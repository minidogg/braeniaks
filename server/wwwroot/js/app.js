/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return Object.propertyIsEnumerable.call(target, symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ "./node_modules/dom-serializer/lib/foreignNames.js":
/*!*********************************************************!*\
  !*** ./node_modules/dom-serializer/lib/foreignNames.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attributeNames = exports.elementNames = void 0;
exports.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath",
].map(function (val) { return [val.toLowerCase(), val]; }));
exports.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan",
].map(function (val) { return [val.toLowerCase(), val]; }));


/***/ }),

/***/ "./node_modules/dom-serializer/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/dom-serializer/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.render = void 0;
/*
 * Module dependencies
 */
var ElementType = __importStar(__webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/lib/index.js"));
var entities_1 = __webpack_require__(/*! entities */ "./node_modules/entities/lib/index.js");
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_js_1 = __webpack_require__(/*! ./foreignNames.js */ "./node_modules/dom-serializer/lib/foreignNames.js");
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
function replaceQuotes(value) {
    return value.replace(/"/g, "&quot;");
}
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    var _a;
    if (!attributes)
        return;
    var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false
        ? replaceQuotes
        : opts.xmlMode || opts.encodeEntities !== "utf8"
            ? entities_1.encodeXML
            : entities_1.escapeAttribute;
    return Object.keys(attributes)
        .map(function (key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return "".concat(key, "=\"").concat(encode(value), "\"");
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options) {
    if (options === void 0) { options = {}; }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
exports.render = render;
exports["default"] = render;
function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render(node.children, options);
        // @ts-expect-error We don't use `Doctype` yet
        case ElementType.Doctype:
        case ElementType.Directive:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<".concat(elem.name);
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " ".concat(attribs);
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</".concat(elem.name, ">");
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<".concat(elem.data, ">");
}
function renderText(elem, opts) {
    var _a;
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data =
            opts.xmlMode || opts.encodeEntities !== "utf8"
                ? (0, entities_1.encodeXML)(data)
                : (0, entities_1.escapeText)(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment(elem) {
    return "<!--".concat(elem.data, "-->");
}


/***/ }),

/***/ "./node_modules/domelementtype/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/domelementtype/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === ElementType.Tag ||
        elem.type === ElementType.Script ||
        elem.type === ElementType.Style);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;


/***/ }),

/***/ "./node_modules/domhandler/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/domhandler/lib/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DomHandler = void 0;
var domelementtype_1 = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/lib/index.js");
var node_js_1 = __webpack_require__(/*! ./node.js */ "./node_modules/domhandler/lib/node.js");
__exportStar(__webpack_require__(/*! ./node.js */ "./node_modules/domhandler/lib/node.js"), exports);
// Default options
var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false,
};
var DomHandler = /** @class */ (function () {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */
        this.dom = [];
        /** The root element for the DOM */
        this.root = new node_js_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */
        this.done = false;
        /** Stack of open tags. */
        this.tagStack = [this.root];
        /** A data node that is still being written to. */
        this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
        if (this.done)
            return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
            this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_js_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
            }
        }
        else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function (data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_js_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
        var text = new node_js_1.Text("");
        var node = new node_js_1.CDATA([text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
        var node = new node_js_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function (node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}());
exports.DomHandler = DomHandler;
exports["default"] = DomHandler;


/***/ }),

/***/ "./node_modules/domhandler/lib/node.js":
/*!*********************************************!*\
  !*** ./node_modules/domhandler/lib/node.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var domelementtype_1 = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/lib/index.js");
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node = /** @class */ (function () {
    function Node() {
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.parent;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.prev;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.next;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    Node.prototype.cloneNode = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        return cloneNode(this, recursive);
    };
    return Node;
}());
exports.Node = Node;
/**
 * A node that contains some data.
 */
var DataNode = /** @class */ (function (_super) {
    __extends(DataNode, _super);
    /**
     * @param data The content of the data node
     */
    function DataNode(data) {
        var _this = _super.call(this) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node));
exports.DataNode = DataNode;
/**
 * Text within the document.
 */
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Text;
        return _this;
    }
    Object.defineProperty(Text.prototype, "nodeType", {
        get: function () {
            return 3;
        },
        enumerable: false,
        configurable: true
    });
    return Text;
}(DataNode));
exports.Text = Text;
/**
 * Comments within the document.
 */
var Comment = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Comment;
        return _this;
    }
    Object.defineProperty(Comment.prototype, "nodeType", {
        get: function () {
            return 8;
        },
        enumerable: false,
        configurable: true
    });
    return Comment;
}(DataNode));
exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, data) || this;
        _this.name = name;
        _this.type = domelementtype_1.ElementType.Directive;
        return _this;
    }
    Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
        get: function () {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    return ProcessingInstruction;
}(DataNode));
exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */ (function (_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(children) {
        var _this = _super.call(this) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        /** Last child of the node. */
        get: function () {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node));
exports.NodeWithChildren = NodeWithChildren;
var CDATA = /** @class */ (function (_super) {
    __extends(CDATA, _super);
    function CDATA() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.CDATA;
        return _this;
    }
    Object.defineProperty(CDATA.prototype, "nodeType", {
        get: function () {
            return 4;
        },
        enumerable: false,
        configurable: true
    });
    return CDATA;
}(NodeWithChildren));
exports.CDATA = CDATA;
/**
 * The root node of the document.
 */
var Document = /** @class */ (function (_super) {
    __extends(Document, _super);
    function Document() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Root;
        return _this;
    }
    Object.defineProperty(Document.prototype, "nodeType", {
        get: function () {
            return 9;
        },
        enumerable: false,
        configurable: true
    });
    return Document;
}(NodeWithChildren));
exports.Document = Document;
/**
 * An element within the DOM.
 */
var Element = /** @class */ (function (_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    function Element(name, attribs, children, type) {
        if (children === void 0) { children = []; }
        if (type === void 0) { type = name === "script"
            ? domelementtype_1.ElementType.Script
            : name === "style"
                ? domelementtype_1.ElementType.Style
                : domelementtype_1.ElementType.Tag; }
        var _this = _super.call(this, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        _this.type = type;
        return _this;
    }
    Object.defineProperty(Element.prototype, "nodeType", {
        get: function () {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
                var _a, _b;
                return ({
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag(node) {
    return (0, domelementtype_1.isTag)(node);
}
exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
}
exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
}
exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
    if (recursive === void 0) { recursive = false; }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    }
    else if (isComment(node)) {
        result = new Comment(node.data);
    }
    else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function (child) { return (child.parent = clone_1); });
        if (node.namespace != null) {
            clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    }
    else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function (child) { return (child.parent = clone_2); });
        result = clone_2;
    }
    else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) { return (child.parent = clone_3); });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    }
    else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
}
exports.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function (child) { return cloneNode(child, true); });
    for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}


/***/ }),

/***/ "./node_modules/domutils/lib/feeds.js":
/*!********************************************!*\
  !*** ./node_modules/domutils/lib/feeds.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFeed = void 0;
var stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/domutils/lib/stringify.js");
var legacy_js_1 = __webpack_require__(/*! ./legacy.js */ "./node_modules/domutils/lib/legacy.js");
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @category Feeds
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot
        ? null
        : feedRoot.name === "feed"
            ? getAtomFeed(feedRoot)
            : getRssFeed(feedRoot);
}
exports.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function (item) {
            var _a;
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
            if (href) {
                entry.link = href;
            }
            var description = fetch("summary", children) || fetch("content", children);
            if (description) {
                entry.description = description;
            }
            var pubDate = fetch("updated", children);
            if (pubDate) {
                entry.pubDate = new Date(pubDate);
            }
            return entry;
        }),
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
    if (href) {
        feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch("updated", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
            if (pubDate)
                entry.pubDate = new Date(pubDate);
            return entry;
        }),
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch("lastBuildDate", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width",
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements(where) {
    return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function (elem) {
        var attribs = elem.attribs;
        var media = {
            medium: attribs["medium"],
            isDefault: !!attribs["isDefault"],
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
            }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
            }
        }
        if (attribs["expression"]) {
            media.expression = attribs["expression"];
        }
        return media;
    });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement(tagName, node) {
    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch(tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally(obj, prop, tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var val = fetch(tagName, where, recurse);
    if (val)
        obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}
//# sourceMappingURL=feeds.js.map

/***/ }),

/***/ "./node_modules/domutils/lib/helpers.js":
/*!**********************************************!*\
  !*** ./node_modules/domutils/lib/helpers.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js");
/**
 * Given an array of nodes, remove any member that is contained by another
 * member.
 *
 * @category Helpers
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't contained by other nodes.
 */
function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
exports.removeSubsets = removeSubsets;
/**
 * @category Helpers
 * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
 */
var DocumentPosition;
(function (DocumentPosition) {
    DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
/**
 * Compare the position of one node against another node in any other document,
 * returning a bitmask with the values from {@link DocumentPosition}.
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent.
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @category Helpers
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
}
exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document,
 * removing any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @category Helpers
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & DocumentPosition.PRECEDING) {
            return -1;
        }
        else if (relative & DocumentPosition.FOLLOWING) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
exports.uniqueSort = uniqueSort;
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ "./node_modules/domutils/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/domutils/lib/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(__webpack_require__(/*! ./stringify.js */ "./node_modules/domutils/lib/stringify.js"), exports);
__exportStar(__webpack_require__(/*! ./traversal.js */ "./node_modules/domutils/lib/traversal.js"), exports);
__exportStar(__webpack_require__(/*! ./manipulation.js */ "./node_modules/domutils/lib/manipulation.js"), exports);
__exportStar(__webpack_require__(/*! ./querying.js */ "./node_modules/domutils/lib/querying.js"), exports);
__exportStar(__webpack_require__(/*! ./legacy.js */ "./node_modules/domutils/lib/legacy.js"), exports);
__exportStar(__webpack_require__(/*! ./helpers.js */ "./node_modules/domutils/lib/helpers.js"), exports);
__exportStar(__webpack_require__(/*! ./feeds.js */ "./node_modules/domutils/lib/feeds.js"), exports);
/** @deprecated Use these methods from `domhandler` directly. */
var domhandler_1 = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js");
Object.defineProperty(exports, "isTag", ({ enumerable: true, get: function () { return domhandler_1.isTag; } }));
Object.defineProperty(exports, "isCDATA", ({ enumerable: true, get: function () { return domhandler_1.isCDATA; } }));
Object.defineProperty(exports, "isText", ({ enumerable: true, get: function () { return domhandler_1.isText; } }));
Object.defineProperty(exports, "isComment", ({ enumerable: true, get: function () { return domhandler_1.isComment; } }));
Object.defineProperty(exports, "isDocument", ({ enumerable: true, get: function () { return domhandler_1.isDocument; } }));
Object.defineProperty(exports, "hasChildren", ({ enumerable: true, get: function () { return domhandler_1.hasChildren; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/domutils/lib/legacy.js":
/*!*********************************************!*\
  !*** ./node_modules/domutils/lib/legacy.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js");
var querying_js_1 = __webpack_require__(/*! ./querying.js */ "./node_modules/domutils/lib/querying.js");
/**
 * A map of functions to check nodes against.
 */
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return domhandler_1.isTag;
        }
        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        return function (elem) { return elem.type === type; };
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };
        }
        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };
    },
};
/**
 * Returns a function to check whether a node has an attribute with a particular
 * value.
 *
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a
 *   particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };
    }
    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };
}
/**
 * Returns a function that returns `true` if either of the input functions
 * returns `true` for a node.
 *
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either of the input
 *   functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
/**
 * Returns a function that executes all checks in `options` and returns `true`
 * if any of them match a node.
 *
 * @param options An object describing nodes to look for.
 * @returns A function that executes all checks in `options` and returns `true`
 *   if any of them match a node.
 */
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key)
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * Checks whether a node matches the description in `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
exports.testElement = testElement;
/**
 * Returns all nodes that match `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
}
exports.getElements = getElements;
/**
 * Returns the node with the supplied ID.
 *
 * @category Legacy Query Functions
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
exports.getElementById = getElementById;
/**
 * Returns all nodes with the supplied `tagName`.
 *
 * @category Legacy Query Functions
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
}
exports.getElementsByTagName = getElementsByTagName;
/**
 * Returns all nodes with the supplied `type`.
 *
 * @category Legacy Query Functions
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
}
exports.getElementsByTagType = getElementsByTagType;
//# sourceMappingURL=legacy.js.map

/***/ }),

/***/ "./node_modules/domutils/lib/manipulation.js":
/*!***************************************************!*\
  !*** ./node_modules/domutils/lib/manipulation.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @category Manipulation
 * @param elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
            childs.splice(childsIndex, 1);
        }
    }
    elem.next = null;
    elem.prev = null;
    elem.parent = null;
}
exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @category Manipulation
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
    }
}
exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @category Manipulation
 * @param parent The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(parent, child) {
    removeElement(child);
    child.next = null;
    child.parent = parent;
    if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    }
    else {
        child.prev = null;
    }
}
exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @category Manipulation
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @category Manipulation
 * @param parent The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(parent, child) {
    removeElement(child);
    child.parent = parent;
    child.prev = null;
    if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
    }
    else {
        child.next = null;
    }
}
exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @category Manipulation
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
exports.prepend = prepend;
//# sourceMappingURL=manipulation.js.map

/***/ }),

/***/ "./node_modules/domutils/lib/querying.js":
/*!***********************************************!*\
  !*** ./node_modules/domutils/lib/querying.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js");
/**
 * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter(test, node, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return find(test, Array.isArray(node) ? node : [node], recurse, limit);
}
exports.filter = filter;
/**
 * Search an array of nodes and their children for nodes passing a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
    var result = [];
    /** Stack of the arrays we are looking at. */
    var nodeStack = [nodes];
    /** Stack of the indices within the arrays. */
    var indexStack = [0];
    for (;;) {
        // First, check if the current array has any more elements to look at.
        if (indexStack[0] >= nodeStack[0].length) {
            // If we have no more arrays to look at, we are done.
            if (indexStack.length === 1) {
                return result;
            }
            // Otherwise, remove the current array from the stack.
            nodeStack.shift();
            indexStack.shift();
            // Loop back to the start to continue with the next array.
            continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                return result;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            /*
             * Add the children to the stack. We are depth-first, so this is
             * the next array we look at.
             */
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
        }
    }
}
exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 * @deprecated Use `Array.prototype.find` directly.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Node or array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first node that passes `test`.
 */
function findOne(test, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
        var node = nodes[i];
        if (!(0, domhandler_1.isTag)(node)) {
            continue;
        }
        else if (test(node)) {
            elem = node;
        }
        else if (recurse && node.children.length > 0) {
            elem = findOne(test, node.children, true);
        }
    }
    return elem;
}
exports.findOne = findOne;
/**
 * Checks if a tree of nodes contains at least one node passing a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing the test.
 */
function existsOne(test, nodes) {
    return nodes.some(function (checked) {
        return (0, domhandler_1.isTag)(checked) &&
            (test(checked) || existsOne(test, checked.children));
    });
}
exports.existsOne = existsOne;
/**
 * Search an array of nodes and their children for elements passing a test function.
 *
 * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
    var result = [];
    var nodeStack = [nodes];
    var indexStack = [0];
    for (;;) {
        if (indexStack[0] >= nodeStack[0].length) {
            if (nodeStack.length === 1) {
                return result;
            }
            // Otherwise, remove the current array from the stack.
            nodeStack.shift();
            indexStack.shift();
            // Loop back to the start to continue with the next array.
            continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (!(0, domhandler_1.isTag)(elem))
            continue;
        if (test(elem))
            result.push(elem);
        if (elem.children.length > 0) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
        }
    }
}
exports.findAll = findAll;
//# sourceMappingURL=querying.js.map

/***/ }),

/***/ "./node_modules/domutils/lib/stringify.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/stringify.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js");
var dom_serializer_1 = __importDefault(__webpack_require__(/*! dom-serializer */ "./node_modules/dom-serializer/lib/index.js"));
var domelementtype_1 = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/lib/index.js");
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return (0, dom_serializer_1.default)(node, options);
}
exports.getOuterHTML = getOuterHTML;
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return (0, domhandler_1.hasChildren)(node)
        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
        : "";
}
exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
 *
 * @category Stringify
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
    if (Array.isArray(node))
        return node.map(getText).join("");
    if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
    if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.getText = getText;
/**
 * Get a node's text content. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
    if (Array.isArray(node))
        return node.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
    }
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.textContent = textContent;
/**
 * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
    if (Array.isArray(node))
        return node.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
    }
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.innerText = innerText;
//# sourceMappingURL=stringify.js.map

/***/ }),

/***/ "./node_modules/domutils/lib/traversal.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/traversal.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js");
/**
 * Get a node's children.
 *
 * @category Traversal
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
}
exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @category Traversal
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node, or `null` if `elem` is a root node.
 */
function getParent(elem) {
    return elem.parent || null;
}
exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first. If we don't
 * have a parent (the element is a root node), we walk the element's `prev` &
 * `next` to get all remaining nodes.
 *
 * @category Traversal
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings, including `elem`.
 */
function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
        return getChildren(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
        siblings.unshift(prev);
        (_a = prev, prev = _a.prev);
    }
    while (next != null) {
        siblings.push(next);
        (_b = next, next = _b.next);
    }
    return siblings;
}
exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @category Traversal
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
    return elem.name;
}
exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
 * sibling.
 */
function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1.isTag)(next))
        (_a = next, next = _a.next);
    return next;
}
exports.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
 * previous sibling.
 */
function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1.isTag)(prev))
        (_a = prev, prev = _a.prev);
    return prev;
}
exports.prevElementSibling = prevElementSibling;
//# sourceMappingURL=traversal.js.map

/***/ }),

/***/ "./node_modules/entities/lib/decode.js":
/*!*********************************************!*\
  !*** ./node_modules/entities/lib/decode.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
var decode_data_html_js_1 = __importDefault(__webpack_require__(/*! ./generated/decode-data-html.js */ "./node_modules/entities/lib/generated/decode-data-html.js"));
exports.htmlDecodeTree = decode_data_html_js_1.default;
var decode_data_xml_js_1 = __importDefault(__webpack_require__(/*! ./generated/decode-data-xml.js */ "./node_modules/entities/lib/generated/decode-data-xml.js"));
exports.xmlDecodeTree = decode_data_xml_js_1.default;
var decode_codepoint_js_1 = __importStar(__webpack_require__(/*! ./decode_codepoint.js */ "./node_modules/entities/lib/decode_codepoint.js"));
exports.decodeCodePoint = decode_codepoint_js_1.default;
var decode_codepoint_js_2 = __webpack_require__(/*! ./decode_codepoint.js */ "./node_modules/entities/lib/decode_codepoint.js");
Object.defineProperty(exports, "replaceCodePoint", ({ enumerable: true, get: function () { return decode_codepoint_js_2.replaceCodePoint; } }));
Object.defineProperty(exports, "fromCodePoint", ({ enumerable: true, get: function () { return decode_codepoint_js_2.fromCodePoint; } }));
var CharCodes;
(function (CharCodes) {
    CharCodes[CharCodes["NUM"] = 35] = "NUM";
    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
    CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
    CharCodes[CharCodes["NINE"] = 57] = "NINE";
    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
    CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
    CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
    CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function (BinTrieFlags) {
    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
function isNumber(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
}
function isAsciiAlphaNumeric(code) {
    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
        isNumber(code));
}
/**
 * Checks if the given character is a valid end character for an entity in an attribute.
 *
 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
 */
function isEntityInAttributeInvalidEnd(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function (EntityDecoderState) {
    EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function (DecodingMode) {
    /** Entities in text nodes that can end with any character. */
    DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
    /** Only allow entities terminated with a semicolon. */
    DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
    /** Entities in attributes have limitations on ending characters. */
    DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
})(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
/**
 * Token decoder with support of writing partial entities.
 */
var EntityDecoder = /** @class */ (function () {
    function EntityDecoder(
    /** The tree used to decode entities. */
    decodeTree, 
    /**
     * The function that is called when a codepoint is decoded.
     *
     * For multi-byte named entities, this will be called multiple times,
     * with the second codepoint, and the same `consumed` value.
     *
     * @param codepoint The decoded codepoint.
     * @param consumed The number of bytes consumed by the decoder.
     */
    emitCodePoint, 
    /** An object that is used to produce errors. */
    errors) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors;
        /** The current state of the decoder. */
        this.state = EntityDecoderState.EntityStart;
        /** Characters that were consumed while parsing an entity. */
        this.consumed = 1;
        /**
         * The result of the entity.
         *
         * Either the result index of a numeric entity, or the codepoint of a
         * numeric entity.
         */
        this.result = 0;
        /** The current index in the decode tree. */
        this.treeIndex = 0;
        /** The number of characters that were consumed in excess. */
        this.excess = 1;
        /** The mode in which the decoder is operating. */
        this.decodeMode = DecodingMode.Strict;
    }
    /** Resets the instance to make it reusable. */
    EntityDecoder.prototype.startEntity = function (decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
    };
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    EntityDecoder.prototype.write = function (str, offset) {
        switch (this.state) {
            case EntityDecoderState.EntityStart: {
                if (str.charCodeAt(offset) === CharCodes.NUM) {
                    this.state = EntityDecoderState.NumericStart;
                    this.consumed += 1;
                    return this.stateNumericStart(str, offset + 1);
                }
                this.state = EntityDecoderState.NamedEntity;
                return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
                return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
                return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
                return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
                return this.stateNamedEntity(str, offset);
            }
        }
    };
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    EntityDecoder.prototype.stateNumericStart = function (str, offset) {
        if (offset >= str.length) {
            return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
    };
    EntityDecoder.prototype.addToNumericResult = function (str, start, end, base) {
        if (start !== end) {
            var digitCount = end - start;
            this.result =
                this.result * Math.pow(base, digitCount) +
                    parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
        }
    };
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    EntityDecoder.prototype.stateNumericHex = function (str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
                offset += 1;
            }
            else {
                this.addToNumericResult(str, startIdx, offset, 16);
                return this.emitNumericEntity(char, 3);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
    };
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    EntityDecoder.prototype.stateNumericDecimal = function (str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char)) {
                offset += 1;
            }
            else {
                this.addToNumericResult(str, startIdx, offset, 10);
                return this.emitNumericEntity(char, 2);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
    };
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */
    EntityDecoder.prototype.emitNumericEntity = function (lastCp, expectedLength) {
        var _a;
        // Ensure we consumed at least one digit.
        if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
        }
        // Figure out if this is a legit end of the entity
        if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
        }
        else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
                this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
    };
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    EntityDecoder.prototype.stateNamedEntity = function (str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        // The mask is the number of bytes of the value, including the current byte.
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
            var char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
                return this.result === 0 ||
                    // If we are parsing an attribute
                    (this.decodeMode === DecodingMode.Attribute &&
                        // We shouldn't have consumed any characters after the entity,
                        (valueLength === 0 ||
                            // And there should be no invalid characters.
                            isEntityInAttributeInvalidEnd(char)))
                    ? 0
                    : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            // If the branch is a value, store it and continue
            if (valueLength !== 0) {
                // If the entity is terminated by a semicolon, we are done.
                if (char === CharCodes.SEMI) {
                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                }
                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                if (this.decodeMode !== DecodingMode.Strict) {
                    this.result = this.treeIndex;
                    this.consumed += this.excess;
                    this.excess = 0;
                }
            }
        }
        return -1;
    };
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */
    EntityDecoder.prototype.emitNotTerminatedNamedEntity = function () {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
    };
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */
    EntityDecoder.prototype.emitNamedEntityData = function (result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1
            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
            : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
            // For multi-byte values, we need to emit the second byte.
            this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
    };
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */
    EntityDecoder.prototype.end = function () {
        var _a;
        switch (this.state) {
            case EntityDecoderState.NamedEntity: {
                // Emit a named entity if we have one.
                return this.result !== 0 &&
                    (this.decodeMode !== DecodingMode.Attribute ||
                        this.result === this.treeIndex)
                    ? this.emitNotTerminatedNamedEntity()
                    : 0;
            }
            // Otherwise, emit a numeric entity if we have one.
            case EntityDecoderState.NumericDecimal: {
                return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
                return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                return 0;
            }
            case EntityDecoderState.EntityStart: {
                // Return 0 if we have no entity.
                return 0;
            }
        }
    };
    return EntityDecoder;
}());
exports.EntityDecoder = EntityDecoder;
/**
 * Creates a function that decodes entities in a string.
 *
 * @param decodeTree The decode tree.
 * @returns A function that decodes entities in a string.
 */
function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function (str) { return (ret += (0, decode_codepoint_js_1.fromCodePoint)(str)); });
    return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
            ret += str.slice(lastIndex, offset);
            decoder.startEntity(decodeMode);
            var len = decoder.write(str, 
            // Skip the "&"
            offset + 1);
            if (len < 0) {
                lastIndex = offset + decoder.end();
                break;
            }
            lastIndex = offset + len;
            // If `len` is 0, skip the current `&` and continue.
            offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        // Make sure we don't keep a reference to the final string.
        ret = "";
        return result;
    };
}
/**
 * Determines the branch of the current node that is taken given the current
 * character. This function is used to traverse the trie.
 *
 * @param decodeTree The trie.
 * @param current The current node.
 * @param nodeIdx The index right after the current node and its value.
 * @param char The current character.
 * @returns The index of the next node, or -1 if no branch is taken.
 */
function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    // Case 1: Single branch encoded in jump offset
    if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    // Case 2: Multiple branches encoded in jump table
    if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount
            ? -1
            : decodeTree[nodeIdx + value] - 1;
    }
    // Case 3: Multiple branches encoded in dictionary
    // Binary search for the character.
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
        var mid = (lo + hi) >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
            lo = mid + 1;
        }
        else if (midVal > char) {
            hi = mid - 1;
        }
        else {
            return decodeTree[mid + branchCount];
        }
    }
    return -1;
}
exports.determineBranch = determineBranch;
var htmlDecoder = getDecoder(decode_data_html_js_1.default);
var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
/**
 * Decodes an HTML string.
 *
 * @param str The string to decode.
 * @param mode The decoding mode.
 * @returns The decoded string.
 */
function decodeHTML(str, mode) {
    if (mode === void 0) { mode = DecodingMode.Legacy; }
    return htmlDecoder(str, mode);
}
exports.decodeHTML = decodeHTML;
/**
 * Decodes an HTML string in an attribute.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
}
exports.decodeHTMLAttribute = decodeHTMLAttribute;
/**
 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
}
exports.decodeHTMLStrict = decodeHTMLStrict;
/**
 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
}
exports.decodeXML = decodeXML;
//# sourceMappingURL=decode.js.map

/***/ }),

/***/ "./node_modules/entities/lib/decode_codepoint.js":
/*!*******************************************************!*\
  !*** ./node_modules/entities/lib/decode_codepoint.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.replaceCodePoint = exports.fromCodePoint = void 0;
var decodeMap = new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376],
]);
/**
 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
 */
exports.fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
    var output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += String.fromCharCode(codePoint);
    return output;
};
/**
 * Replace the given code point with a replacement character if it is a
 * surrogate or is outside the valid range. Otherwise return the code
 * point unchanged.
 */
function replaceCodePoint(codePoint) {
    var _a;
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return 0xfffd;
    }
    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
}
exports.replaceCodePoint = replaceCodePoint;
/**
 * Replace the code point if relevant, then convert it to a string.
 *
 * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
 * @param codePoint The code point to decode.
 * @returns The decoded code point.
 */
function decodeCodePoint(codePoint) {
    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
}
exports["default"] = decodeCodePoint;
//# sourceMappingURL=decode_codepoint.js.map

/***/ }),

/***/ "./node_modules/entities/lib/encode.js":
/*!*********************************************!*\
  !*** ./node_modules/entities/lib/encode.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
var encode_html_js_1 = __importDefault(__webpack_require__(/*! ./generated/encode-html.js */ "./node_modules/entities/lib/generated/encode-html.js"));
var escape_js_1 = __webpack_require__(/*! ./escape.js */ "./node_modules/entities/lib/escape.js");
var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
/**
 * Encodes all characters in the input using HTML entities. This includes
 * characters that are valid ASCII characters in HTML documents, such as `#`.
 *
 * To get a more compact output, consider using the `encodeNonAsciiHTML`
 * function, which will only encode characters that are not valid in HTML
 * documents, as well as non-ASCII characters.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encodeHTML(data) {
    return encodeHTMLTrieRe(htmlReplacer, data);
}
exports.encodeHTML = encodeHTML;
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities. This function will not encode characters that
 * are valid in HTML documents, such as `#`.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encodeNonAsciiHTML(data) {
    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
}
exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
function encodeHTMLTrieRe(regExp, str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = regExp.exec(str)) !== null) {
        var i = match.index;
        ret += str.substring(lastIdx, i);
        var char = str.charCodeAt(i);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
            // We are in a branch. Try to match the next char.
            if (i + 1 < str.length) {
                var nextChar = str.charCodeAt(i + 1);
                var value = typeof next.n === "number"
                    ? next.n === nextChar
                        ? next.o
                        : undefined
                    : next.n.get(nextChar);
                if (value !== undefined) {
                    ret += value;
                    lastIdx = regExp.lastIndex += 1;
                    continue;
                }
            }
            next = next.v;
        }
        // We might have a tree node without a value; skip and use a numeric entity.
        if (next !== undefined) {
            ret += next;
            lastIdx = i + 1;
        }
        else {
            var cp = (0, escape_js_1.getCodePoint)(str, i);
            ret += "&#x".concat(cp.toString(16), ";");
            // Increase by 1 if we have a surrogate pair
            lastIdx = regExp.lastIndex += Number(cp !== char);
        }
    }
    return ret + str.substr(lastIdx);
}
//# sourceMappingURL=encode.js.map

/***/ }),

/***/ "./node_modules/entities/lib/escape.js":
/*!*********************************************!*\
  !*** ./node_modules/entities/lib/escape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"],
]);
// For compatibility with node < 4, we wrap `codePointAt`
exports.getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? function (str, index) { return str.codePointAt(index); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c, index) {
            return (c.charCodeAt(index) & 0xfc00) === 0xd800
                ? (c.charCodeAt(index) - 0xd800) * 0x400 +
                    c.charCodeAt(index + 1) -
                    0xdc00 +
                    0x10000
                : c.charCodeAt(index);
        };
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports.xmlReplacer.exec(str)) !== null) {
        var i = match.index;
        var char = str.charCodeAt(i);
        var next = xmlCodeMap.get(char);
        if (next !== undefined) {
            ret += str.substring(lastIdx, i) + next;
            lastIdx = i + 1;
        }
        else {
            ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
            // Increase by 1 if we have a surrogate pair
            lastIdx = exports.xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
        }
    }
    return ret + str.substr(lastIdx);
}
exports.encodeXML = encodeXML;
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
exports.escape = encodeXML;
/**
 * Creates a function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 *
 * @param regex Regular expression to match characters to escape.
 * @param map Map of characters to escape to their entities.
 *
 * @returns Function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 */
function getEscaper(regex, map) {
    return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while ((match = regex.exec(data))) {
            if (lastIdx !== match.index) {
                result += data.substring(lastIdx, match.index);
            }
            // We know that this character will be in the map.
            result += map.get(match[0].charCodeAt(0));
            // Every match will be of length 1
            lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
    };
}
/**
 * Encodes all characters not valid in XML documents using XML entities.
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
/**
 * Encodes all characters that have to be escaped in HTML attributes,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"],
]));
/**
 * Encodes all characters that have to be escaped in HTML text,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"],
]));
//# sourceMappingURL=escape.js.map

/***/ }),

/***/ "./node_modules/entities/lib/generated/decode-data-html.js":
/*!*****************************************************************!*\
  !*** ./node_modules/entities/lib/generated/decode-data-html.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated using scripts/write-decode-map.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = new Uint16Array(
// prettier-ignore
"\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
    .split("")
    .map(function (c) { return c.charCodeAt(0); }));
//# sourceMappingURL=decode-data-html.js.map

/***/ }),

/***/ "./node_modules/entities/lib/generated/decode-data-xml.js":
/*!****************************************************************!*\
  !*** ./node_modules/entities/lib/generated/decode-data-xml.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated using scripts/write-decode-map.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = new Uint16Array(
// prettier-ignore
"\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
    .split("")
    .map(function (c) { return c.charCodeAt(0); }));
//# sourceMappingURL=decode-data-xml.js.map

/***/ }),

/***/ "./node_modules/entities/lib/generated/encode-html.js":
/*!************************************************************!*\
  !*** ./node_modules/entities/lib/generated/encode-html.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated using scripts/write-encode-map.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
function restoreDiff(arr) {
    for (var i = 1; i < arr.length; i++) {
        arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
}
// prettier-ignore
exports["default"] = new Map(/* #__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* #__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
//# sourceMappingURL=encode-html.js.map

/***/ }),

/***/ "./node_modules/entities/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/entities/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;
var decode_js_1 = __webpack_require__(/*! ./decode.js */ "./node_modules/entities/lib/decode.js");
var encode_js_1 = __webpack_require__(/*! ./encode.js */ "./node_modules/entities/lib/encode.js");
var escape_js_1 = __webpack_require__(/*! ./escape.js */ "./node_modules/entities/lib/escape.js");
/** The level of entities to support. */
var EntityLevel;
(function (EntityLevel) {
    /** Support only XML entities. */
    EntityLevel[EntityLevel["XML"] = 0] = "XML";
    /** Support HTML entities, which are a superset of XML entities. */
    EntityLevel[EntityLevel["HTML"] = 1] = "HTML";
})(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
var EncodingMode;
(function (EncodingMode) {
    /**
     * The output is UTF-8 encoded. Only characters that need escaping within
     * XML will be escaped.
     */
    EncodingMode[EncodingMode["UTF8"] = 0] = "UTF8";
    /**
     * The output consists only of ASCII characters. Characters that need
     * escaping within HTML, and characters that aren't ASCII characters will
     * be escaped.
     */
    EncodingMode[EncodingMode["ASCII"] = 1] = "ASCII";
    /**
     * Encode all characters that have an equivalent entity, as well as all
     * characters that are not ASCII characters.
     */
    EncodingMode[EncodingMode["Extensive"] = 2] = "Extensive";
    /**
     * Encode all characters that have to be escaped in HTML attributes,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */
    EncodingMode[EncodingMode["Attribute"] = 3] = "Attribute";
    /**
     * Encode all characters that have to be escaped in HTML text,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */
    EncodingMode[EncodingMode["Text"] = 4] = "Text";
})(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 */
function decode(data, options) {
    if (options === void 0) { options = EntityLevel.XML; }
    var level = typeof options === "number" ? options : options.level;
    if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : undefined;
        return (0, decode_js_1.decodeHTML)(data, mode);
    }
    return (0, decode_js_1.decodeXML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 * @deprecated Use `decode` with the `mode` set to `Strict`.
 */
function decodeStrict(data, options) {
    var _a;
    if (options === void 0) { options = EntityLevel.XML; }
    var opts = typeof options === "number" ? { level: options } : options;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : (opts.mode = decode_js_1.DecodingMode.Strict);
    return decode(data, opts);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param options Encoding options.
 */
function encode(data, options) {
    if (options === void 0) { options = EntityLevel.XML; }
    var opts = typeof options === "number" ? { level: options } : options;
    // Mode `UTF8` just escapes XML entities
    if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
    if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
    if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
    if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
            return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
    }
    // ASCII and Extensive are equivalent
    return (0, escape_js_1.encodeXML)(data);
}
exports.encode = encode;
var escape_js_2 = __webpack_require__(/*! ./escape.js */ "./node_modules/entities/lib/escape.js");
Object.defineProperty(exports, "encodeXML", ({ enumerable: true, get: function () { return escape_js_2.encodeXML; } }));
Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));
Object.defineProperty(exports, "escapeUTF8", ({ enumerable: true, get: function () { return escape_js_2.escapeUTF8; } }));
Object.defineProperty(exports, "escapeAttribute", ({ enumerable: true, get: function () { return escape_js_2.escapeAttribute; } }));
Object.defineProperty(exports, "escapeText", ({ enumerable: true, get: function () { return escape_js_2.escapeText; } }));
var encode_js_2 = __webpack_require__(/*! ./encode.js */ "./node_modules/entities/lib/encode.js");
Object.defineProperty(exports, "encodeHTML", ({ enumerable: true, get: function () { return encode_js_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeNonAsciiHTML", ({ enumerable: true, get: function () { return encode_js_2.encodeNonAsciiHTML; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", ({ enumerable: true, get: function () { return encode_js_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeHTML5", ({ enumerable: true, get: function () { return encode_js_2.encodeHTML; } }));
var decode_js_2 = __webpack_require__(/*! ./decode.js */ "./node_modules/entities/lib/decode.js");
Object.defineProperty(exports, "EntityDecoder", ({ enumerable: true, get: function () { return decode_js_2.EntityDecoder; } }));
Object.defineProperty(exports, "DecodingMode", ({ enumerable: true, get: function () { return decode_js_2.DecodingMode; } }));
Object.defineProperty(exports, "decodeXML", ({ enumerable: true, get: function () { return decode_js_2.decodeXML; } }));
Object.defineProperty(exports, "decodeHTML", ({ enumerable: true, get: function () { return decode_js_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTMLStrict", ({ enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeHTMLAttribute", ({ enumerable: true, get: function () { return decode_js_2.decodeHTMLAttribute; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", ({ enumerable: true, get: function () { return decode_js_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML5", ({ enumerable: true, get: function () { return decode_js_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML4Strict", ({ enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeHTML5Strict", ({ enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeXMLStrict", ({ enumerable: true, get: function () { return decode_js_2.decodeXML; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/escape-string-regexp/index.js":
/*!****************************************************!*\
  !*** ./node_modules/escape-string-regexp/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";


module.exports = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when it’s always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
};


/***/ }),

/***/ "./node_modules/htmlparser2/lib/Parser.js":
/*!************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Parser.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parser = void 0;
var Tokenizer_js_1 = __importStar(__webpack_require__(/*! ./Tokenizer.js */ "./node_modules/htmlparser2/lib/Tokenizer.js"));
var decode_js_1 = __webpack_require__(/*! entities/lib/decode.js */ "./node_modules/entities/lib/decode.js");
var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea",
]);
var pTag = new Set(["p"]);
var tableSectionTags = new Set(["thead", "tbody"]);
var ddtTags = new Set(["dd", "dt"]);
var rtpTags = new Set(["rt", "rp"]);
var openImpliesClose = new Map([
    ["tr", new Set(["tr", "th", "td"])],
    ["th", new Set(["th"])],
    ["td", new Set(["thead", "th", "td"])],
    ["body", new Set(["head", "link", "script"])],
    ["li", new Set(["li"])],
    ["p", pTag],
    ["h1", pTag],
    ["h2", pTag],
    ["h3", pTag],
    ["h4", pTag],
    ["h5", pTag],
    ["h6", pTag],
    ["select", formTags],
    ["input", formTags],
    ["output", formTags],
    ["button", formTags],
    ["datalist", formTags],
    ["textarea", formTags],
    ["option", new Set(["option"])],
    ["optgroup", new Set(["optgroup", "option"])],
    ["dd", ddtTags],
    ["dt", ddtTags],
    ["address", pTag],
    ["article", pTag],
    ["aside", pTag],
    ["blockquote", pTag],
    ["details", pTag],
    ["div", pTag],
    ["dl", pTag],
    ["fieldset", pTag],
    ["figcaption", pTag],
    ["figure", pTag],
    ["footer", pTag],
    ["form", pTag],
    ["header", pTag],
    ["hr", pTag],
    ["main", pTag],
    ["nav", pTag],
    ["ol", pTag],
    ["pre", pTag],
    ["section", pTag],
    ["table", pTag],
    ["ul", pTag],
    ["rt", rtpTags],
    ["rp", rtpTags],
    ["tbody", tableSectionTags],
    ["tfoot", tableSectionTags],
]);
var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title",
]);
var reNameEnd = /\s|\//;
var Parser = /** @class */ (function () {
    function Parser(cbs, options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d, _e;
        this.options = options;
        /** The start index of the last event. */
        this.startIndex = 0;
        /** The end index of the last event. */
        this.endIndex = 0;
        /**
         * Store the start index of the current open tag,
         * so we can update the start index for attributes.
         */
        this.openTagStart = 0;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.buffers = [];
        this.bufferOffset = 0;
        /** The index of the last written buffer. Used when resuming after a `pause()`. */
        this.writeIndex = 0;
        /** Indicates whether the parser has finished running / `.end` has been called. */
        this.ended = false;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
        this.lowerCaseAttributeNames =
            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    // Tokenizer event handlers
    /** @internal */
    Parser.prototype.ontext = function (start, endIndex) {
        var _a, _b;
        var data = this.getSlice(start, endIndex);
        this.endIndex = endIndex - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
        this.startIndex = endIndex;
    };
    /** @internal */
    Parser.prototype.ontextentity = function (cp) {
        var _a, _b;
        /*
         * Entities can be emitted on the character, or directly after.
         * We use the section start here to get accurate indices.
         */
        var index = this.tokenizer.getSectionStart();
        this.endIndex = index - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
        this.startIndex = index;
    };
    Parser.prototype.isVoidElement = function (name) {
        return !this.options.xmlMode && voidElements.has(name);
    };
    /** @internal */
    Parser.prototype.onopentagname = function (start, endIndex) {
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        this.emitOpenTag(name);
    };
    Parser.prototype.emitOpenTag = function (name) {
        var _a, _b, _c, _d;
        this.openTagStart = this.startIndex;
        this.tagname = name;
        var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
        if (impliesClose) {
            while (this.stack.length > 0 &&
                impliesClose.has(this.stack[this.stack.length - 1])) {
                var element = this.stack.pop();
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
            }
        }
        if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
            }
            else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
            }
        }
        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
        if (this.cbs.onopentag)
            this.attribs = {};
    };
    Parser.prototype.endOpenTag = function (isImplied) {
        var _a, _b;
        this.startIndex = this.openTagStart;
        if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
            this.attribs = null;
        }
        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
        }
        this.tagname = "";
    };
    /** @internal */
    Parser.prototype.onopentagend = function (endIndex) {
        this.endIndex = endIndex;
        this.endOpenTag(false);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.onclosetag = function (start, endIndex) {
        var _a, _b, _c, _d, _e, _f;
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) ||
            htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
        }
        if (!this.isVoidElement(name)) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
                if (this.cbs.onclosetag) {
                    var count = this.stack.length - pos;
                    while (count--) {
                        // We know the stack has sufficient elements.
                        this.cbs.onclosetag(this.stack.pop(), count !== 0);
                    }
                }
                else
                    this.stack.length = pos;
            }
            else if (!this.options.xmlMode && name === "p") {
                // Implicit open before close
                this.emitOpenTag("p");
                this.closeCurrentTag(true);
            }
        }
        else if (!this.options.xmlMode && name === "br") {
            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.onselfclosingtag = function (endIndex) {
        this.endIndex = endIndex;
        if (this.options.xmlMode ||
            this.options.recognizeSelfClosing ||
            this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        else {
            // Ignore the fact that the tag is self-closing.
            this.onopentagend(endIndex);
        }
    };
    Parser.prototype.closeCurrentTag = function (isOpenImplied) {
        var _a, _b;
        var name = this.tagname;
        this.endOpenTag(isOpenImplied);
        // Self-closing tags will be on the top of the stack
        if (this.stack[this.stack.length - 1] === name) {
            // If the opening tag isn't implied, the closing tag has to be implied.
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
            this.stack.pop();
        }
    };
    /** @internal */
    Parser.prototype.onattribname = function (start, endIndex) {
        this.startIndex = start;
        var name = this.getSlice(start, endIndex);
        this.attribname = this.lowerCaseAttributeNames
            ? name.toLowerCase()
            : name;
    };
    /** @internal */
    Parser.prototype.onattribdata = function (start, endIndex) {
        this.attribvalue += this.getSlice(start, endIndex);
    };
    /** @internal */
    Parser.prototype.onattribentity = function (cp) {
        this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
    };
    /** @internal */
    Parser.prototype.onattribend = function (quote, endIndex) {
        var _a, _b;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double
            ? '"'
            : quote === Tokenizer_js_1.QuoteType.Single
                ? "'"
                : quote === Tokenizer_js_1.QuoteType.NoValue
                    ? undefined
                    : null);
        if (this.attribs &&
            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribvalue = "";
    };
    Parser.prototype.getInstructionName = function (value) {
        var index = value.search(reNameEnd);
        var name = index < 0 ? value : value.substr(0, index);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        return name;
    };
    /** @internal */
    Parser.prototype.ondeclaration = function (start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.onprocessinginstruction = function (start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.oncomment = function (start, endIndex, offset) {
        var _a, _b, _c, _d;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.oncdata = function (start, endIndex, offset) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex - offset);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        }
        else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.onend = function () {
        var _a, _b;
        if (this.cbs.onclosetag) {
            // Set the end index for all remaining tags
            this.endIndex = this.startIndex;
            for (var index = this.stack.length; index > 0; this.cbs.onclosetag(this.stack[--index], true))
                ;
        }
        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */
    Parser.prototype.reset = function () {
        var _a, _b, _c, _d;
        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack.length = 0;
        this.startIndex = 0;
        this.endIndex = 0;
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this.buffers.length = 0;
        this.bufferOffset = 0;
        this.writeIndex = 0;
        this.ended = false;
    };
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */
    Parser.prototype.parseComplete = function (data) {
        this.reset();
        this.end(data);
    };
    Parser.prototype.getSlice = function (start, end) {
        while (start - this.bufferOffset >= this.buffers[0].length) {
            this.shiftBuffer();
        }
        var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
        while (end - this.bufferOffset > this.buffers[0].length) {
            this.shiftBuffer();
            slice += this.buffers[0].slice(0, end - this.bufferOffset);
        }
        return slice;
    };
    Parser.prototype.shiftBuffer = function () {
        this.bufferOffset += this.buffers[0].length;
        this.writeIndex--;
        this.buffers.shift();
    };
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */
    Parser.prototype.write = function (chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
            return;
        }
        this.buffers.push(chunk);
        if (this.tokenizer.running) {
            this.tokenizer.write(chunk);
            this.writeIndex++;
        }
    };
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */
    Parser.prototype.end = function (chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
            return;
        }
        if (chunk)
            this.write(chunk);
        this.ended = true;
        this.tokenizer.end();
    };
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */
    Parser.prototype.pause = function () {
        this.tokenizer.pause();
    };
    /**
     * Resumes parsing after `pause` was called.
     */
    Parser.prototype.resume = function () {
        this.tokenizer.resume();
        while (this.tokenizer.running &&
            this.writeIndex < this.buffers.length) {
            this.tokenizer.write(this.buffers[this.writeIndex++]);
        }
        if (this.ended)
            this.tokenizer.end();
    };
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */
    Parser.prototype.parseChunk = function (chunk) {
        this.write(chunk);
    };
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */
    Parser.prototype.done = function (chunk) {
        this.end(chunk);
    };
    return Parser;
}());
exports.Parser = Parser;
//# sourceMappingURL=Parser.js.map

/***/ }),

/***/ "./node_modules/htmlparser2/lib/Tokenizer.js":
/*!***************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Tokenizer.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuoteType = void 0;
var decode_js_1 = __webpack_require__(/*! entities/lib/decode.js */ "./node_modules/entities/lib/decode.js");
var CharCodes;
(function (CharCodes) {
    CharCodes[CharCodes["Tab"] = 9] = "Tab";
    CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
    CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
    CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes[CharCodes["Space"] = 32] = "Space";
    CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes[CharCodes["Number"] = 35] = "Number";
    CharCodes[CharCodes["Amp"] = 38] = "Amp";
    CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
    CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes[CharCodes["Dash"] = 45] = "Dash";
    CharCodes[CharCodes["Slash"] = 47] = "Slash";
    CharCodes[CharCodes["Zero"] = 48] = "Zero";
    CharCodes[CharCodes["Nine"] = 57] = "Nine";
    CharCodes[CharCodes["Semi"] = 59] = "Semi";
    CharCodes[CharCodes["Lt"] = 60] = "Lt";
    CharCodes[CharCodes["Eq"] = 61] = "Eq";
    CharCodes[CharCodes["Gt"] = 62] = "Gt";
    CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
    CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
    CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
    CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
    CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
    CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
    CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
    CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
    CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
/** All the states the tokenizer can be in. */
var State;
(function (State) {
    State[State["Text"] = 1] = "Text";
    State[State["BeforeTagName"] = 2] = "BeforeTagName";
    State[State["InTagName"] = 3] = "InTagName";
    State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State[State["InClosingTagName"] = 6] = "InClosingTagName";
    State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    // Attributes
    State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State[State["InAttributeName"] = 9] = "InAttributeName";
    State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
    State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    // Declarations
    State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State[State["InDeclaration"] = 16] = "InDeclaration";
    // Processing instructions
    State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    // Comments & CDATA
    State[State["BeforeComment"] = 18] = "BeforeComment";
    State[State["CDATASequence"] = 19] = "CDATASequence";
    State[State["InSpecialComment"] = 20] = "InSpecialComment";
    State[State["InCommentLike"] = 21] = "InCommentLike";
    // Special tags
    State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State[State["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State[State["InSpecialTag"] = 24] = "InSpecialTag";
    State[State["BeforeEntity"] = 25] = "BeforeEntity";
    State[State["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State[State["InNamedEntity"] = 27] = "InNamedEntity";
    State[State["InNumericEntity"] = 28] = "InNumericEntity";
    State[State["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c) {
    return (c === CharCodes.Space ||
        c === CharCodes.NewLine ||
        c === CharCodes.Tab ||
        c === CharCodes.FormFeed ||
        c === CharCodes.CarriageReturn);
}
function isEndOfTagSection(c) {
    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
}
function isNumber(c) {
    return c >= CharCodes.Zero && c <= CharCodes.Nine;
}
function isASCIIAlpha(c) {
    return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));
}
function isHexDigit(c) {
    return ((c >= CharCodes.UpperA && c <= CharCodes.UpperF) ||
        (c >= CharCodes.LowerA && c <= CharCodes.LowerF));
}
var QuoteType;
(function (QuoteType) {
    QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
    QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
    QuoteType[QuoteType["Single"] = 2] = "Single";
    QuoteType[QuoteType["Double"] = 3] = "Double";
})(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
/**
 * Sequences used to match longer strings.
 *
 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
 * sequences with an increased offset.
 */
var Sequences = {
    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),
    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),
    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),
    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),
    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),
    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
};
var Tokenizer = /** @class */ (function () {
    function Tokenizer(_a, cbs) {
        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
        this.cbs = cbs;
        /** The current state the tokenizer is in. */
        this.state = State.Text;
        /** The read buffer. */
        this.buffer = "";
        /** The beginning of the section that is currently being read. */
        this.sectionStart = 0;
        /** The index within the buffer that we are currently looking at. */
        this.index = 0;
        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
        this.baseState = State.Text;
        /** For special parsing behavior inside of script and style tags. */
        this.isSpecial = false;
        /** Indicates whether the tokenizer has been paused. */
        this.running = true;
        /** The offset of the current buffer. */
        this.offset = 0;
        this.currentSequence = undefined;
        this.sequenceIndex = 0;
        this.trieIndex = 0;
        this.trieCurrent = 0;
        /** For named entities, the index of the value. For numeric entities, the code point. */
        this.entityResult = 0;
        this.entityExcess = 0;
        this.xmlMode = xmlMode;
        this.decodeEntities = decodeEntities;
        this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
    }
    Tokenizer.prototype.reset = function () {
        this.state = State.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State.Text;
        this.currentSequence = undefined;
        this.running = true;
        this.offset = 0;
    };
    Tokenizer.prototype.write = function (chunk) {
        this.offset += this.buffer.length;
        this.buffer = chunk;
        this.parse();
    };
    Tokenizer.prototype.end = function () {
        if (this.running)
            this.finish();
    };
    Tokenizer.prototype.pause = function () {
        this.running = false;
    };
    Tokenizer.prototype.resume = function () {
        this.running = true;
        if (this.index < this.buffer.length + this.offset) {
            this.parse();
        }
    };
    /**
     * The current index within all of the written data.
     */
    Tokenizer.prototype.getIndex = function () {
        return this.index;
    };
    /**
     * The start of the current section.
     */
    Tokenizer.prototype.getSectionStart = function () {
        return this.sectionStart;
    };
    Tokenizer.prototype.stateText = function (c) {
        if (c === CharCodes.Lt ||
            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
            if (this.index > this.sectionStart) {
                this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State.BeforeTagName;
            this.sectionStart = this.index;
        }
        else if (this.decodeEntities && c === CharCodes.Amp) {
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateSpecialStartSequence = function (c) {
        var isEnd = this.sequenceIndex === this.currentSequence.length;
        var isMatch = isEnd
            ? // If we are at the end of the sequence, make sure the tag name has ended
                isEndOfTagSection(c)
            : // Otherwise, do a case-insensitive comparison
                (c | 0x20) === this.currentSequence[this.sequenceIndex];
        if (!isMatch) {
            this.isSpecial = false;
        }
        else if (!isEnd) {
            this.sequenceIndex++;
            return;
        }
        this.sequenceIndex = 0;
        this.state = State.InTagName;
        this.stateInTagName(c);
    };
    /** Look for an end tag. For <title> tags, also decode entities. */
    Tokenizer.prototype.stateInSpecialTag = function (c) {
        if (this.sequenceIndex === this.currentSequence.length) {
            if (c === CharCodes.Gt || isWhitespace(c)) {
                var endOfText = this.index - this.currentSequence.length;
                if (this.sectionStart < endOfText) {
                    // Spoof the index so that reported locations match up.
                    var actualIndex = this.index;
                    this.index = endOfText;
                    this.cbs.ontext(this.sectionStart, endOfText);
                    this.index = actualIndex;
                }
                this.isSpecial = false;
                this.sectionStart = endOfText + 2; // Skip over the `</`
                this.stateInClosingTagName(c);
                return; // We are done; skip the rest of the function.
            }
            this.sequenceIndex = 0;
        }
        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
        }
        else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
                // We have to parse entities in <title> tags.
                if (this.decodeEntities && c === CharCodes.Amp) {
                    this.state = State.BeforeEntity;
                }
            }
            else if (this.fastForwardTo(CharCodes.Lt)) {
                // Outside of <title> tags, we can fast-forward.
                this.sequenceIndex = 1;
            }
        }
        else {
            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
            this.sequenceIndex = Number(c === CharCodes.Lt);
        }
    };
    Tokenizer.prototype.stateCDATASequence = function (c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
                this.state = State.InCommentLike;
                this.currentSequence = Sequences.CdataEnd;
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
            }
        }
        else {
            this.sequenceIndex = 0;
            this.state = State.InDeclaration;
            this.stateInDeclaration(c); // Reconsume the character
        }
    };
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */
    Tokenizer.prototype.fastForwardTo = function (c) {
        while (++this.index < this.buffer.length + this.offset) {
            if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                return true;
            }
        }
        /*
         * We increment the index at the end of the `parse` loop,
         * so set it to `buffer.length - 1` here.
         *
         * TODO: Refactor `parse` to increment index before calling states.
         */
        this.index = this.buffer.length + this.offset - 1;
        return false;
    };
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */
    Tokenizer.prototype.stateInCommentLike = function (c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
                if (this.currentSequence === Sequences.CdataEnd) {
                    this.cbs.oncdata(this.sectionStart, this.index, 2);
                }
                else {
                    this.cbs.oncomment(this.sectionStart, this.index, 2);
                }
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
                this.state = State.Text;
            }
        }
        else if (this.sequenceIndex === 0) {
            // Fast-forward to the first character of the sequence
            if (this.fastForwardTo(this.currentSequence[0])) {
                this.sequenceIndex = 1;
            }
        }
        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
            // Allow long sequences, eg. --->, ]]]>
            this.sequenceIndex = 0;
        }
    };
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */
    Tokenizer.prototype.isTagStartChar = function (c) {
        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
    };
    Tokenizer.prototype.startSpecial = function (sequence, offset) {
        this.isSpecial = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
        this.state = State.SpecialStartSequence;
    };
    Tokenizer.prototype.stateBeforeTagName = function (c) {
        if (c === CharCodes.ExclamationMark) {
            this.state = State.BeforeDeclaration;
            this.sectionStart = this.index + 1;
        }
        else if (c === CharCodes.Questionmark) {
            this.state = State.InProcessingInstruction;
            this.sectionStart = this.index + 1;
        }
        else if (this.isTagStartChar(c)) {
            var lower = c | 0x20;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
                this.startSpecial(Sequences.TitleEnd, 3);
            }
            else {
                this.state =
                    !this.xmlMode && lower === Sequences.ScriptEnd[2]
                        ? State.BeforeSpecialS
                        : State.InTagName;
            }
        }
        else if (c === CharCodes.Slash) {
            this.state = State.BeforeClosingTagName;
        }
        else {
            this.state = State.Text;
            this.stateText(c);
        }
    };
    Tokenizer.prototype.stateInTagName = function (c) {
        if (isEndOfTagSection(c)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    };
    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
        if (isWhitespace(c)) {
            // Ignore
        }
        else if (c === CharCodes.Gt) {
            this.state = State.Text;
        }
        else {
            this.state = this.isTagStartChar(c)
                ? State.InClosingTagName
                : State.InSpecialComment;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateInClosingTagName = function (c) {
        if (c === CharCodes.Gt || isWhitespace(c)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterClosingTagName;
            this.stateAfterClosingTagName(c);
        }
    };
    Tokenizer.prototype.stateAfterClosingTagName = function (c) {
        // Skip everything until ">"
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.state = State.Text;
            this.baseState = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeName = function (c) {
        if (c === CharCodes.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
                this.state = State.InSpecialTag;
                this.sequenceIndex = 0;
            }
            else {
                this.state = State.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
        }
        else if (c === CharCodes.Slash) {
            this.state = State.InSelfClosingTag;
        }
        else if (!isWhitespace(c)) {
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateInSelfClosingTag = function (c) {
        if (c === CharCodes.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State.Text;
            this.baseState = State.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false; // Reset special state, in case of self-closing special tags
        }
        else if (!isWhitespace(c)) {
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    };
    Tokenizer.prototype.stateInAttributeName = function (c) {
        if (c === CharCodes.Eq || isEndOfTagSection(c)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterAttributeName;
            this.stateAfterAttributeName(c);
        }
    };
    Tokenizer.prototype.stateAfterAttributeName = function (c) {
        if (c === CharCodes.Eq) {
            this.state = State.BeforeAttributeValue;
        }
        else if (c === CharCodes.Slash || c === CharCodes.Gt) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
        else if (!isWhitespace(c)) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
        if (c === CharCodes.DoubleQuote) {
            this.state = State.InAttributeValueDq;
            this.sectionStart = this.index + 1;
        }
        else if (c === CharCodes.SingleQuote) {
            this.state = State.InAttributeValueSq;
            this.sectionStart = this.index + 1;
        }
        else if (!isWhitespace(c)) {
            this.sectionStart = this.index;
            this.state = State.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c); // Reconsume token
        }
    };
    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
        if (c === quote ||
            (!this.decodeEntities && this.fastForwardTo(quote))) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === CharCodes.DoubleQuote
                ? QuoteType.Double
                : QuoteType.Single, this.index);
            this.state = State.BeforeAttributeName;
        }
        else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
        this.handleInAttributeValue(c, CharCodes.DoubleQuote);
    };
    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
        this.handleInAttributeValue(c, CharCodes.SingleQuote);
    };
    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
        if (isWhitespace(c) || c === CharCodes.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType.Unquoted, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
        else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateBeforeDeclaration = function (c) {
        if (c === CharCodes.OpeningSquareBracket) {
            this.state = State.CDATASequence;
            this.sequenceIndex = 0;
        }
        else {
            this.state =
                c === CharCodes.Dash
                    ? State.BeforeComment
                    : State.InDeclaration;
        }
    };
    Tokenizer.prototype.stateInDeclaration = function (c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateInProcessingInstruction = function (c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeComment = function (c) {
        if (c === CharCodes.Dash) {
            this.state = State.InCommentLike;
            this.currentSequence = Sequences.CommentEnd;
            // Allow short comments (eg. <!-->)
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
        }
        else {
            this.state = State.InDeclaration;
        }
    };
    Tokenizer.prototype.stateInSpecialComment = function (c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeSpecialS = function (c) {
        var lower = c | 0x20;
        if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
        }
        else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
        }
        else {
            this.state = State.InTagName;
            this.stateInTagName(c); // Consume the token again
        }
    };
    Tokenizer.prototype.stateBeforeEntity = function (c) {
        // Start excess with 1 to include the '&'
        this.entityExcess = 1;
        this.entityResult = 0;
        if (c === CharCodes.Number) {
            this.state = State.BeforeNumericEntity;
        }
        else if (c === CharCodes.Amp) {
            // We have two `&` characters in a row. Stay in the current state.
        }
        else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State.InNamedEntity;
            this.stateInNamedEntity(c);
        }
    };
    Tokenizer.prototype.stateInNamedEntity = function (c) {
        this.entityExcess += 1;
        this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
        if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
        // If the branch is a value, store it and continue
        if (masked) {
            // The mask is the number of bytes of the value, including the current byte.
            var valueLength = (masked >> 14) - 1;
            // If we have a legacy entity while parsing strictly, just skip the number of bytes
            if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
                this.trieIndex += valueLength;
            }
            else {
                // Add 1 as we have already incremented the excess
                var entityStart = this.index - this.entityExcess + 1;
                if (entityStart > this.sectionStart) {
                    this.emitPartial(this.sectionStart, entityStart);
                }
                // If this is a surrogate pair, consume the next two bytes
                this.entityResult = this.trieIndex;
                this.trieIndex += valueLength;
                this.entityExcess = 0;
                this.sectionStart = this.index + 1;
                if (valueLength === 0) {
                    this.emitNamedEntity();
                }
            }
        }
    };
    Tokenizer.prototype.emitNamedEntity = function () {
        this.state = this.baseState;
        if (this.entityResult === 0) {
            return;
        }
        var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >>
            14;
        switch (valueLength) {
            case 1: {
                this.emitCodePoint(this.entityTrie[this.entityResult] &
                    ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
                break;
            }
            case 2: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
            }
            case 3: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
        }
    };
    Tokenizer.prototype.stateBeforeNumericEntity = function (c) {
        if ((c | 0x20) === CharCodes.LowerX) {
            this.entityExcess++;
            this.state = State.InHexEntity;
        }
        else {
            this.state = State.InNumericEntity;
            this.stateInNumericEntity(c);
        }
    };
    Tokenizer.prototype.emitNumericEntity = function (strict) {
        var entityStart = this.index - this.entityExcess - 1;
        var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
        if (numberStart !== this.index) {
            // Emit leading data if any
            if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
        }
        this.state = this.baseState;
    };
    Tokenizer.prototype.stateInNumericEntity = function (c) {
        if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
        }
        else if (isNumber(c)) {
            this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
            this.entityExcess++;
        }
        else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            }
            else {
                this.state = this.baseState;
            }
            this.index--;
        }
    };
    Tokenizer.prototype.stateInHexEntity = function (c) {
        if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
        }
        else if (isNumber(c)) {
            this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
            this.entityExcess++;
        }
        else if (isHexDigit(c)) {
            this.entityResult =
                this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);
            this.entityExcess++;
        }
        else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            }
            else {
                this.state = this.baseState;
            }
            this.index--;
        }
    };
    Tokenizer.prototype.allowLegacyEntity = function () {
        return (!this.xmlMode &&
            (this.baseState === State.Text ||
                this.baseState === State.InSpecialTag));
    };
    /**
     * Remove data that has already been consumed from the buffer.
     */
    Tokenizer.prototype.cleanup = function () {
        // If we are inside of text or attributes, emit what we already have.
        if (this.running && this.sectionStart !== this.index) {
            if (this.state === State.Text ||
                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
                this.cbs.ontext(this.sectionStart, this.index);
                this.sectionStart = this.index;
            }
            else if (this.state === State.InAttributeValueDq ||
                this.state === State.InAttributeValueSq ||
                this.state === State.InAttributeValueNq) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = this.index;
            }
        }
    };
    Tokenizer.prototype.shouldContinue = function () {
        return this.index < this.buffer.length + this.offset && this.running;
    };
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    Tokenizer.prototype.parse = function () {
        while (this.shouldContinue()) {
            var c = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
                case State.Text: {
                    this.stateText(c);
                    break;
                }
                case State.SpecialStartSequence: {
                    this.stateSpecialStartSequence(c);
                    break;
                }
                case State.InSpecialTag: {
                    this.stateInSpecialTag(c);
                    break;
                }
                case State.CDATASequence: {
                    this.stateCDATASequence(c);
                    break;
                }
                case State.InAttributeValueDq: {
                    this.stateInAttributeValueDoubleQuotes(c);
                    break;
                }
                case State.InAttributeName: {
                    this.stateInAttributeName(c);
                    break;
                }
                case State.InCommentLike: {
                    this.stateInCommentLike(c);
                    break;
                }
                case State.InSpecialComment: {
                    this.stateInSpecialComment(c);
                    break;
                }
                case State.BeforeAttributeName: {
                    this.stateBeforeAttributeName(c);
                    break;
                }
                case State.InTagName: {
                    this.stateInTagName(c);
                    break;
                }
                case State.InClosingTagName: {
                    this.stateInClosingTagName(c);
                    break;
                }
                case State.BeforeTagName: {
                    this.stateBeforeTagName(c);
                    break;
                }
                case State.AfterAttributeName: {
                    this.stateAfterAttributeName(c);
                    break;
                }
                case State.InAttributeValueSq: {
                    this.stateInAttributeValueSingleQuotes(c);
                    break;
                }
                case State.BeforeAttributeValue: {
                    this.stateBeforeAttributeValue(c);
                    break;
                }
                case State.BeforeClosingTagName: {
                    this.stateBeforeClosingTagName(c);
                    break;
                }
                case State.AfterClosingTagName: {
                    this.stateAfterClosingTagName(c);
                    break;
                }
                case State.BeforeSpecialS: {
                    this.stateBeforeSpecialS(c);
                    break;
                }
                case State.InAttributeValueNq: {
                    this.stateInAttributeValueNoQuotes(c);
                    break;
                }
                case State.InSelfClosingTag: {
                    this.stateInSelfClosingTag(c);
                    break;
                }
                case State.InDeclaration: {
                    this.stateInDeclaration(c);
                    break;
                }
                case State.BeforeDeclaration: {
                    this.stateBeforeDeclaration(c);
                    break;
                }
                case State.BeforeComment: {
                    this.stateBeforeComment(c);
                    break;
                }
                case State.InProcessingInstruction: {
                    this.stateInProcessingInstruction(c);
                    break;
                }
                case State.InNamedEntity: {
                    this.stateInNamedEntity(c);
                    break;
                }
                case State.BeforeEntity: {
                    this.stateBeforeEntity(c);
                    break;
                }
                case State.InHexEntity: {
                    this.stateInHexEntity(c);
                    break;
                }
                case State.InNumericEntity: {
                    this.stateInNumericEntity(c);
                    break;
                }
                default: {
                    // `this._state === State.BeforeNumericEntity`
                    this.stateBeforeNumericEntity(c);
                }
            }
            this.index++;
        }
        this.cleanup();
    };
    Tokenizer.prototype.finish = function () {
        if (this.state === State.InNamedEntity) {
            this.emitNamedEntity();
        }
        // If there is remaining data, emit it in a reasonable way
        if (this.sectionStart < this.index) {
            this.handleTrailingData();
        }
        this.cbs.onend();
    };
    /** Handle any trailing data. */
    Tokenizer.prototype.handleTrailingData = function () {
        var endIndex = this.buffer.length + this.offset;
        if (this.state === State.InCommentLike) {
            if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, endIndex, 0);
            }
            else {
                this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
        }
        else if (this.state === State.InNumericEntity &&
            this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
            // All trailing data will have been consumed
        }
        else if (this.state === State.InHexEntity &&
            this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
            // All trailing data will have been consumed
        }
        else if (this.state === State.InTagName ||
            this.state === State.BeforeAttributeName ||
            this.state === State.BeforeAttributeValue ||
            this.state === State.AfterAttributeName ||
            this.state === State.InAttributeName ||
            this.state === State.InAttributeValueSq ||
            this.state === State.InAttributeValueDq ||
            this.state === State.InAttributeValueNq ||
            this.state === State.InClosingTagName) {
            /*
             * If we are currently in an opening or closing tag, us not calling the
             * respective callback signals that the tag should be ignored.
             */
        }
        else {
            this.cbs.ontext(this.sectionStart, endIndex);
        }
    };
    Tokenizer.prototype.emitPartial = function (start, endIndex) {
        if (this.baseState !== State.Text &&
            this.baseState !== State.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
        }
        else {
            this.cbs.ontext(start, endIndex);
        }
    };
    Tokenizer.prototype.emitCodePoint = function (cp) {
        if (this.baseState !== State.Text &&
            this.baseState !== State.InSpecialTag) {
            this.cbs.onattribentity(cp);
        }
        else {
            this.cbs.ontextentity(cp);
        }
    };
    return Tokenizer;
}());
exports["default"] = Tokenizer;
//# sourceMappingURL=Tokenizer.js.map

/***/ }),

/***/ "./node_modules/htmlparser2/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/htmlparser2/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DefaultHandler = exports.DomHandler = exports.Parser = void 0;
var Parser_js_1 = __webpack_require__(/*! ./Parser.js */ "./node_modules/htmlparser2/lib/Parser.js");
var Parser_js_2 = __webpack_require__(/*! ./Parser.js */ "./node_modules/htmlparser2/lib/Parser.js");
Object.defineProperty(exports, "Parser", ({ enumerable: true, get: function () { return Parser_js_2.Parser; } }));
var domhandler_1 = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js");
var domhandler_2 = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js");
Object.defineProperty(exports, "DomHandler", ({ enumerable: true, get: function () { return domhandler_2.DomHandler; } }));
// Old name for DomHandler
Object.defineProperty(exports, "DefaultHandler", ({ enumerable: true, get: function () { return domhandler_2.DomHandler; } }));
// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */
function parseDocument(data, options) {
    var handler = new domhandler_1.DomHandler(undefined, options);
    new Parser_js_1.Parser(handler, options).end(data);
    return handler.root;
}
exports.parseDocument = parseDocument;
/**
 * Parses data, returns an array of the root nodes.
 *
 * Note that the root nodes still have a `Document` node as their parent.
 * Use `parseDocument` to get the `Document` node instead.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 * @deprecated Use `parseDocument` instead.
 */
function parseDOM(data, options) {
    return parseDocument(data, options).children;
}
exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param callback A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
 */
function createDomStream(callback, options, elementCallback) {
    var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
    return new Parser_js_1.Parser(handler, options);
}
exports.createDomStream = createDomStream;
var Tokenizer_js_1 = __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/htmlparser2/lib/Tokenizer.js");
Object.defineProperty(exports, "Tokenizer", ({ enumerable: true, get: function () { return __importDefault(Tokenizer_js_1).default; } }));
/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */
exports.ElementType = __importStar(__webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/lib/index.js"));
var domutils_1 = __webpack_require__(/*! domutils */ "./node_modules/domutils/lib/index.js");
var domutils_2 = __webpack_require__(/*! domutils */ "./node_modules/domutils/lib/index.js");
Object.defineProperty(exports, "getFeed", ({ enumerable: true, get: function () { return domutils_2.getFeed; } }));
var parseFeedDefaultOptions = { xmlMode: true };
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
 */
function parseFeed(feed, options) {
    if (options === void 0) { options = parseFeedDefaultOptions; }
    return (0, domutils_1.getFeed)(parseDOM(feed, options));
}
exports.parseFeed = parseFeed;
exports.DomUtils = __importStar(__webpack_require__(/*! domutils */ "./node_modules/domutils/lib/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/parse-srcset/src/parse-srcset.js":
/*!*******************************************************!*\
  !*** ./node_modules/parse-srcset/src/parse-srcset.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Srcset Parser
 *
 * By Alex Bell |  MIT License
 *
 * JS Parser for the string value that appears in markup <img srcset="here">
 *
 * @returns Array [{url: _, d: _, w: _, h:_}, ...]
 *
 * Based super duper closely on the reference algorithm at:
 * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute
 *
 * Most comments are copied in directly from the spec
 * (except for comments in parens).
 */

(function (root, factory) {
	if (true) {
		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}(this, function () {

	// 1. Let input be the value passed to this algorithm.
	return function (input) {

		// UTILITY FUNCTIONS

		// Manual is faster than RegEx
		// http://bjorn.tipling.com/state-and-regular-expressions-in-javascript
		// http://jsperf.com/whitespace-character/5
		function isSpace(c) {
			return (c === "\u0020" || // space
			c === "\u0009" || // horizontal tab
			c === "\u000A" || // new line
			c === "\u000C" || // form feed
			c === "\u000D");  // carriage return
		}

		function collectCharacters(regEx) {
			var chars,
				match = regEx.exec(input.substring(pos));
			if (match) {
				chars = match[ 0 ];
				pos += chars.length;
				return chars;
			}
		}

		var inputLength = input.length,

			// (Don't use \s, to avoid matching non-breaking space)
			regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
			regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
			regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
			regexTrailingCommas = /[,]+$/,
			regexNonNegativeInteger = /^\d+$/,

			// ( Positive or negative or unsigned integers or decimals, without or without exponents.
			// Must include at least one digit.
			// According to spec tests any decimal point must be followed by a digit.
			// No leading plus sign is allowed.)
			// https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number
			regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,

			url,
			descriptors,
			currentDescriptor,
			state,
			c,

			// 2. Let position be a pointer into input, initially pointing at the start
			//    of the string.
			pos = 0,

			// 3. Let candidates be an initially empty source set.
			candidates = [];

		// 4. Splitting loop: Collect a sequence of characters that are space
		//    characters or U+002C COMMA characters. If any U+002C COMMA characters
		//    were collected, that is a parse error.
		while (true) {
			collectCharacters(regexLeadingCommasOrSpaces);

			// 5. If position is past the end of input, return candidates and abort these steps.
			if (pos >= inputLength) {
				return candidates; // (we're done, this is the sole return path)
			}

			// 6. Collect a sequence of characters that are not space characters,
			//    and let that be url.
			url = collectCharacters(regexLeadingNotSpaces);

			// 7. Let descriptors be a new empty list.
			descriptors = [];

			// 8. If url ends with a U+002C COMMA character (,), follow these substeps:
			//		(1). Remove all trailing U+002C COMMA characters from url. If this removed
			//         more than one character, that is a parse error.
			if (url.slice(-1) === ",") {
				url = url.replace(regexTrailingCommas, "");
				// (Jump ahead to step 9 to skip tokenization and just push the candidate).
				parseDescriptors();

				//	Otherwise, follow these substeps:
			} else {
				tokenize();
			} // (close else of step 8)

			// 16. Return to the step labeled splitting loop.
		} // (Close of big while loop.)

		/**
		 * Tokenizes descriptor properties prior to parsing
		 * Returns undefined.
		 */
		function tokenize() {

			// 8.1. Descriptor tokeniser: Skip whitespace
			collectCharacters(regexLeadingSpaces);

			// 8.2. Let current descriptor be the empty string.
			currentDescriptor = "";

			// 8.3. Let state be in descriptor.
			state = "in descriptor";

			while (true) {

				// 8.4. Let c be the character at position.
				c = input.charAt(pos);

				//  Do the following depending on the value of state.
				//  For the purpose of this step, "EOF" is a special character representing
				//  that position is past the end of input.

				// In descriptor
				if (state === "in descriptor") {
					// Do the following, depending on the value of c:

					// Space character
					// If current descriptor is not empty, append current descriptor to
					// descriptors and let current descriptor be the empty string.
					// Set state to after descriptor.
					if (isSpace(c)) {
						if (currentDescriptor) {
							descriptors.push(currentDescriptor);
							currentDescriptor = "";
							state = "after descriptor";
						}

						// U+002C COMMA (,)
						// Advance position to the next character in input. If current descriptor
						// is not empty, append current descriptor to descriptors. Jump to the step
						// labeled descriptor parser.
					} else if (c === ",") {
						pos += 1;
						if (currentDescriptor) {
							descriptors.push(currentDescriptor);
						}
						parseDescriptors();
						return;

						// U+0028 LEFT PARENTHESIS (()
						// Append c to current descriptor. Set state to in parens.
					} else if (c === "\u0028") {
						currentDescriptor = currentDescriptor + c;
						state = "in parens";

						// EOF
						// If current descriptor is not empty, append current descriptor to
						// descriptors. Jump to the step labeled descriptor parser.
					} else if (c === "") {
						if (currentDescriptor) {
							descriptors.push(currentDescriptor);
						}
						parseDescriptors();
						return;

						// Anything else
						// Append c to current descriptor.
					} else {
						currentDescriptor = currentDescriptor + c;
					}
					// (end "in descriptor"

					// In parens
				} else if (state === "in parens") {

					// U+0029 RIGHT PARENTHESIS ())
					// Append c to current descriptor. Set state to in descriptor.
					if (c === ")") {
						currentDescriptor = currentDescriptor + c;
						state = "in descriptor";

						// EOF
						// Append current descriptor to descriptors. Jump to the step labeled
						// descriptor parser.
					} else if (c === "") {
						descriptors.push(currentDescriptor);
						parseDescriptors();
						return;

						// Anything else
						// Append c to current descriptor.
					} else {
						currentDescriptor = currentDescriptor + c;
					}

					// After descriptor
				} else if (state === "after descriptor") {

					// Do the following, depending on the value of c:
					// Space character: Stay in this state.
					if (isSpace(c)) {

						// EOF: Jump to the step labeled descriptor parser.
					} else if (c === "") {
						parseDescriptors();
						return;

						// Anything else
						// Set state to in descriptor. Set position to the previous character in input.
					} else {
						state = "in descriptor";
						pos -= 1;

					}
				}

				// Advance position to the next character in input.
				pos += 1;

				// Repeat this step.
			} // (close while true loop)
		}

		/**
		 * Adds descriptor properties to a candidate, pushes to the candidates array
		 * @return undefined
		 */
		// Declared outside of the while loop so that it's only created once.
		function parseDescriptors() {

			// 9. Descriptor parser: Let error be no.
			var pError = false,

				// 10. Let width be absent.
				// 11. Let density be absent.
				// 12. Let future-compat-h be absent. (We're implementing it now as h)
				w, d, h, i,
				candidate = {},
				desc, lastChar, value, intVal, floatVal;

			// 13. For each descriptor in descriptors, run the appropriate set of steps
			// from the following list:
			for (i = 0 ; i < descriptors.length; i++) {
				desc = descriptors[ i ];

				lastChar = desc[ desc.length - 1 ];
				value = desc.substring(0, desc.length - 1);
				intVal = parseInt(value, 10);
				floatVal = parseFloat(value);

				// If the descriptor consists of a valid non-negative integer followed by
				// a U+0077 LATIN SMALL LETTER W character
				if (regexNonNegativeInteger.test(value) && (lastChar === "w")) {

					// If width and density are not both absent, then let error be yes.
					if (w || d) {pError = true;}

					// Apply the rules for parsing non-negative integers to the descriptor.
					// If the result is zero, let error be yes.
					// Otherwise, let width be the result.
					if (intVal === 0) {pError = true;} else {w = intVal;}

					// If the descriptor consists of a valid floating-point number followed by
					// a U+0078 LATIN SMALL LETTER X character
				} else if (regexFloatingPoint.test(value) && (lastChar === "x")) {

					// If width, density and future-compat-h are not all absent, then let error
					// be yes.
					if (w || d || h) {pError = true;}

					// Apply the rules for parsing floating-point number values to the descriptor.
					// If the result is less than zero, let error be yes. Otherwise, let density
					// be the result.
					if (floatVal < 0) {pError = true;} else {d = floatVal;}

					// If the descriptor consists of a valid non-negative integer followed by
					// a U+0068 LATIN SMALL LETTER H character
				} else if (regexNonNegativeInteger.test(value) && (lastChar === "h")) {

					// If height and density are not both absent, then let error be yes.
					if (h || d) {pError = true;}

					// Apply the rules for parsing non-negative integers to the descriptor.
					// If the result is zero, let error be yes. Otherwise, let future-compat-h
					// be the result.
					if (intVal === 0) {pError = true;} else {h = intVal;}

					// Anything else, Let error be yes.
				} else {pError = true;}
			} // (close step 13 for loop)

			// 15. If error is still no, then append a new image source to candidates whose
			// URL is url, associated with a width width if not absent and a pixel
			// density density if not absent. Otherwise, there is a parse error.
			if (!pError) {
				candidate.url = url;
				if (w) { candidate.w = w;}
				if (d) { candidate.d = d;}
				if (h) { candidate.h = h;}
				candidates.push(candidate);
			} else if (console && console.log) {
				console.log("Invalid srcset descriptor found in '" +
					input + "' at '" + desc + "'.");
			}
		} // (close parseDescriptors fn)

	}
}));


/***/ }),

/***/ "./node_modules/picocolors/picocolors.browser.js":
/*!*******************************************************!*\
  !*** ./node_modules/picocolors/picocolors.browser.js ***!
  \*******************************************************/
/***/ ((module) => {

var x=String;
var create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x,blackBright:x,redBright:x,greenBright:x,yellowBright:x,blueBright:x,magentaBright:x,cyanBright:x,whiteBright:x,bgBlackBright:x,bgRedBright:x,bgGreenBright:x,bgYellowBright:x,bgBlueBright:x,bgMagentaBright:x,bgCyanBright:x,bgWhiteBright:x}};
module.exports=create();
module.exports.createColors = create;


/***/ }),

/***/ "./node_modules/postcss/lib/at-rule.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/at-rule.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(/*! ./container */ "./node_modules/postcss/lib/container.js")

class AtRule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'atrule'
  }

  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.append(...children)
  }

  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.prepend(...children)
  }
}

module.exports = AtRule
AtRule.default = AtRule

Container.registerAtRule(AtRule)


/***/ }),

/***/ "./node_modules/postcss/lib/comment.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/comment.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Node = __webpack_require__(/*! ./node */ "./node_modules/postcss/lib/node.js")

class Comment extends Node {
  constructor(defaults) {
    super(defaults)
    this.type = 'comment'
  }
}

module.exports = Comment
Comment.default = Comment


/***/ }),

/***/ "./node_modules/postcss/lib/container.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/container.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Comment = __webpack_require__(/*! ./comment */ "./node_modules/postcss/lib/comment.js")
let Declaration = __webpack_require__(/*! ./declaration */ "./node_modules/postcss/lib/declaration.js")
let Node = __webpack_require__(/*! ./node */ "./node_modules/postcss/lib/node.js")
let { isClean, my } = __webpack_require__(/*! ./symbols */ "./node_modules/postcss/lib/symbols.js")

let AtRule, parse, Root, Rule

function cleanSource(nodes) {
  return nodes.map(i => {
    if (i.nodes) i.nodes = cleanSource(i.nodes)
    delete i.source
    return i
  })
}

function markTreeDirty(node) {
  node[isClean] = false
  if (node.proxyOf.nodes) {
    for (let i of node.proxyOf.nodes) {
      markTreeDirty(i)
    }
  }
}

class Container extends Node {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last)
      for (let node of nodes) this.proxyOf.nodes.push(node)
    }

    this.markDirty()

    return this
  }

  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween)
    if (this.nodes) {
      for (let node of this.nodes) node.cleanRaws(keepBetween)
    }
  }

  each(callback) {
    if (!this.proxyOf.nodes) return undefined
    let iterator = this.getIterator()

    let index, result
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator]
      result = callback(this.proxyOf.nodes[index], index)
      if (result === false) break

      this.indexes[iterator] += 1
    }

    delete this.indexes[iterator]
    return result
  }

  every(condition) {
    return this.nodes.every(condition)
  }

  getIterator() {
    if (!this.lastEach) this.lastEach = 0
    if (!this.indexes) this.indexes = {}

    this.lastEach += 1
    let iterator = this.lastEach
    this.indexes[iterator] = 0

    return iterator
  }

  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (!node[prop]) {
          return node[prop]
        } else if (
          prop === 'each' ||
          (typeof prop === 'string' && prop.startsWith('walk'))
        ) {
          return (...args) => {
            return node[prop](
              ...args.map(i => {
                if (typeof i === 'function') {
                  return (child, index) => i(child.toProxy(), index)
                } else {
                  return i
                }
              })
            )
          }
        } else if (prop === 'every' || prop === 'some') {
          return cb => {
            return node[prop]((child, ...other) =>
              cb(child.toProxy(), ...other)
            )
          }
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else if (prop === 'nodes') {
          return node.nodes.map(i => i.toProxy())
        } else if (prop === 'first' || prop === 'last') {
          return node[prop].toProxy()
        } else {
          return node[prop]
        }
      },

      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (prop === 'name' || prop === 'params' || prop === 'selector') {
          node.markDirty()
        }
        return true
      }
    }
  }

  index(child) {
    if (typeof child === 'number') return child
    if (child.proxyOf) child = child.proxyOf
    return this.proxyOf.nodes.indexOf(child)
  }

  insertAfter(exist, add) {
    let existIndex = this.index(exist)
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex < index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  insertBefore(exist, add) {
    let existIndex = this.index(exist)
    let type = existIndex === 0 ? 'prepend' : false
    let nodes = this.normalize(
      add,
      this.proxyOf.nodes[existIndex],
      type
    ).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex <= index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  normalize(nodes, sample) {
    if (typeof nodes === 'string') {
      nodes = cleanSource(parse(nodes).nodes)
    } else if (typeof nodes === 'undefined') {
      nodes = []
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type === 'root' && this.type !== 'document') {
      nodes = nodes.nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type) {
      nodes = [nodes]
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation')
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value)
      }
      nodes = [new Declaration(nodes)]
    } else if (nodes.selector || nodes.selectors) {
      nodes = [new Rule(nodes)]
    } else if (nodes.name) {
      nodes = [new AtRule(nodes)]
    } else if (nodes.text) {
      nodes = [new Comment(nodes)]
    } else {
      throw new Error('Unknown node type in node creation')
    }

    let processed = nodes.map(i => {
      /* c8 ignore next */
      if (!i[my]) Container.rebuild(i)
      i = i.proxyOf
      if (i.parent) i.parent.removeChild(i)
      if (i[isClean]) markTreeDirty(i)
      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/\S/g, '')
        }
      }
      i.parent = this.proxyOf
      return i
    })

    return processed
  }

  prepend(...children) {
    children = children.reverse()
    for (let child of children) {
      let nodes = this.normalize(child, this.first, 'prepend').reverse()
      for (let node of nodes) this.proxyOf.nodes.unshift(node)
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  push(child) {
    child.parent = this
    this.proxyOf.nodes.push(child)
    return this
  }

  removeAll() {
    for (let node of this.proxyOf.nodes) node.parent = undefined
    this.proxyOf.nodes = []

    this.markDirty()

    return this
  }

  removeChild(child) {
    child = this.index(child)
    this.proxyOf.nodes[child].parent = undefined
    this.proxyOf.nodes.splice(child, 1)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (index >= child) {
        this.indexes[id] = index - 1
      }
    }

    this.markDirty()

    return this
  }

  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts
      opts = {}
    }

    this.walkDecls(decl => {
      if (opts.props && !opts.props.includes(decl.prop)) return
      if (opts.fast && !decl.value.includes(opts.fast)) return

      decl.value = decl.value.replace(pattern, callback)
    })

    this.markDirty()

    return this
  }

  some(condition) {
    return this.nodes.some(condition)
  }

  walk(callback) {
    return this.each((child, i) => {
      let result
      try {
        result = callback(child, i)
      } catch (e) {
        throw child.addToError(e)
      }
      if (result !== false && child.walk) {
        result = child.walk(callback)
      }

      return result
    })
  }

  walkAtRules(name, callback) {
    if (!callback) {
      callback = name
      return this.walk((child, i) => {
        if (child.type === 'atrule') {
          return callback(child, i)
        }
      })
    }
    if (name instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i)
      }
    })
  }

  walkComments(callback) {
    return this.walk((child, i) => {
      if (child.type === 'comment') {
        return callback(child, i)
      }
    })
  }

  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop
      return this.walk((child, i) => {
        if (child.type === 'decl') {
          return callback(child, i)
        }
      })
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i)
      }
    })
  }

  walkRules(selector, callback) {
    if (!callback) {
      callback = selector

      return this.walk((child, i) => {
        if (child.type === 'rule') {
          return callback(child, i)
        }
      })
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i)
      }
    })
  }

  get first() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[0]
  }

  get last() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
  }
}

Container.registerParse = dependant => {
  parse = dependant
}

Container.registerRule = dependant => {
  Rule = dependant
}

Container.registerAtRule = dependant => {
  AtRule = dependant
}

Container.registerRoot = dependant => {
  Root = dependant
}

module.exports = Container
Container.default = Container

/* c8 ignore start */
Container.rebuild = node => {
  if (node.type === 'atrule') {
    Object.setPrototypeOf(node, AtRule.prototype)
  } else if (node.type === 'rule') {
    Object.setPrototypeOf(node, Rule.prototype)
  } else if (node.type === 'decl') {
    Object.setPrototypeOf(node, Declaration.prototype)
  } else if (node.type === 'comment') {
    Object.setPrototypeOf(node, Comment.prototype)
  } else if (node.type === 'root') {
    Object.setPrototypeOf(node, Root.prototype)
  }

  node[my] = true

  if (node.nodes) {
    node.nodes.forEach(child => {
      Container.rebuild(child)
    })
  }
}
/* c8 ignore stop */


/***/ }),

/***/ "./node_modules/postcss/lib/css-syntax-error.js":
/*!******************************************************!*\
  !*** ./node_modules/postcss/lib/css-syntax-error.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let pico = __webpack_require__(/*! picocolors */ "./node_modules/picocolors/picocolors.browser.js")

let terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ "?5580")

class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin) {
    super(message)
    this.name = 'CssSyntaxError'
    this.reason = message

    if (file) {
      this.file = file
    }
    if (source) {
      this.source = source
    }
    if (plugin) {
      this.plugin = plugin
    }
    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      if (typeof line === 'number') {
        this.line = line
        this.column = column
      } else {
        this.line = line.line
        this.column = line.column
        this.endLine = column.line
        this.endColumn = column.column
      }
    }

    this.setMessage()

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError)
    }
  }

  setMessage() {
    this.message = this.plugin ? this.plugin + ': ' : ''
    this.message += this.file ? this.file : '<css input>'
    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column
    }
    this.message += ': ' + this.reason
  }

  showSourceCode(color) {
    if (!this.source) return ''

    let css = this.source
    if (color == null) color = pico.isColorSupported

    let aside = text => text
    let mark = text => text
    let highlight = text => text
    if (color) {
      let { bold, gray, red } = pico.createColors(true)
      mark = text => bold(red(text))
      aside = text => gray(text)
      if (terminalHighlight) {
        highlight = text => terminalHighlight(text)
      }
    }

    let lines = css.split(/\r?\n/)
    let start = Math.max(this.line - 3, 0)
    let end = Math.min(this.line + 2, lines.length)
    let maxWidth = String(end).length

    return lines
      .slice(start, end)
      .map((line, index) => {
        let number = start + 1 + index
        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '
        if (number === this.line) {
          if (line.length > 160) {
            let padding = 20
            let subLineStart = Math.max(0, this.column - padding)
            let subLineEnd = Math.max(
              this.column + padding,
              this.endColumn + padding
            )
            let subLine = line.slice(subLineStart, subLineEnd)

            let spacing =
              aside(gutter.replace(/\d/g, ' ')) +
              line
                .slice(0, Math.min(this.column - 1, padding - 1))
                .replace(/[^\t]/g, ' ')

            return (
              mark('>') +
              aside(gutter) +
              highlight(subLine) +
              '\n ' +
              spacing +
              mark('^')
            )
          }

          let spacing =
            aside(gutter.replace(/\d/g, ' ')) +
            line.slice(0, this.column - 1).replace(/[^\t]/g, ' ')

          return (
            mark('>') +
            aside(gutter) +
            highlight(line) +
            '\n ' +
            spacing +
            mark('^')
          )
        }

        return ' ' + aside(gutter) + highlight(line)
      })
      .join('\n')
  }

  toString() {
    let code = this.showSourceCode()
    if (code) {
      code = '\n\n' + code + '\n'
    }
    return this.name + ': ' + this.message + code
  }
}

module.exports = CssSyntaxError
CssSyntaxError.default = CssSyntaxError


/***/ }),

/***/ "./node_modules/postcss/lib/declaration.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/declaration.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Node = __webpack_require__(/*! ./node */ "./node_modules/postcss/lib/node.js")

class Declaration extends Node {
  constructor(defaults) {
    if (
      defaults &&
      typeof defaults.value !== 'undefined' &&
      typeof defaults.value !== 'string'
    ) {
      defaults = { ...defaults, value: String(defaults.value) }
    }
    super(defaults)
    this.type = 'decl'
  }

  get variable() {
    return this.prop.startsWith('--') || this.prop[0] === '$'
  }
}

module.exports = Declaration
Declaration.default = Declaration


/***/ }),

/***/ "./node_modules/postcss/lib/document.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/document.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(/*! ./container */ "./node_modules/postcss/lib/container.js")

let LazyResult, Processor

class Document extends Container {
  constructor(defaults) {
    // type needs to be passed to super, otherwise child roots won't be normalized correctly
    super({ type: 'document', ...defaults })

    if (!this.nodes) {
      this.nodes = []
    }
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)

    return lazy.stringify()
  }
}

Document.registerLazyResult = dependant => {
  LazyResult = dependant
}

Document.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Document
Document.default = Document


/***/ }),

/***/ "./node_modules/postcss/lib/fromJSON.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/fromJSON.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let AtRule = __webpack_require__(/*! ./at-rule */ "./node_modules/postcss/lib/at-rule.js")
let Comment = __webpack_require__(/*! ./comment */ "./node_modules/postcss/lib/comment.js")
let Declaration = __webpack_require__(/*! ./declaration */ "./node_modules/postcss/lib/declaration.js")
let Input = __webpack_require__(/*! ./input */ "./node_modules/postcss/lib/input.js")
let PreviousMap = __webpack_require__(/*! ./previous-map */ "./node_modules/postcss/lib/previous-map.js")
let Root = __webpack_require__(/*! ./root */ "./node_modules/postcss/lib/root.js")
let Rule = __webpack_require__(/*! ./rule */ "./node_modules/postcss/lib/rule.js")

function fromJSON(json, inputs) {
  if (Array.isArray(json)) return json.map(n => fromJSON(n))

  let { inputs: ownInputs, ...defaults } = json
  if (ownInputs) {
    inputs = []
    for (let input of ownInputs) {
      let inputHydrated = { ...input, __proto__: Input.prototype }
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap.prototype
        }
      }
      inputs.push(inputHydrated)
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source
    defaults.source = source
    if (inputId != null) {
      defaults.source.input = inputs[inputId]
    }
  }
  if (defaults.type === 'root') {
    return new Root(defaults)
  } else if (defaults.type === 'decl') {
    return new Declaration(defaults)
  } else if (defaults.type === 'rule') {
    return new Rule(defaults)
  } else if (defaults.type === 'comment') {
    return new Comment(defaults)
  } else if (defaults.type === 'atrule') {
    return new AtRule(defaults)
  } else {
    throw new Error('Unknown node type: ' + json.type)
  }
}

module.exports = fromJSON
fromJSON.default = fromJSON


/***/ }),

/***/ "./node_modules/postcss/lib/input.js":
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/input.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { nanoid } = __webpack_require__(/*! nanoid/non-secure */ "./node_modules/nanoid/non-secure/index.cjs")
let { isAbsolute, resolve } = __webpack_require__(/*! path */ "?6197")
let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ "?b8cb")
let { fileURLToPath, pathToFileURL } = __webpack_require__(/*! url */ "?c717")

let CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ "./node_modules/postcss/lib/css-syntax-error.js")
let PreviousMap = __webpack_require__(/*! ./previous-map */ "./node_modules/postcss/lib/previous-map.js")
let terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ "?5580")

let fromOffsetCache = Symbol('fromOffsetCache')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(resolve && isAbsolute)

class Input {
  constructor(css, opts = {}) {
    if (
      css === null ||
      typeof css === 'undefined' ||
      (typeof css === 'object' && !css.toString)
    ) {
      throw new Error(`PostCSS received ${css} instead of CSS string`)
    }

    this.css = css.toString()

    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
      this.hasBOM = true
      this.css = this.css.slice(1)
    } else {
      this.hasBOM = false
    }

    if (opts.from) {
      if (
        !pathAvailable ||
        /^\w+:\/\//.test(opts.from) ||
        isAbsolute(opts.from)
      ) {
        this.file = opts.from
      } else {
        this.file = resolve(opts.from)
      }
    }

    if (pathAvailable && sourceMapAvailable) {
      let map = new PreviousMap(this.css, opts)
      if (map.text) {
        this.map = map
        let file = map.consumer().file
        if (!this.file && file) this.file = this.mapResolve(file)
      }
    }

    if (!this.file) {
      this.id = '<input css ' + nanoid(6) + '>'
    }
    if (this.map) this.map.file = this.from
  }

  error(message, line, column, opts = {}) {
    let endColumn, endLine, result

    if (line && typeof line === 'object') {
      let start = line
      let end = column
      if (typeof start.offset === 'number') {
        let pos = this.fromOffset(start.offset)
        line = pos.line
        column = pos.col
      } else {
        line = start.line
        column = start.column
      }
      if (typeof end.offset === 'number') {
        let pos = this.fromOffset(end.offset)
        endLine = pos.line
        endColumn = pos.col
      } else {
        endLine = end.line
        endColumn = end.column
      }
    } else if (!column) {
      let pos = this.fromOffset(line)
      line = pos.line
      column = pos.col
    }

    let origin = this.origin(line, column, endLine, endColumn)
    if (origin) {
      result = new CssSyntaxError(
        message,
        origin.endLine === undefined
          ? origin.line
          : { column: origin.column, line: origin.line },
        origin.endLine === undefined
          ? origin.column
          : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      )
    } else {
      result = new CssSyntaxError(
        message,
        endLine === undefined ? line : { column, line },
        endLine === undefined ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      )
    }

    result.input = { column, endColumn, endLine, line, source: this.css }
    if (this.file) {
      if (pathToFileURL) {
        result.input.url = pathToFileURL(this.file).toString()
      }
      result.input.file = this.file
    }

    return result
  }

  fromOffset(offset) {
    let lastLine, lineToIndex
    if (!this[fromOffsetCache]) {
      let lines = this.css.split('\n')
      lineToIndex = new Array(lines.length)
      let prevIndex = 0

      for (let i = 0, l = lines.length; i < l; i++) {
        lineToIndex[i] = prevIndex
        prevIndex += lines[i].length + 1
      }

      this[fromOffsetCache] = lineToIndex
    } else {
      lineToIndex = this[fromOffsetCache]
    }
    lastLine = lineToIndex[lineToIndex.length - 1]

    let min = 0
    if (offset >= lastLine) {
      min = lineToIndex.length - 1
    } else {
      let max = lineToIndex.length - 2
      let mid
      while (min < max) {
        mid = min + ((max - min) >> 1)
        if (offset < lineToIndex[mid]) {
          max = mid - 1
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1
        } else {
          min = mid
          break
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    }
  }

  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file
    }
    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
  }

  origin(line, column, endLine, endColumn) {
    if (!this.map) return false
    let consumer = this.map.consumer()

    let from = consumer.originalPositionFor({ column, line })
    if (!from.source) return false

    let to
    if (typeof endLine === 'number') {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine })
    }

    let fromUrl

    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL(from.source)
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
      )
    }

    let result = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    }

    if (fromUrl.protocol === 'file:') {
      if (fileURLToPath) {
        result.file = fileURLToPath(fromUrl)
      } else {
        /* c8 ignore next 2 */
        throw new Error(`file: protocol is not available in this PostCSS build`)
      }
    }

    let source = consumer.sourceContentFor(from.source)
    if (source) result.source = source

    return result
  }

  toJSON() {
    let json = {}
    for (let name of ['hasBOM', 'css', 'file', 'id']) {
      if (this[name] != null) {
        json[name] = this[name]
      }
    }
    if (this.map) {
      json.map = { ...this.map }
      if (json.map.consumerCache) {
        json.map.consumerCache = undefined
      }
    }
    return json
  }

  get from() {
    return this.file || this.id
  }
}

module.exports = Input
Input.default = Input

if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input)
}


/***/ }),

/***/ "./node_modules/postcss/lib/lazy-result.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/lazy-result.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(/*! ./container */ "./node_modules/postcss/lib/container.js")
let Document = __webpack_require__(/*! ./document */ "./node_modules/postcss/lib/document.js")
let MapGenerator = __webpack_require__(/*! ./map-generator */ "./node_modules/postcss/lib/map-generator.js")
let parse = __webpack_require__(/*! ./parse */ "./node_modules/postcss/lib/parse.js")
let Result = __webpack_require__(/*! ./result */ "./node_modules/postcss/lib/result.js")
let Root = __webpack_require__(/*! ./root */ "./node_modules/postcss/lib/root.js")
let stringify = __webpack_require__(/*! ./stringify */ "./node_modules/postcss/lib/stringify.js")
let { isClean, my } = __webpack_require__(/*! ./symbols */ "./node_modules/postcss/lib/symbols.js")
let warnOnce = __webpack_require__(/*! ./warn-once */ "./node_modules/postcss/lib/warn-once.js")

const TYPE_TO_CLASS_NAME = {
  atrule: 'AtRule',
  comment: 'Comment',
  decl: 'Declaration',
  document: 'Document',
  root: 'Root',
  rule: 'Rule'
}

const PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
}

const NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
}

const CHILDREN = 0

function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function'
}

function getEvents(node) {
  let key = false
  let type = TYPE_TO_CLASS_NAME[node.type]
  if (node.type === 'decl') {
    key = node.prop.toLowerCase()
  } else if (node.type === 'atrule') {
    key = node.name.toLowerCase()
  }

  if (key && node.append) {
    return [
      type,
      type + '-' + key,
      CHILDREN,
      type + 'Exit',
      type + 'Exit-' + key
    ]
  } else if (key) {
    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
  } else if (node.append) {
    return [type, CHILDREN, type + 'Exit']
  } else {
    return [type, type + 'Exit']
  }
}

function toStack(node) {
  let events
  if (node.type === 'document') {
    events = ['Document', CHILDREN, 'DocumentExit']
  } else if (node.type === 'root') {
    events = ['Root', CHILDREN, 'RootExit']
  } else {
    events = getEvents(node)
  }

  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node,
    visitorIndex: 0,
    visitors: []
  }
}

function cleanMarks(node) {
  node[isClean] = false
  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))
  return node
}

let postcss = {}

class LazyResult {
  constructor(processor, css, opts) {
    this.stringified = false
    this.processed = false

    let root
    if (
      typeof css === 'object' &&
      css !== null &&
      (css.type === 'root' || css.type === 'document')
    ) {
      root = cleanMarks(css)
    } else if (css instanceof LazyResult || css instanceof Result) {
      root = cleanMarks(css.root)
      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {}
        if (!opts.map.inline) opts.map.inline = false
        opts.map.prev = css.map
      }
    } else {
      let parser = parse
      if (opts.syntax) parser = opts.syntax.parse
      if (opts.parser) parser = opts.parser
      if (parser.parse) parser = parser.parse

      try {
        root = parser(css, opts)
      } catch (error) {
        this.processed = true
        this.error = error
      }

      if (root && !root[my]) {
        /* c8 ignore next 2 */
        Container.rebuild(root)
      }
    }

    this.result = new Result(processor, root, opts)
    this.helpers = { ...postcss, postcss, result: this.result }
    this.plugins = this.processor.plugins.map(plugin => {
      if (typeof plugin === 'object' && plugin.prepare) {
        return { ...plugin, ...plugin.prepare(this.result) }
      } else {
        return plugin
      }
    })
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    if (this.processed) return Promise.resolve(this.result)
    if (!this.processing) {
      this.processing = this.runAsync()
    }
    return this.processing
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  getAsyncError() {
    throw new Error('Use process(css).then(cb) to work with async plugins')
  }

  handleError(error, node) {
    let plugin = this.result.lastPlugin
    try {
      if (node) node.addToError(error)
      this.error = error
      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin
        error.setMessage()
      } else if (plugin.postcssVersion) {
        if (true) {
          let pluginName = plugin.postcssPlugin
          let pluginVer = plugin.postcssVersion
          let runtimeVer = this.result.processor.version
          let a = pluginVer.split('.')
          let b = runtimeVer.split('.')

          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
            // eslint-disable-next-line no-console
            console.error(
              'Unknown error from PostCSS plugin. Your current PostCSS ' +
                'version is ' +
                runtimeVer +
                ', but ' +
                pluginName +
                ' uses ' +
                pluginVer +
                '. Perhaps this is the source of the error below.'
            )
          }
        }
      }
    } catch (err) {
      /* c8 ignore next 3 */
      // eslint-disable-next-line no-console
      if (console && console.error) console.error(err)
    }
    return error
  }

  prepareVisitors() {
    this.listeners = {}
    let add = (plugin, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = []
      this.listeners[type].push([plugin, cb])
    }
    for (let plugin of this.plugins) {
      if (typeof plugin === 'object') {
        for (let event in plugin) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
                `Try to update PostCSS (${this.processor.version} now).`
            )
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin[event] === 'object') {
              for (let filter in plugin[event]) {
                if (filter === '*') {
                  add(plugin, event, plugin[event][filter])
                } else {
                  add(
                    plugin,
                    event + '-' + filter.toLowerCase(),
                    plugin[event][filter]
                  )
                }
              }
            } else if (typeof plugin[event] === 'function') {
              add(plugin, event, plugin[event])
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0
  }

  async runAsync() {
    this.plugin = 0
    for (let i = 0; i < this.plugins.length; i++) {
      let plugin = this.plugins[i]
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        try {
          await promise
        } catch (error) {
          throw this.handleError(error)
        }
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        let stack = [toStack(root)]
        while (stack.length > 0) {
          let promise = this.visitTick(stack)
          if (isPromise(promise)) {
            try {
              await promise
            } catch (e) {
              let node = stack[stack.length - 1].node
              throw this.handleError(e, node)
            }
          }
        }
      }

      if (this.listeners.OnceExit) {
        for (let [plugin, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin
          try {
            if (root.type === 'document') {
              let roots = root.nodes.map(subRoot =>
                visitor(subRoot, this.helpers)
              )

              await Promise.all(roots)
            } else {
              await visitor(root, this.helpers)
            }
          } catch (e) {
            throw this.handleError(e)
          }
        }
      }
    }

    this.processed = true
    return this.stringify()
  }

  runOnRoot(plugin) {
    this.result.lastPlugin = plugin
    try {
      if (typeof plugin === 'object' && plugin.Once) {
        if (this.result.root.type === 'document') {
          let roots = this.result.root.nodes.map(root =>
            plugin.Once(root, this.helpers)
          )

          if (isPromise(roots[0])) {
            return Promise.all(roots)
          }

          return roots
        }

        return plugin.Once(this.result.root, this.helpers)
      } else if (typeof plugin === 'function') {
        return plugin(this.result.root, this.result)
      }
    } catch (error) {
      throw this.handleError(error)
    }
  }

  stringify() {
    if (this.error) throw this.error
    if (this.stringified) return this.result
    this.stringified = true

    this.sync()

    let opts = this.result.opts
    let str = stringify
    if (opts.syntax) str = opts.syntax.stringify
    if (opts.stringifier) str = opts.stringifier
    if (str.stringify) str = str.stringify

    let map = new MapGenerator(str, this.result.root, this.result.opts)
    let data = map.generate()
    this.result.css = data[0]
    this.result.map = data[1]

    return this.result
  }

  sync() {
    if (this.error) throw this.error
    if (this.processed) return this.result
    this.processed = true

    if (this.processing) {
      throw this.getAsyncError()
    }

    for (let plugin of this.plugins) {
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        this.walkSync(root)
      }
      if (this.listeners.OnceExit) {
        if (root.type === 'document') {
          for (let subRoot of root.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot)
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root)
        }
      }
    }

    return this.result
  }

  then(onFulfilled, onRejected) {
    if (true) {
      if (!('from' in this.opts)) {
        warnOnce(
          'Without `from` option PostCSS could generate wrong source map ' +
            'and will not find Browserslist config. Set it to CSS file path ' +
            'or to `undefined` to prevent this warning.'
        )
      }
    }
    return this.async().then(onFulfilled, onRejected)
  }

  toString() {
    return this.css
  }

  visitSync(visitors, node) {
    for (let [plugin, visitor] of visitors) {
      this.result.lastPlugin = plugin
      let promise
      try {
        promise = visitor(node, this.helpers)
      } catch (e) {
        throw this.handleError(e, node.proxyOf)
      }
      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
        return true
      }
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }
  }

  visitTick(stack) {
    let visit = stack[stack.length - 1]
    let { node, visitors } = visit

    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
      stack.pop()
      return
    }

    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
      let [plugin, visitor] = visitors[visit.visitorIndex]
      visit.visitorIndex += 1
      if (visit.visitorIndex === visitors.length) {
        visit.visitors = []
        visit.visitorIndex = 0
      }
      this.result.lastPlugin = plugin
      try {
        return visitor(node.toProxy(), this.helpers)
      } catch (e) {
        throw this.handleError(e, node)
      }
    }

    if (visit.iterator !== 0) {
      let iterator = visit.iterator
      let child
      while ((child = node.nodes[node.indexes[iterator]])) {
        node.indexes[iterator] += 1
        if (!child[isClean]) {
          child[isClean] = true
          stack.push(toStack(child))
          return
        }
      }
      visit.iterator = 0
      delete node.indexes[iterator]
    }

    let events = visit.events
    while (visit.eventIndex < events.length) {
      let event = events[visit.eventIndex]
      visit.eventIndex += 1
      if (event === CHILDREN) {
        if (node.nodes && node.nodes.length) {
          node[isClean] = true
          visit.iterator = node.getIterator()
        }
        return
      } else if (this.listeners[event]) {
        visit.visitors = this.listeners[event]
        return
      }
    }
    stack.pop()
  }

  walkSync(node) {
    node[isClean] = true
    let events = getEvents(node)
    for (let event of events) {
      if (event === CHILDREN) {
        if (node.nodes) {
          node.each(child => {
            if (!child[isClean]) this.walkSync(child)
          })
        }
      } else {
        let visitors = this.listeners[event]
        if (visitors) {
          if (this.visitSync(visitors, node.toProxy())) return
        }
      }
    }
  }

  warnings() {
    return this.sync().warnings()
  }

  get content() {
    return this.stringify().content
  }

  get css() {
    return this.stringify().css
  }

  get map() {
    return this.stringify().map
  }

  get messages() {
    return this.sync().messages
  }

  get opts() {
    return this.result.opts
  }

  get processor() {
    return this.result.processor
  }

  get root() {
    return this.sync().root
  }

  get [Symbol.toStringTag]() {
    return 'LazyResult'
  }
}

LazyResult.registerPostcss = dependant => {
  postcss = dependant
}

module.exports = LazyResult
LazyResult.default = LazyResult

Root.registerLazyResult(LazyResult)
Document.registerLazyResult(LazyResult)


/***/ }),

/***/ "./node_modules/postcss/lib/list.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/list.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


let list = {
  comma(string) {
    return list.split(string, [','], true)
  },

  space(string) {
    let spaces = [' ', '\n', '\t']
    return list.split(string, spaces)
  },

  split(string, separators, last) {
    let array = []
    let current = ''
    let split = false

    let func = 0
    let inQuote = false
    let prevQuote = ''
    let escape = false

    for (let letter of string) {
      if (escape) {
        escape = false
      } else if (letter === '\\') {
        escape = true
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true
        prevQuote = letter
      } else if (letter === '(') {
        func += 1
      } else if (letter === ')') {
        if (func > 0) func -= 1
      } else if (func === 0) {
        if (separators.includes(letter)) split = true
      }

      if (split) {
        if (current !== '') array.push(current.trim())
        current = ''
        split = false
      } else {
        current += letter
      }
    }

    if (last || current !== '') array.push(current.trim())
    return array
  }
}

module.exports = list
list.default = list


/***/ }),

/***/ "./node_modules/postcss/lib/map-generator.js":
/*!***************************************************!*\
  !*** ./node_modules/postcss/lib/map-generator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { dirname, relative, resolve, sep } = __webpack_require__(/*! path */ "?6197")
let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ "?b8cb")
let { pathToFileURL } = __webpack_require__(/*! url */ "?c717")

let Input = __webpack_require__(/*! ./input */ "./node_modules/postcss/lib/input.js")

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(dirname && resolve && relative && sep)

class MapGenerator {
  constructor(stringify, root, opts, cssString) {
    this.stringify = stringify
    this.mapOpts = opts.map || {}
    this.root = root
    this.opts = opts
    this.css = cssString
    this.originalCSS = cssString
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute

    this.memoizedFileURLs = new Map()
    this.memoizedPaths = new Map()
    this.memoizedURLs = new Map()
  }

  addAnnotation() {
    let content

    if (this.isInline()) {
      content =
        'data:application/json;base64,' + this.toBase64(this.map.toString())
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation
    } else if (typeof this.mapOpts.annotation === 'function') {
      content = this.mapOpts.annotation(this.opts.to, this.root)
    } else {
      content = this.outputFile() + '.map'
    }
    let eol = '\n'
    if (this.css.includes('\r\n')) eol = '\r\n'

    this.css += eol + '/*# sourceMappingURL=' + content + ' */'
  }

  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file))
      let root = prev.root || dirname(prev.file)
      let map

      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text)
        if (map.sourcesContent) {
          map.sourcesContent = null
        }
      } else {
        map = prev.consumer()
      }

      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))
    }
  }

  clearAnnotation() {
    if (this.mapOpts.annotation === false) return

    if (this.root) {
      let node
      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
        node = this.root.nodes[i]
        if (node.type !== 'comment') continue
        if (node.text.startsWith('# sourceMappingURL=')) {
          this.root.removeChild(i)
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, '')
    }
  }

  generate() {
    this.clearAnnotation()
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap()
    } else {
      let result = ''
      this.stringify(this.root, i => {
        result += i
      })
      return [result]
    }
  }

  generateMap() {
    if (this.root) {
      this.generateString()
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer()
      prev.file = this.outputFile()
      this.map = SourceMapGenerator.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      })
    } else {
      this.map = new SourceMapGenerator({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      })
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from
          ? this.toUrl(this.path(this.opts.from))
          : '<no source>'
      })
    }

    if (this.isSourcesContent()) this.setSourcesContent()
    if (this.root && this.previous().length > 0) this.applyPrevMaps()
    if (this.isAnnotation()) this.addAnnotation()

    if (this.isInline()) {
      return [this.css]
    } else {
      return [this.css, this.map]
    }
  }

  generateString() {
    this.css = ''
    this.map = new SourceMapGenerator({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    })

    let line = 1
    let column = 1

    let noSource = '<no source>'
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ''
    }

    let last, lines
    this.stringify(this.root, (str, node, type) => {
      this.css += str

      if (node && type !== 'end') {
        mapping.generated.line = line
        mapping.generated.column = column - 1
        if (node.source && node.source.start) {
          mapping.source = this.sourcePath(node)
          mapping.original.line = node.source.start.line
          mapping.original.column = node.source.start.column - 1
          this.map.addMapping(mapping)
        } else {
          mapping.source = noSource
          mapping.original.line = 1
          mapping.original.column = 0
          this.map.addMapping(mapping)
        }
      }

      lines = str.match(/\n/g)
      if (lines) {
        line += lines.length
        last = str.lastIndexOf('\n')
        column = str.length - last
      } else {
        column += str.length
      }

      if (node && type !== 'start') {
        let p = node.parent || { raws: {} }
        let childless =
          node.type === 'decl' || (node.type === 'atrule' && !node.nodes)
        if (!childless || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            mapping.source = this.sourcePath(node)
            mapping.original.line = node.source.end.line
            mapping.original.column = node.source.end.column - 1
            mapping.generated.line = line
            mapping.generated.column = column - 2
            this.map.addMapping(mapping)
          } else {
            mapping.source = noSource
            mapping.original.line = 1
            mapping.original.column = 0
            mapping.generated.line = line
            mapping.generated.column = column - 1
            this.map.addMapping(mapping)
          }
        }
      }
    })
  }

  isAnnotation() {
    if (this.isInline()) {
      return true
    }
    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation
    }
    if (this.previous().length) {
      return this.previous().some(i => i.annotation)
    }
    return true
  }

  isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline
    }

    let annotation = this.mapOpts.annotation
    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false
    }

    if (this.previous().length) {
      return this.previous().some(i => i.inline)
    }
    return true
  }

  isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map
    }
    return this.previous().length > 0
  }

  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent
    }
    if (this.previous().length) {
      return this.previous().some(i => i.withContent())
    }
    return true
  }

  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to)
    } else if (this.opts.from) {
      return this.path(this.opts.from)
    } else {
      return 'to.css'
    }
  }

  path(file) {
    if (this.mapOpts.absolute) return file
    if (file.charCodeAt(0) === 60 /* `<` */) return file
    if (/^\w+:\/\//.test(file)) return file
    let cached = this.memoizedPaths.get(file)
    if (cached) return cached

    let from = this.opts.to ? dirname(this.opts.to) : '.'

    if (typeof this.mapOpts.annotation === 'string') {
      from = dirname(resolve(from, this.mapOpts.annotation))
    }

    let path = relative(from, file)
    this.memoizedPaths.set(file, path)

    return path
  }

  previous() {
    if (!this.previousMaps) {
      this.previousMaps = []
      if (this.root) {
        this.root.walk(node => {
          if (node.source && node.source.input.map) {
            let map = node.source.input.map
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map)
            }
          }
        })
      } else {
        let input = new Input(this.originalCSS, this.opts)
        if (input.map) this.previousMaps.push(input.map)
      }
    }

    return this.previousMaps
  }

  setSourcesContent() {
    let already = {}
    if (this.root) {
      this.root.walk(node => {
        if (node.source) {
          let from = node.source.input.from
          if (from && !already[from]) {
            already[from] = true
            let fromUrl = this.usesFileUrls
              ? this.toFileUrl(from)
              : this.toUrl(this.path(from))
            this.map.setSourceContent(fromUrl, node.source.input.css)
          }
        }
      })
    } else if (this.css) {
      let from = this.opts.from
        ? this.toUrl(this.path(this.opts.from))
        : '<no source>'
      this.map.setSourceContent(from, this.css)
    }
  }

  sourcePath(node) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from)
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node.source.input.from)
    } else {
      return this.toUrl(this.path(node.source.input.from))
    }
  }

  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64')
    } else {
      return window.btoa(unescape(encodeURIComponent(str)))
    }
  }

  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path)
    if (cached) return cached

    if (pathToFileURL) {
      let fileURL = pathToFileURL(path).toString()
      this.memoizedFileURLs.set(path, fileURL)

      return fileURL
    } else {
      throw new Error(
        '`map.absolute` option is not available in this PostCSS build'
      )
    }
  }

  toUrl(path) {
    let cached = this.memoizedURLs.get(path)
    if (cached) return cached

    if (sep === '\\') {
      path = path.replace(/\\/g, '/')
    }

    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent)
    this.memoizedURLs.set(path, url)

    return url
  }
}

module.exports = MapGenerator


/***/ }),

/***/ "./node_modules/postcss/lib/no-work-result.js":
/*!****************************************************!*\
  !*** ./node_modules/postcss/lib/no-work-result.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let MapGenerator = __webpack_require__(/*! ./map-generator */ "./node_modules/postcss/lib/map-generator.js")
let parse = __webpack_require__(/*! ./parse */ "./node_modules/postcss/lib/parse.js")
const Result = __webpack_require__(/*! ./result */ "./node_modules/postcss/lib/result.js")
let stringify = __webpack_require__(/*! ./stringify */ "./node_modules/postcss/lib/stringify.js")
let warnOnce = __webpack_require__(/*! ./warn-once */ "./node_modules/postcss/lib/warn-once.js")

class NoWorkResult {
  constructor(processor, css, opts) {
    css = css.toString()
    this.stringified = false

    this._processor = processor
    this._css = css
    this._opts = opts
    this._map = undefined
    let root

    let str = stringify
    this.result = new Result(this._processor, root, this._opts)
    this.result.css = css

    let self = this
    Object.defineProperty(this.result, 'root', {
      get() {
        return self.root
      }
    })

    let map = new MapGenerator(str, root, this._opts, css)
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate()
      if (generatedCSS) {
        this.result.css = generatedCSS
      }
      if (generatedMap) {
        this.result.map = generatedMap
      }
    } else {
      map.clearAnnotation()
      this.result.css = map.css
    }
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    return Promise.resolve(this.result)
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  sync() {
    if (this.error) throw this.error
    return this.result
  }

  then(onFulfilled, onRejected) {
    if (true) {
      if (!('from' in this._opts)) {
        warnOnce(
          'Without `from` option PostCSS could generate wrong source map ' +
            'and will not find Browserslist config. Set it to CSS file path ' +
            'or to `undefined` to prevent this warning.'
        )
      }
    }

    return this.async().then(onFulfilled, onRejected)
  }

  toString() {
    return this._css
  }

  warnings() {
    return []
  }

  get content() {
    return this.result.css
  }

  get css() {
    return this.result.css
  }

  get map() {
    return this.result.map
  }

  get messages() {
    return []
  }

  get opts() {
    return this.result.opts
  }

  get processor() {
    return this.result.processor
  }

  get root() {
    if (this._root) {
      return this._root
    }

    let root
    let parser = parse

    try {
      root = parser(this._css, this._opts)
    } catch (error) {
      this.error = error
    }

    if (this.error) {
      throw this.error
    } else {
      this._root = root
      return root
    }
  }

  get [Symbol.toStringTag]() {
    return 'NoWorkResult'
  }
}

module.exports = NoWorkResult
NoWorkResult.default = NoWorkResult


/***/ }),

/***/ "./node_modules/postcss/lib/node.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/node.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ "./node_modules/postcss/lib/css-syntax-error.js")
let Stringifier = __webpack_require__(/*! ./stringifier */ "./node_modules/postcss/lib/stringifier.js")
let stringify = __webpack_require__(/*! ./stringify */ "./node_modules/postcss/lib/stringify.js")
let { isClean, my } = __webpack_require__(/*! ./symbols */ "./node_modules/postcss/lib/symbols.js")

function cloneNode(obj, parent) {
  let cloned = new obj.constructor()

  for (let i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      /* c8 ignore next 2 */
      continue
    }
    if (i === 'proxyCache') continue
    let value = obj[i]
    let type = typeof value

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent
    } else if (i === 'source') {
      cloned[i] = value
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(j => cloneNode(j, cloned))
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value)
      cloned[i] = value
    }
  }

  return cloned
}

class Node {
  constructor(defaults = {}) {
    this.raws = {}
    this[isClean] = false
    this[my] = true

    for (let name in defaults) {
      if (name === 'nodes') {
        this.nodes = []
        for (let node of defaults[name]) {
          if (typeof node.clone === 'function') {
            this.append(node.clone())
          } else {
            this.append(node)
          }
        }
      } else {
        this[name] = defaults[name]
      }
    }
  }

  addToError(error) {
    error.postcssNode = this
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s = this.source
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
      )
    }
    return error
  }

  after(add) {
    this.parent.insertAfter(this, add)
    return this
  }

  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name]
    }
    return this
  }

  before(add) {
    this.parent.insertBefore(this, add)
    return this
  }

  cleanRaws(keepBetween) {
    delete this.raws.before
    delete this.raws.after
    if (!keepBetween) delete this.raws.between
  }

  clone(overrides = {}) {
    let cloned = cloneNode(this)
    for (let name in overrides) {
      cloned[name] = overrides[name]
    }
    return cloned
  }

  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertAfter(this, cloned)
    return cloned
  }

  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertBefore(this, cloned)
    return cloned
  }

  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts)
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      )
    }
    return new CssSyntaxError(message)
  }

  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else {
          return node[prop]
        }
      },

      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (
          prop === 'prop' ||
          prop === 'value' ||
          prop === 'name' ||
          prop === 'params' ||
          prop === 'important' ||
          /* c8 ignore next */
          prop === 'text'
        ) {
          node.markDirty()
        }
        return true
      }
    }
  }

  /* c8 ignore next 3 */
  markClean() {
    this[isClean] = true
  }

  markDirty() {
    if (this[isClean]) {
      this[isClean] = false
      let next = this
      while ((next = next.parent)) {
        next[isClean] = false
      }
    }
  }

  next() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index + 1]
  }

  positionBy(opts, stringRepresentation) {
    let pos = this.source.start
    if (opts.index) {
      pos = this.positionInside(opts.index, stringRepresentation)
    } else if (opts.word) {
      stringRepresentation = this.toString()
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) pos = this.positionInside(index, stringRepresentation)
    }
    return pos
  }

  positionInside(index, stringRepresentation) {
    let string = stringRepresentation || this.toString()
    let column = this.source.start.column
    let line = this.source.start.line

    for (let i = 0; i < index; i++) {
      if (string[i] === '\n') {
        column = 1
        line += 1
      } else {
        column += 1
      }
    }

    return { column, line }
  }

  prev() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index - 1]
  }

  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    }
    let end = this.source.end
      ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        }
      : {
          column: start.column + 1,
          line: start.line
        }

    if (opts.word) {
      let stringRepresentation = this.toString()
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) {
        start = this.positionInside(index, stringRepresentation)
        end = this.positionInside(
          index + opts.word.length,
          stringRepresentation
        )
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        }
      } else if (opts.index) {
        start = this.positionInside(opts.index)
      }

      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        }
      } else if (typeof opts.endIndex === 'number') {
        end = this.positionInside(opts.endIndex)
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1)
      }
    }

    if (
      end.line < start.line ||
      (end.line === start.line && end.column <= start.column)
    ) {
      end = { column: start.column + 1, line: start.line }
    }

    return { end, start }
  }

  raw(prop, defaultType) {
    let str = new Stringifier()
    return str.raw(this, prop, defaultType)
  }

  remove() {
    if (this.parent) {
      this.parent.removeChild(this)
    }
    this.parent = undefined
    return this
  }

  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this
      let foundSelf = false
      for (let node of nodes) {
        if (node === this) {
          foundSelf = true
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node)
          bookmark = node
        } else {
          this.parent.insertBefore(bookmark, node)
        }
      }

      if (!foundSelf) {
        this.remove()
      }
    }

    return this
  }

  root() {
    let result = this
    while (result.parent && result.parent.type !== 'document') {
      result = result.parent
    }
    return result
  }

  toJSON(_, inputs) {
    let fixed = {}
    let emitInputs = inputs == null
    inputs = inputs || new Map()
    let inputsNextIndex = 0

    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        /* c8 ignore next 2 */
        continue
      }
      if (name === 'parent' || name === 'proxyCache') continue
      let value = this[name]

      if (Array.isArray(value)) {
        fixed[name] = value.map(i => {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON(null, inputs)
          } else {
            return i
          }
        })
      } else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs)
      } else if (name === 'source') {
        let inputId = inputs.get(value.input)
        if (inputId == null) {
          inputId = inputsNextIndex
          inputs.set(value.input, inputsNextIndex)
          inputsNextIndex++
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        }
      } else {
        fixed[name] = value
      }
    }

    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())
    }

    return fixed
  }

  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor())
    }
    return this.proxyCache
  }

  toString(stringifier = stringify) {
    if (stringifier.stringify) stringifier = stringifier.stringify
    let result = ''
    stringifier(this, i => {
      result += i
    })
    return result
  }

  warn(result, text, opts) {
    let data = { node: this }
    for (let i in opts) data[i] = opts[i]
    return result.warn(text, data)
  }

  get proxyOf() {
    return this
  }
}

module.exports = Node
Node.default = Node


/***/ }),

/***/ "./node_modules/postcss/lib/parse.js":
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/parse.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(/*! ./container */ "./node_modules/postcss/lib/container.js")
let Input = __webpack_require__(/*! ./input */ "./node_modules/postcss/lib/input.js")
let Parser = __webpack_require__(/*! ./parser */ "./node_modules/postcss/lib/parser.js")

function parse(css, opts) {
  let input = new Input(css, opts)
  let parser = new Parser(input)
  try {
    parser.parse()
  } catch (e) {
    if (true) {
      if (e.name === 'CssSyntaxError' && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e.message +=
            '\nYou tried to parse SCSS with ' +
            'the standard CSS parser; ' +
            'try again with the postcss-scss parser'
        } else if (/\.sass/i.test(opts.from)) {
          e.message +=
            '\nYou tried to parse Sass with ' +
            'the standard CSS parser; ' +
            'try again with the postcss-sass parser'
        } else if (/\.less$/i.test(opts.from)) {
          e.message +=
            '\nYou tried to parse Less with ' +
            'the standard CSS parser; ' +
            'try again with the postcss-less parser'
        }
      }
    }
    throw e
  }

  return parser.root
}

module.exports = parse
parse.default = parse

Container.registerParse(parse)


/***/ }),

/***/ "./node_modules/postcss/lib/parser.js":
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/parser.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let AtRule = __webpack_require__(/*! ./at-rule */ "./node_modules/postcss/lib/at-rule.js")
let Comment = __webpack_require__(/*! ./comment */ "./node_modules/postcss/lib/comment.js")
let Declaration = __webpack_require__(/*! ./declaration */ "./node_modules/postcss/lib/declaration.js")
let Root = __webpack_require__(/*! ./root */ "./node_modules/postcss/lib/root.js")
let Rule = __webpack_require__(/*! ./rule */ "./node_modules/postcss/lib/rule.js")
let tokenizer = __webpack_require__(/*! ./tokenize */ "./node_modules/postcss/lib/tokenize.js")

const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
}

function findLastWithPosition(tokens) {
  for (let i = tokens.length - 1; i >= 0; i--) {
    let token = tokens[i]
    let pos = token[3] || token[2]
    if (pos) return pos
  }
}

class Parser {
  constructor(input) {
    this.input = input

    this.root = new Root()
    this.current = this.root
    this.spaces = ''
    this.semicolon = false

    this.createTokenizer()
    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }
  }

  atrule(token) {
    let node = new AtRule()
    node.name = token[1].slice(1)
    if (node.name === '') {
      this.unnamedAtrule(node, token)
    }
    this.init(node, token[2])

    let type
    let prev
    let shift
    let last = false
    let open = false
    let params = []
    let brackets = []

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()
      type = token[0]

      if (type === '(' || type === '[') {
        brackets.push(type === '(' ? ')' : ']')
      } else if (type === '{' && brackets.length > 0) {
        brackets.push('}')
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
      }

      if (brackets.length === 0) {
        if (type === ';') {
          node.source.end = this.getPosition(token[2])
          node.source.end.offset++
          this.semicolon = true
          break
        } else if (type === '{') {
          open = true
          break
        } else if (type === '}') {
          if (params.length > 0) {
            shift = params.length - 1
            prev = params[shift]
            while (prev && prev[0] === 'space') {
              prev = params[--shift]
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2])
              node.source.end.offset++
            }
          }
          this.end(token)
          break
        } else {
          params.push(token)
        }
      } else {
        params.push(token)
      }

      if (this.tokenizer.endOfFile()) {
        last = true
        break
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params)
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params)
      this.raw(node, 'params', params)
      if (last) {
        token = params[params.length - 1]
        node.source.end = this.getPosition(token[3] || token[2])
        node.source.end.offset++
        this.spaces = node.raws.between
        node.raws.between = ''
      }
    } else {
      node.raws.afterName = ''
      node.params = ''
    }

    if (open) {
      node.nodes = []
      this.current = node
    }
  }

  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens)
    if (colon === false) return

    let founded = 0
    let token
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j]
      if (token[0] !== 'space') {
        founded += 1
        if (founded === 2) break
      }
    }
    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error(
      'Missed semicolon',
      token[0] === 'word' ? token[3] + 1 : token[2]
    )
  }

  colon(tokens) {
    let brackets = 0
    let prev, token, type
    for (let [i, element] of tokens.entries()) {
      token = element
      type = token[0]

      if (type === '(') {
        brackets += 1
      }
      if (type === ')') {
        brackets -= 1
      }
      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token)
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue
        } else {
          return i
        }
      }

      prev = token
    }
    return false
  }

  comment(token) {
    let node = new Comment()
    this.init(node, token[2])
    node.source.end = this.getPosition(token[3] || token[2])
    node.source.end.offset++

    let text = token[1].slice(2, -2)
    if (/^\s*$/.test(text)) {
      node.text = ''
      node.raws.left = text
      node.raws.right = ''
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
    }
  }

  createTokenizer() {
    this.tokenizer = tokenizer(this.input)
  }

  decl(tokens, customProperty) {
    let node = new Declaration()
    this.init(node, tokens[0][2])

    let last = tokens[tokens.length - 1]
    if (last[0] === ';') {
      this.semicolon = true
      tokens.pop()
    }

    node.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    )
    node.source.end.offset++

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens)
      node.raws.before += tokens.shift()[1]
    }
    node.source.start = this.getPosition(tokens[0][2])

    node.prop = ''
    while (tokens.length) {
      let type = tokens[0][0]
      if (type === ':' || type === 'space' || type === 'comment') {
        break
      }
      node.prop += tokens.shift()[1]
    }

    node.raws.between = ''

    let token
    while (tokens.length) {
      token = tokens.shift()

      if (token[0] === ':') {
        node.raws.between += token[1]
        break
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token])
        }
        node.raws.between += token[1]
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0]
      node.prop = node.prop.slice(1)
    }

    let firstSpaces = []
    let next
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      firstSpaces.push(tokens.shift())
    }

    this.precheckMissedSemicolon(tokens)

    for (let i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i]
      if (token[1].toLowerCase() === '!important') {
        node.important = true
        let string = this.stringFrom(tokens, i)
        string = this.spacesFromEnd(tokens) + string
        if (string !== ' !important') node.raws.important = string
        break
      } else if (token[1].toLowerCase() === 'important') {
        let cache = tokens.slice(0)
        let str = ''
        for (let j = i; j > 0; j--) {
          let type = cache[j][0]
          if (str.trim().startsWith('!') && type !== 'space') {
            break
          }
          str = cache.pop()[1] + str
        }
        if (str.trim().startsWith('!')) {
          node.important = true
          node.raws.important = str
          tokens = cache
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break
      }
    }

    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')

    if (hasWord) {
      node.raws.between += firstSpaces.map(i => i[1]).join('')
      firstSpaces = []
    }
    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)

    if (node.value.includes(':') && !customProperty) {
      this.checkMissedSemicolon(tokens)
    }
  }

  doubleColon(token) {
    throw this.input.error(
      'Double colon',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }

  emptyRule(token) {
    let node = new Rule()
    this.init(node, token[2])
    node.selector = ''
    node.raws.between = ''
    this.current = node
  }

  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.semicolon = false

    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.spaces = ''

    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2])
      this.current.source.end.offset++
      this.current = this.current.parent
    } else {
      this.unexpectedClose(token)
    }
  }

  endFile() {
    if (this.current.parent) this.unclosedBlock()
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.root.source.end = this.getPosition(this.tokenizer.position())
  }

  freeSemicolon(token) {
    this.spaces += token[1]
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1]
      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces
        this.spaces = ''
      }
    }
  }

  // Helpers

  getPosition(offset) {
    let pos = this.input.fromOffset(offset)
    return {
      column: pos.col,
      line: pos.line,
      offset
    }
  }

  init(node, offset) {
    this.current.push(node)
    node.source = {
      input: this.input,
      start: this.getPosition(offset)
    }
    node.raws.before = this.spaces
    this.spaces = ''
    if (node.type !== 'comment') this.semicolon = false
  }

  other(start) {
    let end = false
    let type = null
    let colon = false
    let bracket = null
    let brackets = []
    let customProperty = start[1].startsWith('--')

    let tokens = []
    let token = start
    while (token) {
      type = token[0]
      tokens.push(token)

      if (type === '(' || type === '[') {
        if (!bracket) bracket = token
        brackets.push(type === '(' ? ')' : ']')
      } else if (customProperty && colon && type === '{') {
        if (!bracket) bracket = token
        brackets.push('}')
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens, customProperty)
            return
          } else {
            break
          }
        } else if (type === '{') {
          this.rule(tokens)
          return
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop())
          end = true
          break
        } else if (type === ':') {
          colon = true
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
        if (brackets.length === 0) bracket = null
      }

      token = this.tokenizer.nextToken()
    }

    if (this.tokenizer.endOfFile()) end = true
    if (brackets.length > 0) this.unclosedBracket(bracket)

    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0]
          if (token !== 'space' && token !== 'comment') break
          this.tokenizer.back(tokens.pop())
        }
      }
      this.decl(tokens, customProperty)
    } else {
      this.unknownWord(tokens)
    }
  }

  parse() {
    let token
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()

      switch (token[0]) {
        case 'space':
          this.spaces += token[1]
          break

        case ';':
          this.freeSemicolon(token)
          break

        case '}':
          this.end(token)
          break

        case 'comment':
          this.comment(token)
          break

        case 'at-word':
          this.atrule(token)
          break

        case '{':
          this.emptyRule(token)
          break

        default:
          this.other(token)
          break
      }
    }
    this.endFile()
  }

  precheckMissedSemicolon(/* tokens */) {
    // Hook for Safe Parser
  }

  raw(node, prop, tokens, customProperty) {
    let token, type
    let length = tokens.length
    let value = ''
    let clean = true
    let next, prev

    for (let i = 0; i < length; i += 1) {
      token = tokens[i]
      type = token[0]
      if (type === 'space' && i === length - 1 && !customProperty) {
        clean = false
      } else if (type === 'comment') {
        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'
        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ',') {
            clean = false
          } else {
            value += token[1]
          }
        } else {
          clean = false
        }
      } else {
        value += token[1]
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i) => all + i[1], '')
      node.raws[prop] = { raw, value }
    }
    node[prop] = value
  }

  rule(tokens) {
    tokens.pop()

    let node = new Rule()
    this.init(node, tokens[0][2])

    node.raws.between = this.spacesAndCommentsFromEnd(tokens)
    this.raw(node, 'selector', tokens)
    this.current = node
  }

  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  // Errors

  spacesAndCommentsFromStart(tokens) {
    let next
    let spaces = ''
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      spaces += tokens.shift()[1]
    }
    return spaces
  }

  spacesFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  stringFrom(tokens, from) {
    let result = ''
    for (let i = from; i < tokens.length; i++) {
      result += tokens[i][1]
    }
    tokens.splice(from, tokens.length - from)
    return result
  }

  unclosedBlock() {
    let pos = this.current.source.start
    throw this.input.error('Unclosed block', pos.line, pos.column)
  }

  unclosedBracket(bracket) {
    throw this.input.error(
      'Unclosed bracket',
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    )
  }

  unexpectedClose(token) {
    throw this.input.error(
      'Unexpected }',
      { offset: token[2] },
      { offset: token[2] + 1 }
    )
  }

  unknownWord(tokens) {
    throw this.input.error(
      'Unknown word',
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    )
  }

  unnamedAtrule(node, token) {
    throw this.input.error(
      'At-rule without name',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }
}

module.exports = Parser


/***/ }),

/***/ "./node_modules/postcss/lib/postcss.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/postcss.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let AtRule = __webpack_require__(/*! ./at-rule */ "./node_modules/postcss/lib/at-rule.js")
let Comment = __webpack_require__(/*! ./comment */ "./node_modules/postcss/lib/comment.js")
let Container = __webpack_require__(/*! ./container */ "./node_modules/postcss/lib/container.js")
let CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ "./node_modules/postcss/lib/css-syntax-error.js")
let Declaration = __webpack_require__(/*! ./declaration */ "./node_modules/postcss/lib/declaration.js")
let Document = __webpack_require__(/*! ./document */ "./node_modules/postcss/lib/document.js")
let fromJSON = __webpack_require__(/*! ./fromJSON */ "./node_modules/postcss/lib/fromJSON.js")
let Input = __webpack_require__(/*! ./input */ "./node_modules/postcss/lib/input.js")
let LazyResult = __webpack_require__(/*! ./lazy-result */ "./node_modules/postcss/lib/lazy-result.js")
let list = __webpack_require__(/*! ./list */ "./node_modules/postcss/lib/list.js")
let Node = __webpack_require__(/*! ./node */ "./node_modules/postcss/lib/node.js")
let parse = __webpack_require__(/*! ./parse */ "./node_modules/postcss/lib/parse.js")
let Processor = __webpack_require__(/*! ./processor */ "./node_modules/postcss/lib/processor.js")
let Result = __webpack_require__(/*! ./result.js */ "./node_modules/postcss/lib/result.js")
let Root = __webpack_require__(/*! ./root */ "./node_modules/postcss/lib/root.js")
let Rule = __webpack_require__(/*! ./rule */ "./node_modules/postcss/lib/rule.js")
let stringify = __webpack_require__(/*! ./stringify */ "./node_modules/postcss/lib/stringify.js")
let Warning = __webpack_require__(/*! ./warning */ "./node_modules/postcss/lib/warning.js")

function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0]
  }
  return new Processor(plugins)
}

postcss.plugin = function plugin(name, initializer) {
  let warningPrinted = false
  function creator(...args) {
    // eslint-disable-next-line no-console
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true
      // eslint-disable-next-line no-console
      console.warn(
        name +
          ': postcss.plugin was deprecated. Migration guide:\n' +
          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'
      )
      if (process.env.LANG && process.env.LANG.startsWith('cn')) {
        /* c8 ignore next 7 */
        // eslint-disable-next-line no-console
        console.warn(
          name +
            ': 里面 postcss.plugin 被弃用. 迁移指南:\n' +
            'https://www.w3ctech.com/topic/2226'
        )
      }
    }
    let transformer = initializer(...args)
    transformer.postcssPlugin = name
    transformer.postcssVersion = new Processor().version
    return transformer
  }

  let cache
  Object.defineProperty(creator, 'postcss', {
    get() {
      if (!cache) cache = creator()
      return cache
    }
  })

  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts)
  }

  return creator
}

postcss.stringify = stringify
postcss.parse = parse
postcss.fromJSON = fromJSON
postcss.list = list

postcss.comment = defaults => new Comment(defaults)
postcss.atRule = defaults => new AtRule(defaults)
postcss.decl = defaults => new Declaration(defaults)
postcss.rule = defaults => new Rule(defaults)
postcss.root = defaults => new Root(defaults)
postcss.document = defaults => new Document(defaults)

postcss.CssSyntaxError = CssSyntaxError
postcss.Declaration = Declaration
postcss.Container = Container
postcss.Processor = Processor
postcss.Document = Document
postcss.Comment = Comment
postcss.Warning = Warning
postcss.AtRule = AtRule
postcss.Result = Result
postcss.Input = Input
postcss.Rule = Rule
postcss.Root = Root
postcss.Node = Node

LazyResult.registerPostcss(postcss)

module.exports = postcss
postcss.default = postcss


/***/ }),

/***/ "./node_modules/postcss/lib/previous-map.js":
/*!**************************************************!*\
  !*** ./node_modules/postcss/lib/previous-map.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { existsSync, readFileSync } = __webpack_require__(/*! fs */ "?03fb")
let { dirname, join } = __webpack_require__(/*! path */ "?6197")
let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ "?b8cb")

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString()
  } else {
    /* c8 ignore next 2 */
    return window.atob(str)
  }
}

class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return
    this.loadAnnotation(css)
    this.inline = this.startWith(this.annotation, 'data:')

    let prev = opts.map ? opts.map.prev : undefined
    let text = this.loadMap(opts.from, prev)
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from
    }
    if (this.mapFile) this.root = dirname(this.mapFile)
    if (text) this.text = text
  }

  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer(this.text)
    }
    return this.consumerCache
  }

  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/
    let baseUri = /^data:application\/json;base64,/
    let charsetUri = /^data:application\/json;charset=utf-?8,/
    let uri = /^data:application\/json,/

    let uriMatch = text.match(charsetUri) || text.match(uri)
    if (uriMatch) {
      return decodeURIComponent(text.substr(uriMatch[0].length))
    }

    let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri)
    if (baseUriMatch) {
      return fromBase64(text.substr(baseUriMatch[0].length))
    }

    let encoding = text.match(/data:application\/json;([^,]+),/)[1]
    throw new Error('Unsupported source map encoding ' + encoding)
  }

  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim()
  }

  isMap(map) {
    if (typeof map !== 'object') return false
    return (
      typeof map.mappings === 'string' ||
      typeof map._mappings === 'string' ||
      Array.isArray(map.sections)
    )
  }

  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/g)
    if (!comments) return

    // sourceMappingURLs from comments, strings, etc.
    let start = css.lastIndexOf(comments.pop())
    let end = css.indexOf('*/', start)

    if (start > -1 && end > -1) {
      // Locate the last sourceMappingURL to avoid pickin
      this.annotation = this.getAnnotationURL(css.substring(start, end))
    }
  }

  loadFile(path) {
    this.root = dirname(path)
    if (existsSync(path)) {
      this.mapFile = path
      return readFileSync(path, 'utf-8').toString().trim()
    }
  }

  loadMap(file, prev) {
    if (prev === false) return false

    if (prev) {
      if (typeof prev === 'string') {
        return prev
      } else if (typeof prev === 'function') {
        let prevPath = prev(file)
        if (prevPath) {
          let map = this.loadFile(prevPath)
          if (!map) {
            throw new Error(
              'Unable to load previous source map: ' + prevPath.toString()
            )
          }
          return map
        }
      } else if (prev instanceof SourceMapConsumer) {
        return SourceMapGenerator.fromSourceMap(prev).toString()
      } else if (prev instanceof SourceMapGenerator) {
        return prev.toString()
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev)
      } else {
        throw new Error(
          'Unsupported previous source map format: ' + prev.toString()
        )
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation)
    } else if (this.annotation) {
      let map = this.annotation
      if (file) map = join(dirname(file), map)
      return this.loadFile(map)
    }
  }

  startWith(string, start) {
    if (!string) return false
    return string.substr(0, start.length) === start
  }

  withContent() {
    return !!(
      this.consumer().sourcesContent &&
      this.consumer().sourcesContent.length > 0
    )
  }
}

module.exports = PreviousMap
PreviousMap.default = PreviousMap


/***/ }),

/***/ "./node_modules/postcss/lib/processor.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/processor.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Document = __webpack_require__(/*! ./document */ "./node_modules/postcss/lib/document.js")
let LazyResult = __webpack_require__(/*! ./lazy-result */ "./node_modules/postcss/lib/lazy-result.js")
let NoWorkResult = __webpack_require__(/*! ./no-work-result */ "./node_modules/postcss/lib/no-work-result.js")
let Root = __webpack_require__(/*! ./root */ "./node_modules/postcss/lib/root.js")

class Processor {
  constructor(plugins = []) {
    this.version = '8.4.45'
    this.plugins = this.normalize(plugins)
  }

  normalize(plugins) {
    let normalized = []
    for (let i of plugins) {
      if (i.postcss === true) {
        i = i()
      } else if (i.postcss) {
        i = i.postcss
      }

      if (typeof i === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins)
      } else if (typeof i === 'object' && i.postcssPlugin) {
        normalized.push(i)
      } else if (typeof i === 'function') {
        normalized.push(i)
      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
        if (true) {
          throw new Error(
            'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +
              'one of the syntax/parser/stringifier options as outlined ' +
              'in your PostCSS runner documentation.'
          )
        }
      } else {
        throw new Error(i + ' is not a PostCSS plugin')
      }
    }
    return normalized
  }

  process(css, opts = {}) {
    if (
      !this.plugins.length &&
      !opts.parser &&
      !opts.stringifier &&
      !opts.syntax
    ) {
      return new NoWorkResult(this, css, opts)
    } else {
      return new LazyResult(this, css, opts)
    }
  }

  use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]))
    return this
  }
}

module.exports = Processor
Processor.default = Processor

Root.registerProcessor(Processor)
Document.registerProcessor(Processor)


/***/ }),

/***/ "./node_modules/postcss/lib/result.js":
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/result.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Warning = __webpack_require__(/*! ./warning */ "./node_modules/postcss/lib/warning.js")

class Result {
  constructor(processor, root, opts) {
    this.processor = processor
    this.messages = []
    this.root = root
    this.opts = opts
    this.css = undefined
    this.map = undefined
  }

  toString() {
    return this.css
  }

  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin
      }
    }

    let warning = new Warning(text, opts)
    this.messages.push(warning)

    return warning
  }

  warnings() {
    return this.messages.filter(i => i.type === 'warning')
  }

  get content() {
    return this.css
  }
}

module.exports = Result
Result.default = Result


/***/ }),

/***/ "./node_modules/postcss/lib/root.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/root.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(/*! ./container */ "./node_modules/postcss/lib/container.js")

let LazyResult, Processor

class Root extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'root'
    if (!this.nodes) this.nodes = []
  }

  normalize(child, sample, type) {
    let nodes = super.normalize(child)

    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before
        } else {
          delete sample.raws.before
        }
      } else if (this.first !== sample) {
        for (let node of nodes) {
          node.raws.before = sample.raws.before
        }
      }
    }

    return nodes
  }

  removeChild(child, ignore) {
    let index = this.index(child)

    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before
    }

    return super.removeChild(child)
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)
    return lazy.stringify()
  }
}

Root.registerLazyResult = dependant => {
  LazyResult = dependant
}

Root.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Root
Root.default = Root

Container.registerRoot(Root)


/***/ }),

/***/ "./node_modules/postcss/lib/rule.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/rule.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(/*! ./container */ "./node_modules/postcss/lib/container.js")
let list = __webpack_require__(/*! ./list */ "./node_modules/postcss/lib/list.js")

class Rule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'rule'
    if (!this.nodes) this.nodes = []
  }

  get selectors() {
    return list.comma(this.selector)
  }

  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null
    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')
    this.selector = values.join(sep)
  }
}

module.exports = Rule
Rule.default = Rule

Container.registerRule(Rule)


/***/ }),

/***/ "./node_modules/postcss/lib/stringifier.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/stringifier.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


const DEFAULT_RAW = {
  after: '\n',
  beforeClose: '\n',
  beforeComment: '\n',
  beforeDecl: '\n',
  beforeOpen: ' ',
  beforeRule: '\n',
  colon: ': ',
  commentLeft: ' ',
  commentRight: ' ',
  emptyBody: '',
  indent: '    ',
  semicolon: false
}

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1)
}

class Stringifier {
  constructor(builder) {
    this.builder = builder
  }

  atrule(node, semicolon) {
    let name = '@' + node.name
    let params = node.params ? this.rawValue(node, 'params') : ''

    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName
    } else if (params) {
      name += ' '
    }

    if (node.nodes) {
      this.block(node, name + params)
    } else {
      let end = (node.raws.between || '') + (semicolon ? ';' : '')
      this.builder(name + params + end, node)
    }
  }

  beforeAfter(node, detect) {
    let value
    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment')
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule')
    } else {
      value = this.raw(node, null, 'beforeClose')
    }

    let buf = node.parent
    let depth = 0
    while (buf && buf.type !== 'root') {
      depth += 1
      buf = buf.parent
    }

    if (value.includes('\n')) {
      let indent = this.raw(node, null, 'indent')
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent
      }
    }

    return value
  }

  block(node, start) {
    let between = this.raw(node, 'between', 'beforeOpen')
    this.builder(start + between + '{', node, 'start')

    let after
    if (node.nodes && node.nodes.length) {
      this.body(node)
      after = this.raw(node, 'after')
    } else {
      after = this.raw(node, 'after', 'emptyBody')
    }

    if (after) this.builder(after)
    this.builder('}', node, 'end')
  }

  body(node) {
    let last = node.nodes.length - 1
    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break
      last -= 1
    }

    let semicolon = this.raw(node, 'semicolon')
    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i]
      let before = this.raw(child, 'before')
      if (before) this.builder(before)
      this.stringify(child, last !== i || semicolon)
    }
  }

  comment(node) {
    let left = this.raw(node, 'left', 'commentLeft')
    let right = this.raw(node, 'right', 'commentRight')
    this.builder('/*' + left + node.text + right + '*/', node)
  }

  decl(node, semicolon) {
    let between = this.raw(node, 'between', 'colon')
    let string = node.prop + between + this.rawValue(node, 'value')

    if (node.important) {
      string += node.raws.important || ' !important'
    }

    if (semicolon) string += ';'
    this.builder(string, node)
  }

  document(node) {
    this.body(node)
  }

  raw(node, own, detect) {
    let value
    if (!detect) detect = own

    // Already had
    if (own) {
      value = node.raws[own]
      if (typeof value !== 'undefined') return value
    }

    let parent = node.parent

    if (detect === 'before') {
      // Hack for first rule in CSS
      if (!parent || (parent.type === 'root' && parent.first === node)) {
        return ''
      }

      // `root` nodes in `document` should use only their own raws
      if (parent && parent.type === 'document') {
        return ''
      }
    }

    // Floating child without parent
    if (!parent) return DEFAULT_RAW[detect]

    // Detect style by other nodes
    let root = node.root()
    if (!root.rawCache) root.rawCache = {}
    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect]
    }

    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect)
    } else {
      let method = 'raw' + capitalize(detect)
      if (this[method]) {
        value = this[method](root, node)
      } else {
        root.walk(i => {
          value = i.raws[own]
          if (typeof value !== 'undefined') return false
        })
      }
    }

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]

    root.rawCache[detect] = value
    return value
  }

  rawBeforeClose(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawBeforeComment(root, node) {
    let value
    root.walkComments(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeDecl(root, node) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeOpen(root) {
    let value
    root.walk(i => {
      if (i.type !== 'decl') {
        value = i.raws.between
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawBeforeRule(root) {
    let value
    root.walk(i => {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawColon(root) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '')
        return false
      }
    })
    return value
  }

  rawEmptyBody(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawIndent(root) {
    if (root.raws.indent) return root.raws.indent
    let value
    root.walk(i => {
      let p = i.parent
      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          let parts = i.raws.before.split('\n')
          value = parts[parts.length - 1]
          value = value.replace(/\S/g, '')
          return false
        }
      }
    })
    return value
  }

  rawSemicolon(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawValue(node, prop) {
    let value = node[prop]
    let raw = node.raws[prop]
    if (raw && raw.value === value) {
      return raw.raw
    }

    return value
  }

  root(node) {
    this.body(node)
    if (node.raws.after) this.builder(node.raws.after)
  }

  rule(node) {
    this.block(node, this.rawValue(node, 'selector'))
    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end')
    }
  }

  stringify(node, semicolon) {
    /* c8 ignore start */
    if (!this[node.type]) {
      throw new Error(
        'Unknown AST node type ' +
          node.type +
          '. ' +
          'Maybe you need to change PostCSS stringifier.'
      )
    }
    /* c8 ignore stop */
    this[node.type](node, semicolon)
  }
}

module.exports = Stringifier
Stringifier.default = Stringifier


/***/ }),

/***/ "./node_modules/postcss/lib/stringify.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/stringify.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Stringifier = __webpack_require__(/*! ./stringifier */ "./node_modules/postcss/lib/stringifier.js")

function stringify(node, builder) {
  let str = new Stringifier(builder)
  str.stringify(node)
}

module.exports = stringify
stringify.default = stringify


/***/ }),

/***/ "./node_modules/postcss/lib/symbols.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/symbols.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


module.exports.isClean = Symbol('isClean')

module.exports.my = Symbol('my')


/***/ }),

/***/ "./node_modules/postcss/lib/tokenize.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/tokenize.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


const SINGLE_QUOTE = "'".charCodeAt(0)
const DOUBLE_QUOTE = '"'.charCodeAt(0)
const BACKSLASH = '\\'.charCodeAt(0)
const SLASH = '/'.charCodeAt(0)
const NEWLINE = '\n'.charCodeAt(0)
const SPACE = ' '.charCodeAt(0)
const FEED = '\f'.charCodeAt(0)
const TAB = '\t'.charCodeAt(0)
const CR = '\r'.charCodeAt(0)
const OPEN_SQUARE = '['.charCodeAt(0)
const CLOSE_SQUARE = ']'.charCodeAt(0)
const OPEN_PARENTHESES = '('.charCodeAt(0)
const CLOSE_PARENTHESES = ')'.charCodeAt(0)
const OPEN_CURLY = '{'.charCodeAt(0)
const CLOSE_CURLY = '}'.charCodeAt(0)
const SEMICOLON = ';'.charCodeAt(0)
const ASTERISK = '*'.charCodeAt(0)
const COLON = ':'.charCodeAt(0)
const AT = '@'.charCodeAt(0)

const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g
const RE_BAD_BRACKET = /.[\r\n"'(/\\]/
const RE_HEX_ESCAPE = /[\da-f]/i

module.exports = function tokenizer(input, options = {}) {
  let css = input.css.valueOf()
  let ignore = options.ignoreErrors

  let code, content, escape, next, quote
  let currentToken, escaped, escapePos, n, prev

  let length = css.length
  let pos = 0
  let buffer = []
  let returned = []

  function position() {
    return pos
  }

  function unclosed(what) {
    throw input.error('Unclosed ' + what, pos)
  }

  function endOfFile() {
    return returned.length === 0 && pos >= length
  }

  function nextToken(opts) {
    if (returned.length) return returned.pop()
    if (pos >= length) return

    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false

    code = css.charCodeAt(pos)

    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos
        do {
          next += 1
          code = css.charCodeAt(next)
        } while (
          code === SPACE ||
          code === NEWLINE ||
          code === TAB ||
          code === CR ||
          code === FEED
        )

        currentToken = ['space', css.slice(pos, next)]
        pos = next - 1
        break
      }

      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code)
        currentToken = [controlChar, controlChar, pos]
        break
      }

      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : ''
        n = css.charCodeAt(pos + 1)
        if (
          prev === 'url' &&
          n !== SINGLE_QUOTE &&
          n !== DOUBLE_QUOTE &&
          n !== SPACE &&
          n !== NEWLINE &&
          n !== TAB &&
          n !== FEED &&
          n !== CR
        ) {
          next = pos
          do {
            escaped = false
            next = css.indexOf(')', next + 1)
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos
                break
              } else {
                unclosed('bracket')
              }
            }
            escapePos = next
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1
              escaped = !escaped
            }
          } while (escaped)

          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]

          pos = next
        } else {
          next = css.indexOf(')', pos + 1)
          content = css.slice(pos, next + 1)

          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ['(', '(', pos]
          } else {
            currentToken = ['brackets', content, pos, next]
            pos = next
          }
        }

        break
      }

      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"'
        next = pos
        do {
          escaped = false
          next = css.indexOf(quote, next + 1)
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1
              break
            } else {
              unclosed('string')
            }
          }
          escapePos = next
          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1
            escaped = !escaped
          }
        } while (escaped)

        currentToken = ['string', css.slice(pos, next + 1), pos, next]
        pos = next
        break
      }

      case AT: {
        RE_AT_END.lastIndex = pos + 1
        RE_AT_END.test(css)
        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1
        } else {
          next = RE_AT_END.lastIndex - 2
        }

        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      case BACKSLASH: {
        next = pos
        escape = true
        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1
          escape = !escape
        }
        code = css.charCodeAt(next + 1)
        if (
          escape &&
          code !== SLASH &&
          code !== SPACE &&
          code !== NEWLINE &&
          code !== TAB &&
          code !== CR &&
          code !== FEED
        ) {
          next += 1
          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1
            }
            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1
            }
          }
        }

        currentToken = ['word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      default: {
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf('*/', pos + 2) + 1
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length
            } else {
              unclosed('comment')
            }
          }

          currentToken = ['comment', css.slice(pos, next + 1), pos, next]
          pos = next
        } else {
          RE_WORD_END.lastIndex = pos + 1
          RE_WORD_END.test(css)
          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1
          } else {
            next = RE_WORD_END.lastIndex - 2
          }

          currentToken = ['word', css.slice(pos, next + 1), pos, next]
          buffer.push(currentToken)
          pos = next
        }

        break
      }
    }

    pos++
    return currentToken
  }

  function back(token) {
    returned.push(token)
  }

  return {
    back,
    endOfFile,
    nextToken,
    position
  }
}


/***/ }),

/***/ "./node_modules/postcss/lib/warn-once.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/warn-once.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
/* eslint-disable no-console */


let printed = {}

module.exports = function warnOnce(message) {
  if (printed[message]) return
  printed[message] = true

  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message)
  }
}


/***/ }),

/***/ "./node_modules/postcss/lib/warning.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/warning.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


class Warning {
  constructor(text, opts = {}) {
    this.type = 'warning'
    this.text = text

    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts)
      this.line = range.start.line
      this.column = range.start.column
      this.endLine = range.end.line
      this.endColumn = range.end.column
    }

    for (let opt in opts) this[opt] = opts[opt]
  }

  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message
    }

    if (this.plugin) {
      return this.plugin + ': ' + this.text
    }

    return this.text
  }
}

module.exports = Warning
Warning.default = Warning


/***/ }),

/***/ "./node_modules/sanitize-html/index.js":
/*!*********************************************!*\
  !*** ./node_modules/sanitize-html/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const htmlparser = __webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js");
const escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ "./node_modules/escape-string-regexp/index.js");
const { isPlainObject } = __webpack_require__(/*! is-plain-object */ "./node_modules/sanitize-html/node_modules/is-plain-object/dist/is-plain-object.js");
const deepmerge = __webpack_require__(/*! deepmerge */ "./node_modules/deepmerge/dist/cjs.js");
const parseSrcset = __webpack_require__(/*! parse-srcset */ "./node_modules/parse-srcset/src/parse-srcset.js");
const { parse: postcssParse } = __webpack_require__(/*! postcss */ "./node_modules/postcss/lib/postcss.js");
// Tags that can conceivably represent stand-alone media.
const mediaTags = [
  'img', 'audio', 'video', 'picture', 'svg',
  'object', 'map', 'iframe', 'embed'
];
// Tags that are inherently vulnerable to being used in XSS attacks.
const vulnerableTags = [ 'script', 'style' ];

function each(obj, cb) {
  if (obj) {
    Object.keys(obj).forEach(function (key) {
      cb(obj[key], key);
    });
  }
}

// Avoid false positives with .__proto__, .hasOwnProperty, etc.
function has(obj, key) {
  return ({}).hasOwnProperty.call(obj, key);
}

// Returns those elements of `a` for which `cb(a)` returns truthy
function filter(a, cb) {
  const n = [];
  each(a, function(v) {
    if (cb(v)) {
      n.push(v);
    }
  });
  return n;
}

function isEmptyObject(obj) {
  for (const key in obj) {
    if (has(obj, key)) {
      return false;
    }
  }
  return true;
}

function stringifySrcset(parsedSrcset) {
  return parsedSrcset.map(function(part) {
    if (!part.url) {
      throw new Error('URL missing');
    }

    return (
      part.url +
      (part.w ? ` ${part.w}w` : '') +
      (part.h ? ` ${part.h}h` : '') +
      (part.d ? ` ${part.d}x` : '')
    );
  }).join(', ');
}

module.exports = sanitizeHtml;

// A valid attribute name.
// We use a tolerant definition based on the set of strings defined by
// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state
// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .
// The characters accepted are ones which can be appended to the attribute
// name buffer without triggering a parse error:
//   * unexpected-equals-sign-before-attribute-name
//   * unexpected-null-character
//   * unexpected-character-in-attribute-name
// We exclude the empty string because it's impossible to get to the after
// attribute name state with an empty attribute name buffer.
const VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;

// Ignore the _recursing flag; it's there for recursive
// invocation as a guard against this exploit:
// https://github.com/fb55/htmlparser2/issues/105

function sanitizeHtml(html, options, _recursing) {
  if (html == null) {
    return '';
  }
  if (typeof html === 'number') {
    html = html.toString();
  }

  let result = '';
  // Used for hot swapping the result variable with an empty string in order to "capture" the text written to it.
  let tempResult = '';

  function Frame(tag, attribs) {
    const that = this;
    this.tag = tag;
    this.attribs = attribs || {};
    this.tagPosition = result.length;
    this.text = ''; // Node inner text
    this.mediaChildren = [];

    this.updateParentNodeText = function() {
      if (stack.length) {
        const parentFrame = stack[stack.length - 1];
        parentFrame.text += that.text;
      }
    };

    this.updateParentNodeMediaChildren = function() {
      if (stack.length && mediaTags.includes(this.tag)) {
        const parentFrame = stack[stack.length - 1];
        parentFrame.mediaChildren.push(this.tag);
      }
    };
  }

  options = Object.assign({}, sanitizeHtml.defaults, options);
  options.parser = Object.assign({}, htmlParserDefaults, options.parser);

  const tagAllowed = function (name) {
    return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;
  };

  // vulnerableTags
  vulnerableTags.forEach(function (tag) {
    if (tagAllowed(tag) && !options.allowVulnerableTags) {
      console.warn(`\n\n⚠️ Your \`allowedTags\` option includes, \`${tag}\`, which is inherently\nvulnerable to XSS attacks. Please remove it from \`allowedTags\`.\nOr, to disable this warning, add the \`allowVulnerableTags\` option\nand ensure you are accounting for this risk.\n\n`);
    }
  });

  // Tags that contain something other than HTML, or where discarding
  // the text when the tag is disallowed makes sense for other reasons.
  // If we are not allowing these tags, we should drop their content too.
  // For other tags you would drop the tag but keep its content.
  const nonTextTagsArray = options.nonTextTags || [
    'script',
    'style',
    'textarea',
    'option'
  ];
  let allowedAttributesMap;
  let allowedAttributesGlobMap;
  if (options.allowedAttributes) {
    allowedAttributesMap = {};
    allowedAttributesGlobMap = {};
    each(options.allowedAttributes, function(attributes, tag) {
      allowedAttributesMap[tag] = [];
      const globRegex = [];
      attributes.forEach(function(obj) {
        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {
          globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, '.*'));
        } else {
          allowedAttributesMap[tag].push(obj);
        }
      });
      if (globRegex.length) {
        allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');
      }
    });
  }
  const allowedClassesMap = {};
  const allowedClassesGlobMap = {};
  const allowedClassesRegexMap = {};
  each(options.allowedClasses, function(classes, tag) {
    // Implicitly allows the class attribute
    if (allowedAttributesMap) {
      if (!has(allowedAttributesMap, tag)) {
        allowedAttributesMap[tag] = [];
      }
      allowedAttributesMap[tag].push('class');
    }

    allowedClassesMap[tag] = classes;

    if (Array.isArray(classes)) {
      const globRegex = [];
      allowedClassesMap[tag] = [];
      allowedClassesRegexMap[tag] = [];
      classes.forEach(function(obj) {
        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {
          globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, '.*'));
        } else if (obj instanceof RegExp) {
          allowedClassesRegexMap[tag].push(obj);
        } else {
          allowedClassesMap[tag].push(obj);
        }
      });
      if (globRegex.length) {
        allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');
      }
    }
  });

  const transformTagsMap = {};
  let transformTagsAll;
  each(options.transformTags, function(transform, tag) {
    let transFun;
    if (typeof transform === 'function') {
      transFun = transform;
    } else if (typeof transform === 'string') {
      transFun = sanitizeHtml.simpleTransform(transform);
    }
    if (tag === '*') {
      transformTagsAll = transFun;
    } else {
      transformTagsMap[tag] = transFun;
    }
  });

  let depth;
  let stack;
  let skipMap;
  let transformMap;
  let skipText;
  let skipTextDepth;
  let addedText = false;

  initializeState();

  const parser = new htmlparser.Parser({
    onopentag: function(name, attribs) {
      // If `enforceHtmlBoundary` is `true` and this has found the opening
      // `html` tag, reset the state.
      if (options.enforceHtmlBoundary && name === 'html') {
        initializeState();
      }

      if (skipText) {
        skipTextDepth++;
        return;
      }
      const frame = new Frame(name, attribs);
      stack.push(frame);

      let skip = false;
      const hasText = !!frame.text;
      let transformedTag;
      if (has(transformTagsMap, name)) {
        transformedTag = transformTagsMap[name](name, attribs);

        frame.attribs = attribs = transformedTag.attribs;

        if (transformedTag.text !== undefined) {
          frame.innerText = transformedTag.text;
        }

        if (name !== transformedTag.tagName) {
          frame.name = name = transformedTag.tagName;
          transformMap[depth] = transformedTag.tagName;
        }
      }
      if (transformTagsAll) {
        transformedTag = transformTagsAll(name, attribs);

        frame.attribs = attribs = transformedTag.attribs;
        if (name !== transformedTag.tagName) {
          frame.name = name = transformedTag.tagName;
          transformMap[depth] = transformedTag.tagName;
        }
      }

      if (!tagAllowed(name) || (options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap)) || (options.nestingLimit != null && depth >= options.nestingLimit)) {
        skip = true;
        skipMap[depth] = true;
        if (options.disallowedTagsMode === 'discard' || options.disallowedTagsMode === 'completelyDiscard') {
          if (nonTextTagsArray.indexOf(name) !== -1) {
            skipText = true;
            skipTextDepth = 1;
          }
        }
        skipMap[depth] = true;
      }
      depth++;
      if (skip) {
        if (options.disallowedTagsMode === 'discard' || options.disallowedTagsMode === 'completelyDiscard') {
          // We want the contents but not this tag
          return;
        }
        tempResult = result;
        result = '';
      }
      result += '<' + name;

      if (name === 'script') {
        if (options.allowedScriptHostnames || options.allowedScriptDomains) {
          frame.innerText = '';
        }
      }

      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {
        each(attribs, function(value, a) {
          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
            // This prevents part of an attribute name in the output from being
            // interpreted as the end of an attribute, or end of a tag.
            delete frame.attribs[a];
            return;
          }
          // If the value is empty, check if the attribute is in the allowedEmptyAttributes array.
          // If it is not in the allowedEmptyAttributes array, and it is a known non-boolean attribute, delete it
          // List taken from https://html.spec.whatwg.org/multipage/indices.html#attributes-3
          if (value === '' && (!options.allowedEmptyAttributes.includes(a)) &&
            (options.nonBooleanAttributes.includes(a) || options.nonBooleanAttributes.includes('*'))) {
            delete frame.attribs[a];
            return;
          }
          // check allowedAttributesMap for the element and attribute and modify the value
          // as necessary if there are specific values defined.
          let passedAllowedAttributesMapCheck = false;
          if (!allowedAttributesMap ||
            (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1) ||
            (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1) ||
            (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||
            (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {
            passedAllowedAttributesMapCheck = true;
          } else if (allowedAttributesMap && allowedAttributesMap[name]) {
            for (const o of allowedAttributesMap[name]) {
              if (isPlainObject(o) && o.name && (o.name === a)) {
                passedAllowedAttributesMapCheck = true;
                let newValue = '';
                if (o.multiple === true) {
                  // verify the values that are allowed
                  const splitStrArray = value.split(' ');
                  for (const s of splitStrArray) {
                    if (o.values.indexOf(s) !== -1) {
                      if (newValue === '') {
                        newValue = s;
                      } else {
                        newValue += ' ' + s;
                      }
                    }
                  }
                } else if (o.values.indexOf(value) >= 0) {
                  // verified an allowed value matches the entire attribute value
                  newValue = value;
                }
                value = newValue;
              }
            }
          }
          if (passedAllowedAttributesMapCheck) {
            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
              if (naughtyHref(name, value)) {
                delete frame.attribs[a];
                return;
              }
            }

            if (name === 'script' && a === 'src') {

              let allowed = true;

              try {
                const parsed = parseUrl(value);

                if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                  const allowedHostname = (options.allowedScriptHostnames || []).find(function (hostname) {
                    return hostname === parsed.url.hostname;
                  });
                  const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                  });
                  allowed = allowedHostname || allowedDomain;
                }
              } catch (e) {
                allowed = false;
              }

              if (!allowed) {
                delete frame.attribs[a];
                return;
              }
            }

            if (name === 'iframe' && a === 'src') {
              let allowed = true;
              try {
                const parsed = parseUrl(value);

                if (parsed.isRelativeUrl) {
                  // default value of allowIframeRelativeUrls is true
                  // unless allowedIframeHostnames or allowedIframeDomains specified
                  allowed = has(options, 'allowIframeRelativeUrls')
                    ? options.allowIframeRelativeUrls
                    : (!options.allowedIframeHostnames && !options.allowedIframeDomains);
                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                  const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {
                    return hostname === parsed.url.hostname;
                  });
                  const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                  });
                  allowed = allowedHostname || allowedDomain;
                }
              } catch (e) {
                // Unparseable iframe src
                allowed = false;
              }
              if (!allowed) {
                delete frame.attribs[a];
                return;
              }
            }
            if (a === 'srcset') {
              try {
                let parsed = parseSrcset(value);
                parsed.forEach(function(value) {
                  if (naughtyHref('srcset', value.url)) {
                    value.evil = true;
                  }
                });
                parsed = filter(parsed, function(v) {
                  return !v.evil;
                });
                if (!parsed.length) {
                  delete frame.attribs[a];
                  return;
                } else {
                  value = stringifySrcset(filter(parsed, function(v) {
                    return !v.evil;
                  }));
                  frame.attribs[a] = value;
                }
              } catch (e) {
                // Unparseable srcset
                delete frame.attribs[a];
                return;
              }
            }
            if (a === 'class') {
              const allowedSpecificClasses = allowedClassesMap[name];
              const allowedWildcardClasses = allowedClassesMap['*'];
              const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
              const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
              const allowedWildcardClassesGlob = allowedClassesGlobMap['*'];
              const allowedClassesGlobs = [
                allowedSpecificClassesGlob,
                allowedWildcardClassesGlob
              ]
                .concat(allowedSpecificClassesRegex)
                .filter(function (t) {
                  return t;
                });
              if (allowedSpecificClasses && allowedWildcardClasses) {
                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
              } else {
                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
              }
              if (!value.length) {
                delete frame.attribs[a];
                return;
              }
            }
            if (a === 'style') {
              if (options.parseStyleAttributes) {
                try {
                  const abstractSyntaxTree = postcssParse(name + ' {' + value + '}', { map: false });
                  const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);

                  value = stringifyStyleAttributes(filteredAST);

                  if (value.length === 0) {
                    delete frame.attribs[a];
                    return;
                  }
                } catch (e) {
                  if (typeof window !== 'undefined') {
                    console.warn('Failed to parse "' + name + ' {' + value + '}' + '", If you\'re running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547');
                  }
                  delete frame.attribs[a];
                  return;
                }
              } else if (options.allowedStyles) {
                throw new Error('allowedStyles option cannot be used together with parseStyleAttributes: false.');
              }
            }
            result += ' ' + a;
            if (value && value.length) {
              result += '="' + escapeHtml(value, true) + '"';
            } else if (options.allowedEmptyAttributes.includes(a)) {
              result += '=""';
            }
          } else {
            delete frame.attribs[a];
          }
        });
      }
      if (options.selfClosing.indexOf(name) !== -1) {
        result += ' />';
      } else {
        result += '>';
        if (frame.innerText && !hasText && !options.textFilter) {
          result += escapeHtml(frame.innerText);
          addedText = true;
        }
      }
      if (skip) {
        result = tempResult + escapeHtml(result);
        tempResult = '';
      }
    },
    ontext: function(text) {
      if (skipText) {
        return;
      }
      const lastFrame = stack[stack.length - 1];
      let tag;

      if (lastFrame) {
        tag = lastFrame.tag;
        // If inner text was set by transform function then let's use it
        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;
      }

      if (options.disallowedTagsMode === 'completelyDiscard' && !tagAllowed(tag)) {
        text = '';
      } else if ((options.disallowedTagsMode === 'discard' || options.disallowedTagsMode === 'completelyDiscard') && ((tag === 'script') || (tag === 'style'))) {
        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing
        // script tags is, by definition, game over for XSS protection, so if that's
        // your concern, don't allow them. The same is essentially true for style tags
        // which have their own collection of XSS vectors.
        result += text;
      } else {
        const escaped = escapeHtml(text, false);
        if (options.textFilter && !addedText) {
          result += options.textFilter(escaped, tag);
        } else if (!addedText) {
          result += escaped;
        }
      }
      if (stack.length) {
        const frame = stack[stack.length - 1];
        frame.text += text;
      }
    },
    onclosetag: function(name, isImplied) {

      if (skipText) {
        skipTextDepth--;
        if (!skipTextDepth) {
          skipText = false;
        } else {
          return;
        }
      }

      const frame = stack.pop();
      if (!frame) {
        // Do not crash on bad markup
        return;
      }

      if (frame.tag !== name) {
        // Another case of bad markup.
        // Push to stack, so that it will be used in future closing tags.
        stack.push(frame);
        return;
      }

      skipText = options.enforceHtmlBoundary ? name === 'html' : false;
      depth--;
      const skip = skipMap[depth];
      if (skip) {
        delete skipMap[depth];
        if (options.disallowedTagsMode === 'discard' || options.disallowedTagsMode === 'completelyDiscard') {
          frame.updateParentNodeText();
          return;
        }
        tempResult = result;
        result = '';
      }

      if (transformMap[depth]) {
        name = transformMap[depth];
        delete transformMap[depth];
      }

      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
        result = result.substr(0, frame.tagPosition);
        return;
      }

      frame.updateParentNodeMediaChildren();
      frame.updateParentNodeText();

      if (
        // Already output />
        options.selfClosing.indexOf(name) !== -1 ||
        // Escaped tag, closing tag is implied
        (isImplied && !tagAllowed(name) && [ 'escape', 'recursiveEscape' ].indexOf(options.disallowedTagsMode) >= 0)
      ) {
        if (skip) {
          result = tempResult;
          tempResult = '';
        }
        return;
      }

      result += '</' + name + '>';
      if (skip) {
        result = tempResult + escapeHtml(result);
        tempResult = '';
      }
      addedText = false;
    }
  }, options.parser);
  parser.write(html);
  parser.end();

  return result;

  function initializeState() {
    result = '';
    depth = 0;
    stack = [];
    skipMap = {};
    transformMap = {};
    skipText = false;
    skipTextDepth = 0;
  }

  function escapeHtml(s, quote) {
    if (typeof (s) !== 'string') {
      s = s + '';
    }
    if (options.parser.decodeEntities) {
      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      if (quote) {
        s = s.replace(/"/g, '&quot;');
      }
    }
    // TODO: this is inadequate because it will pass `&0;`. This approach
    // will not work, each & must be considered with regard to whether it
    // is followed by a 100% syntactically valid entity or not, and escaped
    // if it is not. If this bothers you, don't set parser.decodeEntities
    // to false. (The default is true.)
    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (quote) {
      s = s.replace(/"/g, '&quot;');
    }
    return s;
  }

  function naughtyHref(name, href) {
    // Browsers ignore character codes of 32 (space) and below in a surprising
    // number of situations. Start reading here:
    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab
    // eslint-disable-next-line no-control-regex
    href = href.replace(/[\x00-\x20]+/g, '');
    // Clobber any comments in URLs, which the browser might
    // interpret inside an XML data island, allowing
    // a javascript: URL to be snuck through
    while (true) {
      const firstIndex = href.indexOf('<!--');
      if (firstIndex === -1) {
        break;
      }
      const lastIndex = href.indexOf('-->', firstIndex + 4);
      if (lastIndex === -1) {
        break;
      }
      href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
    }
    // Case insensitive so we don't get faked out by JAVASCRIPT #1
    // Allow more characters after the first so we don't get faked
    // out by certain schemes browsers accept
    const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
    if (!matches) {
      // Protocol-relative URL starting with any combination of '/' and '\'
      if (href.match(/^[/\\]{2}/)) {
        return !options.allowProtocolRelative;
      }

      // No scheme
      return false;
    }
    const scheme = matches[1].toLowerCase();

    if (has(options.allowedSchemesByTag, name)) {
      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
    }

    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
  }

  function parseUrl(value) {
    value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, '$1//');
    if (value.startsWith('relative:')) {
      // An attempt to exploit our workaround for base URLs being
      // mandatory for relative URL validation in the WHATWG
      // URL parser, reject it
      throw new Error('relative: exploit attempt');
    }
    // naughtyHref is in charge of whether protocol relative URLs
    // are cool. Here we are concerned just with allowed hostnames and
    // whether to allow relative URLs.
    //
    // Build a placeholder "base URL" against which any reasonable
    // relative URL may be parsed successfully
    let base = 'relative://relative-site';
    for (let i = 0; (i < 100); i++) {
      base += `/${i}`;
    }

    const parsed = new URL(value, base);

    const isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';
    return {
      isRelativeUrl,
      url: parsed
    };
  }
  /**
   * Filters user input css properties by allowlisted regex attributes.
   * Modifies the abstractSyntaxTree object.
   *
   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.
   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.
   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).
   * @return {object}                    - The modified tree.
   */
  function filterCss(abstractSyntaxTree, allowedStyles) {
    if (!allowedStyles) {
      return abstractSyntaxTree;
    }

    const astRules = abstractSyntaxTree.nodes[0];
    let selectedRule;

    // Merge global and tag-specific styles into new AST.
    if (allowedStyles[astRules.selector] && allowedStyles['*']) {
      selectedRule = deepmerge(
        allowedStyles[astRules.selector],
        allowedStyles['*']
      );
    } else {
      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];
    }

    if (selectedRule) {
      abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
    }

    return abstractSyntaxTree;
  }

  /**
   * Extracts the style attributes from an AbstractSyntaxTree and formats those
   * values in the inline style attribute format.
   *
   * @param  {AbstractSyntaxTree} filteredAST
   * @return {string}             - Example: "color:yellow;text-align:center !important;font-family:helvetica;"
   */
  function stringifyStyleAttributes(filteredAST) {
    return filteredAST.nodes[0].nodes
      .reduce(function(extractedAttributes, attrObject) {
        extractedAttributes.push(
          `${attrObject.prop}:${attrObject.value}${attrObject.important ? ' !important' : ''}`
        );
        return extractedAttributes;
      }, [])
      .join(';');
  }

  /**
    * Filters the existing attributes for the given property. Discards any attributes
    * which don't match the allowlist.
    *
    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }
    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.
    * @param  {object} attributeObject          - Object representing the current css property.
    * @property {string} attributeObject.type   - Typically 'declaration'.
    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.
    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.
    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects
    */
  function filterDeclarations(selectedRule) {
    return function (allowedDeclarationsList, attributeObject) {
      // If this property is allowlisted...
      if (has(selectedRule, attributeObject.prop)) {
        const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
          return regularExpression.test(attributeObject.value);
        });

        if (matchesRegex) {
          allowedDeclarationsList.push(attributeObject);
        }
      }
      return allowedDeclarationsList;
    };
  }

  function filterClasses(classes, allowed, allowedGlobs) {
    if (!allowed) {
      // The class attribute is allowed without filtering on this tag
      return classes;
    }
    classes = classes.split(/\s+/);
    return classes.filter(function(clss) {
      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
        return glob.test(clss);
      });
    }).join(' ');
  }
}

// Defaults are accessible to you so that you can use them as a starting point
// programmatically if you wish

const htmlParserDefaults = {
  decodeEntities: true
};
sanitizeHtml.defaults = {
  allowedTags: [
    // Sections derived from MDN element categories and limited to the more
    // benign categories.
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
    // Content sectioning
    'address', 'article', 'aside', 'footer', 'header',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup',
    'main', 'nav', 'section',
    // Text content
    'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure',
    'hr', 'li', 'main', 'ol', 'p', 'pre', 'ul',
    // Inline text semantics
    'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn',
    'em', 'i', 'kbd', 'mark', 'q',
    'rb', 'rp', 'rt', 'rtc', 'ruby',
    's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr',
    // Table content
    'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th',
    'thead', 'tr'
  ],
  // Tags that cannot be boolean
  nonBooleanAttributes: [
    'abbr', 'accept', 'accept-charset', 'accesskey', 'action',
    'allow', 'alt', 'as', 'autocapitalize', 'autocomplete',
    'blocking', 'charset', 'cite', 'class', 'color', 'cols',
    'colspan', 'content', 'contenteditable', 'coords', 'crossorigin',
    'data', 'datetime', 'decoding', 'dir', 'dirname', 'download',
    'draggable', 'enctype', 'enterkeyhint', 'fetchpriority', 'for',
    'form', 'formaction', 'formenctype', 'formmethod', 'formtarget',
    'headers', 'height', 'hidden', 'high', 'href', 'hreflang',
    'http-equiv', 'id', 'imagesizes', 'imagesrcset', 'inputmode',
    'integrity', 'is', 'itemid', 'itemprop', 'itemref', 'itemtype',
    'kind', 'label', 'lang', 'list', 'loading', 'low', 'max',
    'maxlength', 'media', 'method', 'min', 'minlength', 'name',
    'nonce', 'optimum', 'pattern', 'ping', 'placeholder', 'popover',
    'popovertarget', 'popovertargetaction', 'poster', 'preload',
    'referrerpolicy', 'rel', 'rows', 'rowspan', 'sandbox', 'scope',
    'shape', 'size', 'sizes', 'slot', 'span', 'spellcheck', 'src',
    'srcdoc', 'srclang', 'srcset', 'start', 'step', 'style',
    'tabindex', 'target', 'title', 'translate', 'type', 'usemap',
    'value', 'width', 'wrap',
    // Event handlers
    'onauxclick', 'onafterprint', 'onbeforematch', 'onbeforeprint',
    'onbeforeunload', 'onbeforetoggle', 'onblur', 'oncancel',
    'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose',
    'oncontextlost', 'oncontextmenu', 'oncontextrestored', 'oncopy',
    'oncuechange', 'oncut', 'ondblclick', 'ondrag', 'ondragend',
    'ondragenter', 'ondragleave', 'ondragover', 'ondragstart',
    'ondrop', 'ondurationchange', 'onemptied', 'onended',
    'onerror', 'onfocus', 'onformdata', 'onhashchange', 'oninput',
    'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup',
    'onlanguagechange', 'onload', 'onloadeddata', 'onloadedmetadata',
    'onloadstart', 'onmessage', 'onmessageerror', 'onmousedown',
    'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout',
    'onmouseover', 'onmouseup', 'onoffline', 'ononline', 'onpagehide',
    'onpageshow', 'onpaste', 'onpause', 'onplay', 'onplaying',
    'onpopstate', 'onprogress', 'onratechange', 'onreset', 'onresize',
    'onrejectionhandled', 'onscroll', 'onscrollend',
    'onsecuritypolicyviolation', 'onseeked', 'onseeking', 'onselect',
    'onslotchange', 'onstalled', 'onstorage', 'onsubmit', 'onsuspend',
    'ontimeupdate', 'ontoggle', 'onunhandledrejection', 'onunload',
    'onvolumechange', 'onwaiting', 'onwheel'
  ],
  disallowedTagsMode: 'discard',
  allowedAttributes: {
    a: [ 'href', 'name', 'target' ],
    // We don't currently allow img itself by default, but
    // these attributes would make sense if we did.
    img: [ 'src', 'srcset', 'alt', 'title', 'width', 'height', 'loading' ]
  },
  allowedEmptyAttributes: [
    'alt'
  ],
  // Lots of these won't come up by default because we don't allow them
  selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],
  // URL schemes we permit
  allowedSchemes: [ 'http', 'https', 'ftp', 'mailto', 'tel' ],
  allowedSchemesByTag: {},
  allowedSchemesAppliedToAttributes: [ 'href', 'src', 'cite' ],
  allowProtocolRelative: true,
  enforceHtmlBoundary: false,
  parseStyleAttributes: true
};

sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {
  merge = (merge === undefined) ? true : merge;
  newAttribs = newAttribs || {};

  return function(tagName, attribs) {
    let attrib;
    if (merge) {
      for (attrib in newAttribs) {
        attribs[attrib] = newAttribs[attrib];
      }
    } else {
      attribs = newAttribs;
    }

    return {
      tagName: newTagName,
      attribs: attribs
    };
  };
};


/***/ }),

/***/ "./node_modules/sanitize-html/node_modules/is-plain-object/dist/is-plain-object.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sanitize-html/node_modules/is-plain-object/dist/is-plain-object.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}

exports.isPlainObject = isPlainObject;


/***/ }),

/***/ "./websrc/badel.js":
/*!*************************!*\
  !*** ./websrc/badel.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ne: () => (/* binding */ ne)
/* harmony export */ });
/* harmony import */ var sanitize_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sanitize-html */ "./node_modules/sanitize-html/index.js");
/* harmony import */ var sanitize_html__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sanitize_html__WEBPACK_IMPORTED_MODULE_0__);


/**
 * @description Function used to convert HTML strings into HTML elements at runtime.
 * @param {String} elementText 
 * @param {boolean} sanitize 
 * @returns 
 */
function ne(elementText, sanitize = true){
    // let elementType = /[\s\S]*?<(.*?)>/.exec(elementText)[1]
    // if(elementType.includes(" ")==true)elementType = elementType.substring(0, elementType.indexOf(" "))
    // let e = document.createElement(elementType)
    let e = document.createElement("div")
    e.style.all = "unset"
    e.innerHTML = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()(elementText)
    return e
}


/***/ }),

/***/ "./websrc/quiz.js":
/*!************************!*\
  !*** ./websrc/quiz.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Page: () => (/* binding */ Page)
/* harmony export */ });
/* harmony import */ var _badel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./badel.js */ "./websrc/badel.js");




function Page(){
    

    return (0,_badel_js__WEBPACK_IMPORTED_MODULE_0__.ne)(`
        <h1 style="color: green">Hello ${1+1}</h1>
    `)
}


/***/ }),

/***/ "?5580":
/*!**************************************!*\
  !*** ./terminal-highlight (ignored) ***!
  \**************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?03fb":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?6197":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b8cb":
/*!*******************************!*\
  !*** source-map-js (ignored) ***!
  \*******************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c717":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/nanoid/non-secure/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/nanoid/non-secure/index.cjs ***!
  \**************************************************/
/***/ ((module) => {

let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = ''
    let i = size
    while (i--) {
      id += alphabet[(Math.random() * alphabet.length) | 0]
    }
    return id
  }
}
let nanoid = (size = 21) => {
  let id = ''
  let i = size
  while (i--) {
    id += urlAlphabet[(Math.random() * 64) | 0]
  }
  return id
}
module.exports = { nanoid, customAlphabet }


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*************************!*\
  !*** ./websrc/entry.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _badel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./badel.js */ "./websrc/badel.js");
/* harmony import */ var _quiz_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quiz.js */ "./websrc/quiz.js");




const pages = {
    "/quiz.html": _quiz_js__WEBPACK_IMPORTED_MODULE_1__.Page
}

if(pages[window.location.pathname]){
    let pageHTML = pages[window.location.pathname]();

    document.getElementById("page").replaceChildren(pageHTML)
}else{
    console.log("No page found!");
}
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQyxvQkFBb0IsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQyxvQkFBb0IsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnRUFBZ0U7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7Ozs7Ozs7Ozs7O0FDdmhCYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmOzs7Ozs7Ozs7OztBQzNFYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLGtCQUFrQjtBQUMvQyx1Q0FBdUMsbUJBQU8sQ0FBQyx3RkFBNEI7QUFDM0Usa0JBQWtCLG1CQUFPLENBQUMsMERBQWE7QUFDdkMsdUNBQXVDLEVBQUU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1RWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQjtBQUNuSixtQkFBbUI7QUFDbkI7QUFDQSxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SEFBd0g7QUFDeEg7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjLHlFQUF5RTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5RUFBeUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLGlCQUFpQjtBQUNqQjtBQUNBOzs7Ozs7Ozs7OztBQ3pIYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2Y7QUFDQSxzY0FBc2MsZ0JBQWdCLG1CQUFtQixRQUFRLDBDQUEwQyxVQUFVLFFBQVEseUJBQXlCLFFBQVEsOEJBQThCLDJDQUEyQyxzQkFBc0IsMkhBQTJILHFCQUFxQixTQUFTLFFBQVEsc0NBQXNDLGNBQWMsUUFBUSxRQUFRLHFCQUFxQixzQkFBc0Isc0JBQXNCLGlIQUFpSCx1REFBdUQsYUFBYSxvQ0FBb0MsV0FBVyw0Q0FBNEMsNEJBQTRCLFdBQVcsU0FBUywrQkFBK0IsYUFBYSxrQkFBa0IsK0NBQStDLFdBQVcsVUFBVSxXQUFXLGdEQUFnRCwyQ0FBMkMsV0FBVyxpREFBaUQsb0JBQW9CLHVDQUF1QyxTQUFTLGtCQUFrQiwyQkFBMkIsWUFBWSxtQ0FBbUMsVUFBVSxTQUFTLDBCQUEwQixzQkFBc0IsZ0dBQWdHLG1CQUFtQixTQUFTLFNBQVMsU0FBUyxxQ0FBcUMsUUFBUSxTQUFTLDhCQUE4QixPQUFPLGNBQWMscUJBQXFCLFFBQVEsd0dBQXdHLDBCQUEwQixlQUFlLFdBQVcsV0FBVyxVQUFVLGlCQUFpQiw4Q0FBOEMseUJBQXlCLDZCQUE2QixXQUFXLHdIQUF3SCw0REFBNEQsZ0JBQWdCLG1FQUFtRSxnQkFBZ0IsZ0JBQWdCLG1DQUFtQyxTQUFTLGtDQUFrQyxlQUFlLGlCQUFpQixrRUFBa0UsNkJBQTZCLGFBQWEsV0FBVyxnREFBZ0QsZUFBZSxrQkFBa0Isc0JBQXNCLHVDQUF1QyxrQkFBa0Isc0JBQXNCLGVBQWUsd0JBQXdCLDRCQUE0QixzQkFBc0IsOEhBQThILDBFQUEwRSx5QkFBeUIsU0FBUyxRQUFRLDRDQUE0Qyw2QkFBNkIseUNBQXlDLHFCQUFxQiw2QkFBNkIsUUFBUSx3QkFBd0IsbUNBQW1DLHdCQUF3QixjQUFjLDRCQUE0QixRQUFRLFFBQVEsZ0RBQWdELGdCQUFnQixpREFBaUQsUUFBUSx1REFBdUQscUJBQXFCLHNDQUFzQyxzQkFBc0IsY0FBYyw4R0FBOEcsNkJBQTZCLG9CQUFvQixXQUFXLHFDQUFxQyxTQUFTLE9BQU8sU0FBUyxRQUFRLG1CQUFtQixTQUFTLGtGQUFrRix1QkFBdUIsZUFBZSxhQUFhLFVBQVUsZ0JBQWdCLFdBQVcsU0FBUyxtQkFBbUIseUVBQXlFLDZCQUE2QixPQUFPLFVBQVUsUUFBUSxpQkFBaUIsNEJBQTRCLGtCQUFrQix3Q0FBd0MsK0NBQStDLGlIQUFpSCxVQUFVLFNBQVMsaUVBQWlFLFNBQVMsUUFBUSxpQ0FBaUMsMENBQTBDLGFBQWEsOENBQThDLDJDQUEyQyxjQUFjLHFDQUFxQyxXQUFXLG9DQUFvQyxRQUFRLG9CQUFvQixTQUFTLFdBQVcsNkJBQTZCLHVGQUF1RixPQUFPLFFBQVEscUJBQXFCLHdDQUF3QyxzQkFBc0IsVUFBVSxnRUFBZ0UsU0FBUyxVQUFVLDhCQUE4QixPQUFPLFFBQVEscUJBQXFCLHFCQUFxQix3R0FBd0csZ0VBQWdFLFVBQVUsUUFBUSxjQUFjLFFBQVEscUNBQXFDLFVBQVUsT0FBTyxzSUFBc0ksZ0JBQWdCLDZCQUE2QixnQkFBZ0IsYUFBYSxzQ0FBc0Msb0NBQW9DLGtCQUFrQixzQkFBc0IsV0FBVyxtQ0FBbUMsWUFBWSxrQ0FBa0MsK0JBQStCLFlBQVksbUJBQW1CLDZCQUE2QixXQUFXLDRDQUE0QyxlQUFlLGtCQUFrQixzQkFBc0Isa0JBQWtCLHNCQUFzQixpRkFBaUYsZUFBZSxhQUFhLFVBQVUsZ0JBQWdCLFdBQVcsUUFBUSx5QkFBeUIsMkJBQTJCLFdBQVcsZ0dBQWdHLGdCQUFnQixnQkFBZ0IsMkRBQTJELGlEQUFpRCxnQkFBZ0IsNENBQTRDLFVBQVUsT0FBTyxzRUFBc0UsUUFBUSxtQ0FBbUMsYUFBYSxRQUFRLDBCQUEwQixTQUFTLDhCQUE4Qiw4RUFBOEUsV0FBVyxxQ0FBcUMsVUFBVSxPQUFPLDRFQUE0RSx3SEFBd0gsUUFBUSx5REFBeUQsb0JBQW9CLFFBQVEsYUFBYSw0SEFBNEgsV0FBVyx1QkFBdUIsdUNBQXVDLGdCQUFnQix3QkFBd0IsdUJBQXVCLG1CQUFtQiwyREFBMkQsZUFBZSx5QkFBeUIsc0JBQXNCLGdCQUFnQix1QkFBdUIsbUNBQW1DLHVCQUF1Qix1REFBdUQsNkJBQTZCLHVCQUF1QixjQUFjLG9EQUFvRCxhQUFhLFVBQVUsNEJBQTRCLHVCQUF1Qiw2Q0FBNkMsMEJBQTBCLGdDQUFnQywrQkFBK0IsNEJBQTRCLHVDQUF1Qyx3QkFBd0IsNkJBQTZCLHVCQUF1Qiw4REFBOEQsb0NBQW9DLGtCQUFrQixvQ0FBb0MsMkNBQTJDLG9DQUFvQyxrQkFBa0Isc0NBQXNDLDRCQUE0QixXQUFXLDhCQUE4QixvQ0FBb0MsaUJBQWlCLHNDQUFzQyxlQUFlLFdBQVcsaUJBQWlCLFNBQVMsdUNBQXVDLGtIQUFrSCxpRUFBaUUsV0FBVyxRQUFRLG9FQUFvRSxTQUFTLFdBQVcsU0FBUyx3REFBd0QsV0FBVyxPQUFPLDRCQUE0Qiw2RUFBNkUsb0VBQW9FLDZCQUE2QixTQUFTLGlCQUFpQixrRkFBa0YsUUFBUSxRQUFRLG9CQUFvQixPQUFPLGNBQWMsK0NBQStDLGFBQWEsNkNBQTZDLHNDQUFzQyxnQkFBZ0IsV0FBVyxTQUFTLDhCQUE4QixtQkFBbUIsZUFBZSw0QkFBNEIsbUJBQW1CLDBEQUEwRCxxQkFBcUIsU0FBUyxnSEFBZ0gsc0RBQXNELFFBQVEsY0FBYyxxQkFBcUIscUNBQXFDLFVBQVUsT0FBTyxhQUFhLHFFQUFxRSxnQkFBZ0IsbUJBQW1CLG1CQUFtQixzR0FBc0csZ0JBQWdCLDZCQUE2QixlQUFlLGFBQWEsc0NBQXNDLG9DQUFvQyxrQkFBa0Isc0JBQXNCLFdBQVcsa0NBQWtDLCtCQUErQixZQUFZLG1CQUFtQiw2QkFBNkIsV0FBVyw0Q0FBNEMsZUFBZSxrQkFBa0Isc0JBQXNCLGtCQUFrQixzQkFBc0IsNEJBQTRCLGdCQUFnQixnQkFBZ0IsNEJBQTRCLE9BQU8sZ0JBQWdCLCtIQUErSCxRQUFRLFdBQVcsV0FBVyxhQUFhLDRDQUE0QyxVQUFVLFNBQVMsT0FBTyxRQUFRLHFIQUFxSCxVQUFVLGdCQUFnQixTQUFTLDBDQUEwQyxnQkFBZ0IsNkNBQTZDLHFDQUFxQyx3QkFBd0Isa0JBQWtCLHdCQUF3QixXQUFXLFNBQVMscUJBQXFCLCtDQUErQyw0QkFBNEIsa0JBQWtCLHFDQUFxQyxzQ0FBc0MsZ0JBQWdCLFdBQVcsbUJBQW1CLGFBQWEscUNBQXFDLHdCQUF3Qiw0SEFBNEgsNkJBQTZCLFFBQVEsMkJBQTJCLE9BQU8scUNBQXFDLFVBQVUsT0FBTyxRQUFRLGdFQUFnRSxRQUFRLGlDQUFpQyx3QkFBd0IsZ0JBQWdCLHNDQUFzQyxlQUFlLFdBQVcsU0FBUywwQkFBMEIsNEJBQTRCLHNCQUFzQiw2SkFBNkosdUJBQXVCLDZCQUE2QixTQUFTLDZDQUE2QyxXQUFXLFFBQVEsMENBQTBDLHNFQUFzRSw2QkFBNkIsU0FBUyxpQkFBaUIsZUFBZSx1QkFBdUIsNkJBQTZCLFFBQVEsMkZBQTJGLHVCQUF1QixlQUFlLGVBQWUsaUJBQWlCLGVBQWUsd0JBQXdCLGtEQUFrRCxnQkFBZ0IsY0FBYyxzQkFBc0IsVUFBVSxTQUFTLHVCQUF1QixpR0FBaUcsU0FBUyxRQUFRLGdCQUFnQixvQkFBb0IsMkJBQTJCLG9DQUFvQyxhQUFhLHFEQUFxRCxVQUFVLGVBQWUsV0FBVyxnQkFBZ0IsUUFBUSxxQkFBcUIscUJBQXFCLHVCQUF1QixtREFBbUQsVUFBVSxRQUFRLHFCQUFxQixxQkFBcUIsc0RBQXNELG1CQUFtQixTQUFTLHFCQUFxQiwwRkFBMEYsU0FBUyxTQUFTLGlEQUFpRCxPQUFPLFFBQVEscUJBQXFCLHFCQUFxQixxQkFBcUIsdUVBQXVFLFdBQVcsOEJBQThCLE9BQU8sU0FBUywyQ0FBMkMsUUFBUSxTQUFTLFNBQVMsK0pBQStKLGFBQWEsZ0RBQWdELG1CQUFtQiwyQ0FBMkMsZ0NBQWdDLFlBQVksa0ZBQWtGLG1CQUFtQiwyQ0FBMkMsUUFBUSxtQ0FBbUMsMkNBQTJDLE9BQU8sV0FBVyxPQUFPLGFBQWEsdURBQXVELDBCQUEwQiwwRUFBMEUsT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxjQUFjLDJCQUEyQixvQkFBb0IsNEJBQTRCLGtCQUFrQiw2QkFBNkIsUUFBUSx5QkFBeUIsaURBQWlELFVBQVUsT0FBTyxRQUFRLFFBQVEsZ0JBQWdCLHVFQUF1RSxtQkFBbUIsZUFBZSxrR0FBa0csK0hBQStILGlFQUFpRSxhQUFhLFdBQVcsZUFBZSxxQkFBcUIsMkJBQTJCLGVBQWUsdUNBQXVDLGlCQUFpQiwyQkFBMkIsVUFBVSx5REFBeUQsa0JBQWtCLHlEQUF5RCxPQUFPLFVBQVUsUUFBUSxrSEFBa0gsK0NBQStDLFVBQVUsV0FBVyxnQ0FBZ0MsU0FBUyxxQ0FBcUMsUUFBUSxXQUFXLGdDQUFnQyx3RkFBd0Ysb0JBQW9CLHFDQUFxQyxVQUFVLFdBQVcsUUFBUSwrQ0FBK0MsT0FBTyxRQUFRLFNBQVMsaUNBQWlDLDhCQUE4QixvQkFBb0IsMENBQTBDLHlCQUF5Qiw2QkFBNkIsbUlBQW1JLE9BQU8sT0FBTyxPQUFPLGFBQWEseUNBQXlDLE9BQU8sT0FBTyxPQUFPLHlDQUF5QyxPQUFPLE9BQU8sT0FBTyxhQUFhLHVEQUF1RCxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sU0FBUyx5Q0FBeUMsT0FBTyxPQUFPLE9BQU8sYUFBYSxtQ0FBbUMsT0FBTyxPQUFPLE9BQU8sV0FBVyxVQUFVLFdBQVcseUNBQXlDLE9BQU8sT0FBTyxPQUFPLGFBQWEsdURBQXVELE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxpRkFBaUYscUJBQXFCLGNBQWMscUJBQXFCLDJCQUEyQixVQUFVLGdDQUFnQyxzQ0FBc0MscUJBQXFCLGFBQWEsZ0tBQWdLLGFBQWEsa0RBQWtELFdBQVcsNEJBQTRCLFFBQVEsU0FBUyxPQUFPLHdDQUF3Qyx3RUFBd0UsU0FBUyw0QkFBNEIsZUFBZSxxQkFBcUIsU0FBUyx3REFBd0Qsa0JBQWtCLGdDQUFnQywrQ0FBK0MsZUFBZSxpQ0FBaUMsY0FBYyx1REFBdUQsYUFBYSw0QkFBNEIseURBQXlELFdBQVcsMERBQTBELFNBQVMsVUFBVSxVQUFVLFdBQVcsU0FBUyxVQUFVLGdCQUFnQix3RUFBd0UsMEJBQTBCLHVDQUF1QyxvQkFBb0IsYUFBYSw0R0FBNEcsZ0JBQWdCLDZDQUE2Qyx3Q0FBd0MsZUFBZSw2QkFBNkIsU0FBUyw0QkFBNEIsNkNBQTZDLG9CQUFvQixhQUFhLG9CQUFvQixVQUFVLHFGQUFxRixPQUFPLDhCQUE4QixRQUFRLGdCQUFnQixvQkFBb0IsYUFBYSxvREFBb0QsNEJBQTRCLFFBQVEsU0FBUyxRQUFRLE9BQU8sNkRBQTZELG9CQUFvQixtRkFBbUYsV0FBVyw2SEFBNkgsV0FBVywrSkFBK0osNENBQTRDLFVBQVUsd0JBQXdCLG9EQUFvRCx5Q0FBeUMsT0FBTyxhQUFhLDBDQUEwQyxXQUFXLG9EQUFvRCxXQUFXLDhCQUE4QixPQUFPLDZHQUE2Ryw2QkFBNkIsaUJBQWlCLFdBQVcsU0FBUyxhQUFhLHVDQUF1QyxvQkFBb0Isb0JBQW9CLGdDQUFnQyxTQUFTLG1EQUFtRCxRQUFRLHlCQUF5QiwwQ0FBMEMsZ0JBQWdCLFdBQVcsVUFBVSxZQUFZLGtMQUFrTCxTQUFTLHNEQUFzRCxtQkFBbUIsUUFBUSxVQUFVLDZCQUE2QixjQUFjLG1FQUFtRSw0QkFBNEIsWUFBWSxvTkFBb04sNENBQTRDLGNBQWMsdUNBQXVDLE9BQU8sU0FBUyw2QkFBNkIsT0FBTyx5QkFBeUIsb0RBQW9ELHNCQUFzQixhQUFhLHVDQUF1QyxPQUFPLGFBQWEsc0JBQXNCLG9DQUFvQyxlQUFlLCtDQUErQywrQkFBK0IsT0FBTyxpQ0FBaUMsUUFBUSw2QkFBNkIsUUFBUSxxREFBcUQscUJBQXFCLFNBQVMsY0FBYyx1Q0FBdUMsc0xBQXNMLFNBQVMsY0FBYyxlQUFlLFlBQVksNkJBQTZCLFNBQVMsbUNBQW1DLHNDQUFzQyw2REFBNkQsbUNBQW1DLHdMQUF3TCxXQUFXLHFDQUFxQyxvQ0FBb0MsZUFBZSxhQUFhLHNCQUFzQixnQkFBZ0IscUNBQXFDLFNBQVMsZUFBZSxTQUFTLDRCQUE0Qiw2Q0FBNkMsb0JBQW9CLGFBQWEsdUpBQXVKLHVCQUF1QixPQUFPLE9BQU8sMkJBQTJCLE9BQU8sbURBQW1ELE9BQU8sUUFBUSwyQkFBMkIsT0FBTyxRQUFRLFFBQVEsU0FBUyxTQUFTLHNKQUFzSixjQUFjLHFDQUFxQyxlQUFlLG9CQUFvQixXQUFXLDZCQUE2QixPQUFPLFNBQVMsYUFBYSxrQ0FBa0Msd0NBQXdDLDZCQUE2QixlQUFlLDBCQUEwQixvQkFBb0IsYUFBYSxpQ0FBaUMsUUFBUSx5QkFBeUIsaUJBQWlCLFNBQVMsYUFBYSw0QkFBNEIsT0FBTyxPQUFPLHlDQUF5QyxjQUFjLHVDQUF1QywwQkFBMEIsZ0JBQWdCLFNBQVMsd0NBQXdDLGNBQWMscUJBQXFCLE9BQU8sY0FBYyw4REFBOEQsUUFBUSxTQUFTLFVBQVUsV0FBVyxrRkFBa0YsOEVBQThFLCtNQUErTSxhQUFhLHVCQUF1QixPQUFPLFNBQVMsVUFBVSwyQ0FBMkMsbUNBQW1DLFVBQVUsUUFBUSw0Q0FBNEMsV0FBVyxrREFBa0QsVUFBVSxvQ0FBb0MsZ0JBQWdCLFFBQVEsc0JBQXNCLG1DQUFtQyxrQ0FBa0MsOEJBQThCLDBKQUEwSix1Q0FBdUMsNEJBQTRCLDZDQUE2Qyw2Q0FBNkMsa0RBQWtELFFBQVEsVUFBVSxTQUFTLFVBQVUsOERBQThELDJEQUEyRCxRQUFRLFNBQVMsYUFBYSxzQ0FBc0MsZUFBZSxzQkFBc0IseUJBQXlCLHFDQUFxQyxxREFBcUQsVUFBVSwwQ0FBMEMsU0FBUyxRQUFRLG9CQUFvQixnREFBZ0QsMEJBQTBCLG1DQUFtQyxTQUFTLGFBQWEsb0JBQW9CLGFBQWEsaUJBQWlCLDZCQUE2Qiw4RkFBOEYsT0FBTyxRQUFRLHNCQUFzQixTQUFTLHdDQUF3QyxzQkFBc0IsVUFBVSw4RUFBOEUsb0JBQW9CLDhCQUE4QixPQUFPLFFBQVEsdUJBQXVCLFNBQVMsU0FBUyxTQUFTLHFCQUFxQiw2T0FBNk8sVUFBVSxhQUFhLGNBQWMsU0FBUyx3RkFBd0YsWUFBWSxzQkFBc0IsY0FBYyxxQkFBcUIsaUJBQWlCLGdDQUFnQyw4REFBOEQsZUFBZSxRQUFRLGtCQUFrQixRQUFRLFNBQVMsUUFBUSxhQUFhLDZCQUE2QixhQUFhLG9CQUFvQixnREFBZ0QsU0FBUyxnREFBZ0QsT0FBTywyQkFBMkIsNEJBQTRCLE9BQU8sNENBQTRDLDZCQUE2QiwyQkFBMkIsMENBQTBDLGVBQWUscUNBQXFDLFdBQVcsUUFBUSxhQUFhLDZGQUE2RixvRkFBb0YsZ0RBQWdELHlEQUF5RCxhQUFhLHdDQUF3QyxvQ0FBb0MsZUFBZSwwQkFBMEIsb0JBQW9CLGFBQWEsaUNBQWlDLGdFQUFnRSxxR0FBcUcsT0FBTyx5QkFBeUIsY0FBYyxvREFBb0QsY0FBYyxTQUFTLFNBQVMsYUFBYSwrREFBK0QsU0FBUyw4QkFBOEIsZ0JBQWdCLG1FQUFtRSxjQUFjLHVDQUF1QywwQkFBMEIsZ0JBQWdCLDBGQUEwRixRQUFRLHdGQUF3RiwrREFBK0QsbUNBQW1DLE9BQU8scUJBQXFCLFdBQVcsMkJBQTJCLHVCQUF1QixnREFBZ0QscUJBQXFCLGlGQUFpRixjQUFjLE9BQU8sU0FBUywwREFBMEQsUUFBUSwwQkFBMEIscUJBQXFCLE9BQU8sa0NBQWtDLGNBQWMsVUFBVSxjQUFjLDRFQUE0RSxRQUFRLHNCQUFzQixVQUFVLFdBQVcsNkJBQTZCLGFBQWEsb0RBQW9ELFVBQVUsaUNBQWlDLHdJQUF3SSw4RUFBOEUsYUFBYSxzQ0FBc0Msc0JBQXNCLGlFQUFpRSw4QkFBOEIsT0FBTyxVQUFVLDZCQUE2QixvQkFBb0IsMERBQTBELHlDQUF5QyxpQ0FBaUMsaUNBQWlDLGNBQWMsMEJBQTBCLGtEQUFrRCxRQUFRLHdDQUF3QyxzQ0FBc0MsZ0NBQWdDLHlNQUF5TSx5QkFBeUIscUZBQXFGLGdCQUFnQixPQUFPLHlCQUF5Qix5Q0FBeUMsOEJBQThCLFVBQVUsK0RBQStELFFBQVEseUJBQXlCLG1DQUFtQyxvQkFBb0Isb0JBQW9CLDJCQUEyQiwyQkFBMkIsMkRBQTJELDJFQUEyRSxTQUFTLFVBQVUsZUFBZSxnQkFBZ0Isb0JBQW9CLE9BQU8sVUFBVSxhQUFhLG1EQUFtRCw2QkFBNkIsYUFBYSxnQkFBZ0IscURBQXFELDBCQUEwQixlQUFlLDJEQUEyRCwyQkFBMkIsbURBQW1ELGdFQUFnRSxTQUFTLGFBQWEsMkJBQTJCLG9CQUFvQixTQUFTLHlFQUF5RSxxQkFBcUIsUUFBUSxhQUFhLHNGQUFzRix3Q0FBd0MseUNBQXlDLHFCQUFxQiw4Q0FBOEMsNkJBQTZCLGtDQUFrQyw0QkFBNEIscUJBQXFCLDJDQUEyQyxPQUFPLGNBQWMsc0NBQXNDLE9BQU8seUNBQXlDLDBDQUEwQyxtQkFBbUIsdUJBQXVCLGFBQWEsc0NBQXNDLG9CQUFvQiw2RUFBNkUsMkJBQTJCLG1CQUFtQiw2Q0FBNkMsMkVBQTJFLHVDQUF1QywrREFBK0Qsb0JBQW9CLHlGQUF5RixrQ0FBa0MsMkJBQTJCLHFCQUFxQixxQkFBcUIsOEJBQThCLGtDQUFrQywyQkFBMkIscUJBQXFCLDBIQUEwSCxrQ0FBa0MsOEJBQThCLDBCQUEwQiw2QkFBNkIsUUFBUSwrRUFBK0UsVUFBVSxRQUFRLHNCQUFzQiwyQkFBMkIsbUJBQW1CLGtCQUFrQixvQ0FBb0MsT0FBTyx5QkFBeUIsNkJBQTZCLHlDQUF5QyxVQUFVLHFCQUFxQixnREFBZ0QsNkJBQTZCLGFBQWEsaUJBQWlCLCtOQUErTiw4QkFBOEIsbURBQW1ELFFBQVEsVUFBVSxVQUFVLDZCQUE2QixPQUFPLGtEQUFrRCwwQkFBMEIsNkJBQTZCLHlFQUF5RSxVQUFVLGtCQUFrQixvQ0FBb0MsU0FBUyxxQ0FBcUMsT0FBTyxTQUFTLCtDQUErQyxTQUFTLGFBQWEsd0VBQXdFLHlDQUF5QyxrRUFBa0UsUUFBUSxXQUFXLE9BQU8sZ0VBQWdFLG9EQUFvRCxlQUFlLDRCQUE0Qiw4R0FBOEcsc0NBQXNDLHVEQUF1RCxPQUFPLFFBQVEsbURBQW1ELFNBQVMsU0FBUyxVQUFVLFFBQVEsb0RBQW9ELG9CQUFvQixxQkFBcUIsYUFBYSwyQ0FBMkMsdURBQXVELGNBQWMsd0JBQXdCLHdFQUF3RSxTQUFTLDJCQUEyQixPQUFPLDBCQUEwQixTQUFTLHVDQUF1QyxRQUFRLDJDQUEyQyxzRUFBc0UsUUFBUSx3QkFBd0Isb0JBQW9CLGlIQUFpSCxTQUFTLFNBQVMsMEJBQTBCLGtIQUFrSCxVQUFVLFVBQVUsYUFBYSwyQkFBMkIsNEJBQTRCLG1CQUFtQixXQUFXLHdEQUF3RCxxQkFBcUIsdUJBQXVCLFNBQVMsb0ZBQW9GLGVBQWUsb1BBQW9QLHFCQUFxQixrRkFBa0YscUJBQXFCLHVCQUF1QixjQUFjLDRCQUE0QixPQUFPLDBDQUEwQyw4RUFBOEUsYUFBYSxlQUFlLE9BQU8sUUFBUSw0QkFBNEIsU0FBUyxRQUFRLE9BQU8sNkJBQTZCLGNBQWMsd0VBQXdFLGdEQUFnRCxPQUFPLDJCQUEyQiw0QkFBNEIsT0FBTyw0Q0FBNEMsNkJBQTZCLDJCQUEyQiwwQ0FBMEMsV0FBVyxlQUFlLGVBQWUseUNBQXlDLG9EQUFvRCxxQ0FBcUMsT0FBTyw0RUFBNEUsY0FBYyxhQUFhLG9CQUFvQiw4RkFBOEYseUlBQXlJLGtDQUFrQyxRQUFRLDBFQUEwRSxpQkFBaUIsb0NBQW9DLDhEQUE4RCxRQUFRLDhDQUE4QyxPQUFPLHFCQUFxQixXQUFXLGtDQUFrQyxxQkFBcUIsWUFBWSx3REFBd0QsUUFBUSw4Q0FBOEMsd0RBQXdELGNBQWMscUNBQXFDLFlBQVksT0FBTyxpSkFBaUoseUJBQXlCLHNFQUFzRSwyQkFBMkIsU0FBUyx3QkFBd0IsZ0JBQWdCLFNBQVMsa0NBQWtDLFFBQVEsU0FBUyxZQUFZLGtCQUFrQixlQUFlLDJCQUEyQixnRUFBZ0UsNENBQTRDLGdDQUFnQyxVQUFVLHFDQUFxQyxjQUFjLG9FQUFvRSw2QkFBNkIsT0FBTyxtR0FBbUcsMkJBQTJCLGFBQWEsMERBQTBELGFBQWEsb0JBQW9CLG9CQUFvQixhQUFhLG9CQUFvQixRQUFRLFVBQVUsVUFBVSwwRkFBMEYsWUFBWSw0QkFBNEIsYUFBYSwwQkFBMEIsb0JBQW9CLGlEQUFpRCxhQUFhLDBCQUEwQixxQkFBcUIsUUFBUSxnREFBZ0Qsc0ZBQXNGLGNBQWMsMEJBQTBCLGNBQWMsOENBQThDLDZCQUE2Qiw4QkFBOEIsNkJBQTZCLDhCQUE4QixpR0FBaUcsK0VBQStFLG9KQUFvSixxRUFBcUUsU0FBUyxhQUFhLGdCQUFnQixVQUFVLDJCQUEyQixPQUFPLFVBQVUsVUFBVSx5Q0FBeUMsNEJBQTRCLHNCQUFzQixlQUFlLDJCQUEyQixPQUFPLGNBQWMsc0lBQXNJLGdCQUFnQix3SUFBd0ksNEJBQTRCLFNBQVMsYUFBYSxnQkFBZ0IsNkJBQTZCLFFBQVEsVUFBVSxVQUFVLDJCQUEyQixPQUFPLFVBQVUseUNBQXlDLDRCQUE0QixzQkFBc0IsZUFBZSwyQkFBMkIsT0FBTyxvQ0FBb0MsNENBQTRDLGlCQUFpQiwySkFBMkosT0FBTyxnREFBZ0QsVUFBVSxPQUFPLFdBQVcsUUFBUSxxR0FBcUcsNkJBQTZCLHlLQUF5SyxpQ0FBaUMsZUFBZSxPQUFPLGtEQUFrRCw4QkFBOEIsU0FBUyxhQUFhLGtDQUFrQyxxQkFBcUIsOEdBQThHLCtEQUErRCx3QkFBd0IsaUJBQWlCLDBCQUEwQixXQUFXLFVBQVUsUUFBUSxVQUFVLFlBQVksc0RBQXNELG1CQUFtQixTQUFTLFVBQVUsbVBBQW1QLDhFQUE4RSxTQUFTLDZDQUE2QyxnREFBZ0QseUNBQXlDLE9BQU8sb0dBQW9HLHlEQUF5RCxpQ0FBaUMsU0FBUyw2QkFBNkIsNkNBQTZDLFFBQVEsMElBQTBJLHdEQUF3RCxnRUFBZ0UsaUNBQWlDLFNBQVMsU0FBUyxTQUFTLGdEQUFnRCxVQUFVLGNBQWMsNkVBQTZFLHlJQUF5SSxvQkFBb0IsMENBQTBDLHVJQUF1SSx3RkFBd0YsZ0NBQWdDLCtCQUErQixnQ0FBZ0MseUdBQXlHLHFEQUFxRCx1QkFBdUIsUUFBUSxVQUFVLHVDQUF1QywyRUFBMkUsZ0VBQWdFLDBHQUEwRyxpRUFBaUUsaURBQWlELGNBQWMsY0FBYyxVQUFVLFFBQVEscUJBQXFCLHlCQUF5Qiw0QkFBNEIsd0lBQXdJLDZEQUE2RCw4REFBOEQsc0RBQXNELDhGQUE4Rix1SkFBdUosNkJBQTZCLE9BQU8seUJBQXlCLHFCQUFxQixTQUFTLHFCQUFxQix3Q0FBd0Msd0dBQXdHLDhCQUE4QixPQUFPLFNBQVMsd0NBQXdDLFFBQVEscUJBQXFCLFlBQVksU0FBUyxxQkFBcUIsdUNBQXVDLFFBQVE7QUFDcDY4QztBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7Ozs7Ozs7Ozs7O0FDUmE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBZTtBQUNmO0FBQ0EsNkNBQTZDLFNBQVMsUUFBUSxRQUFRLFVBQVU7QUFDaEY7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEOzs7Ozs7Ozs7OztBQ1JhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSxrREFBa0Qsa0JBQWtCLGdCQUFnQixlQUFlLGNBQWMsaUJBQWlCLGlCQUFpQixjQUFjLGVBQWUsZUFBZSxlQUFlLGNBQWMsZUFBZSxnQkFBZ0IsaUJBQWlCLGNBQWMsaUJBQWlCLGVBQWUsVUFBVSxRQUFRLHNCQUFzQixHQUFHLFNBQVMsWUFBWSxxQkFBcUIsR0FBRyxTQUFTLFFBQVEsc0JBQXNCLEdBQUcsZUFBZSxpQkFBaUIsa0JBQWtCLGVBQWUsaUJBQWlCLGNBQWMsaUJBQWlCLDJCQUEyQixVQUFVLG1CQUFtQixHQUFHLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixnQkFBZ0IsZUFBZSxnQkFBZ0IsaUJBQWlCLGNBQWMsaUJBQWlCLGVBQWUsY0FBYyxlQUFlLGVBQWUsZ0JBQWdCLGNBQWMsY0FBYyxtQkFBbUIsZUFBZSxjQUFjLG9CQUFvQixlQUFlLGVBQWUsZ0JBQWdCLGdCQUFnQixlQUFlLG9CQUFvQixnQkFBZ0IsZUFBZSxlQUFlLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLGVBQWUsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZUFBZSxpQkFBaUIsaUJBQWlCLGdCQUFnQixlQUFlLGNBQWMsaUJBQWlCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGlCQUFpQixlQUFlLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZUFBZSxpQkFBaUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGdCQUFnQixpQkFBaUIsZUFBZSxnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixlQUFlLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGVBQWUsY0FBYyxpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLGVBQWUsY0FBYyxpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZUFBZSxpQkFBaUIsZ0JBQWdCLGVBQWUsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGVBQWUsZUFBZSxpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGVBQWUsZUFBZSxnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGVBQWUsZUFBZSxpQkFBaUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGVBQWUsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGNBQWMsY0FBYyxnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixlQUFlLGlCQUFpQixpQkFBaUIsZUFBZSxlQUFlLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGlCQUFpQixrQkFBa0IsaUJBQWlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLHlCQUF5QixlQUFlLGVBQWUsMkJBQTJCLGdCQUFnQixxQkFBcUIsa0JBQWtCLGVBQWUsZ0JBQWdCLGdCQUFnQixrQkFBa0IsZUFBZSxjQUFjLGdCQUFnQixlQUFlLGdCQUFnQixpQkFBaUIsYUFBYSxhQUFhLGFBQWEsa0JBQWtCLGFBQWEsY0FBYyxnQkFBZ0IsY0FBYyxrQkFBa0IsY0FBYyxjQUFjLGNBQWMsY0FBYyxnQkFBZ0IsZUFBZSxnQkFBZ0IsZ0JBQWdCLGVBQWUsZUFBZSxjQUFjLGdCQUFnQixlQUFlLGdCQUFnQixpQkFBaUIsYUFBYSxhQUFhLGFBQWEsa0JBQWtCLGFBQWEsY0FBYyxpQkFBaUIsZ0JBQWdCLGNBQWMsZUFBZSxjQUFjLGNBQWMsY0FBYyxnQkFBZ0IsbUJBQW1CLGVBQWUsZUFBZSxjQUFjLGlCQUFpQixrQkFBa0Isa0JBQWtCLGVBQWUsZ0JBQWdCLHNCQUFzQixnQkFBZ0IsZUFBZSxlQUFlLGdCQUFnQixlQUFlLGdCQUFnQixlQUFlLGlCQUFpQixlQUFlLGVBQWUsZ0JBQWdCLGVBQWUsZ0JBQWdCLGVBQWUsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGVBQWUsZUFBZSxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsZUFBZSxlQUFlLGVBQWUsZUFBZSxpQkFBaUIsaUJBQWlCLGNBQWMsaUJBQWlCLGNBQWMsZUFBZSxlQUFlLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxlQUFlLGVBQWUsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGVBQWUsZUFBZSxlQUFlLGVBQWUsaUJBQWlCLGlCQUFpQixjQUFjLGlCQUFpQixjQUFjLGVBQWUsZUFBZSxlQUFl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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7O0FDcmdCYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsa0JBQWtCLG1CQUFPLENBQUMscUVBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DLGlCQUFpQixLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1Ylk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLG1FQUFZOztBQUUvQix3QkFBd0IsbUJBQU8sQ0FBQyxtQ0FBc0I7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDcElZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkJZOztBQUVaLGdCQUFnQixtQkFBTyxDQUFDLDREQUFhOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hDWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsd0RBQVc7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFXO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLGdFQUFlO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyxvREFBUztBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBZ0I7QUFDMUMsV0FBVyxtQkFBTyxDQUFDLGtEQUFRO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTs7QUFFM0I7QUFDQTs7QUFFQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDckRZOztBQUVaLE1BQU0sU0FBUyxFQUFFLG1CQUFPLENBQUMscUVBQW1CO0FBQzVDLE1BQU0sc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxtQkFBTTtBQUM1QyxNQUFNLHdDQUF3QyxFQUFFLG1CQUFPLENBQUMsNEJBQWU7QUFDdkUsTUFBTSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLGtCQUFLOztBQUVwRCxxQkFBcUIsbUJBQU8sQ0FBQywwRUFBb0I7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsa0VBQWdCO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLG1DQUFzQjs7QUFFdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMENBQTBDO0FBQ3hEO0FBQ0E7QUFDQSxjQUFjLGdEQUFnRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQsMkNBQTJDLGtDQUFrQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxrQ0FBa0M7QUFDNUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZQWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTtBQUNyQyxlQUFlLG1CQUFPLENBQUMsMERBQVk7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQWlCO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxvREFBUztBQUM3QixhQUFhLG1CQUFPLENBQUMsc0RBQVU7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGtEQUFRO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDREQUFhO0FBQ3JDLE1BQU0sY0FBYyxFQUFFLG1CQUFPLENBQUMsd0RBQVc7QUFDekMsZUFBZSxtQkFBTyxDQUFDLDREQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sS0FBSyxxQkFBcUI7QUFDaEUsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsaUJBQWlCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JpQlk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFH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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hXWTs7QUFFWixrQkFBa0IsbUJBQU8sQ0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyNUJhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVk7QUFDOUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDNkI7QUFDWTtBQUN6QztBQUNPO0FBQ1A7QUFDQTtBQUNBLFdBQVcsNkNBQUU7QUFDYix5Q0FBeUMsSUFBSTtBQUM3QztBQUNBOzs7Ozs7Ozs7OztBQ1ZBOzs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COzs7Ozs7O1VDcEJuQjtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7QUNObUM7QUFDbkM7QUFDaUM7QUFDakM7QUFDQTtBQUNBLGtCQUFrQiwwQ0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9kb20tc2VyaWFsaXplci9saWIvZm9yZWlnbk5hbWVzLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvZG9tLXNlcmlhbGl6ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvZG9tZWxlbWVudHR5cGUvbGliL2luZGV4LmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvZG9taGFuZGxlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9kb21oYW5kbGVyL2xpYi9ub2RlLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL2ZlZWRzLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvbGVnYWN5LmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL21hbmlwdWxhdGlvbi5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9xdWVyeWluZy5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvdHJhdmVyc2FsLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2RlY29kZS5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9kZWNvZGVfY29kZXBvaW50LmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2VuY29kZS5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZ2VuZXJhdGVkL2RlY29kZS1kYXRhLWh0bWwuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZ2VuZXJhdGVkL2RlY29kZS1kYXRhLXhtbC5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9nZW5lcmF0ZWQvZW5jb2RlLWh0bWwuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9QYXJzZXIuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9saWIvVG9rZW5pemVyLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL2luZGV4LmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcGFyc2Utc3Jjc2V0L3NyYy9wYXJzZS1zcmNzZXQuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9waWNvY29sb3JzL3BpY29jb2xvcnMuYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2F0LXJ1bGUuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9jb21tZW50LmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvY29udGFpbmVyLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvY3NzLXN5bnRheC1lcnJvci5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2RlY2xhcmF0aW9uLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvZG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9mcm9tSlNPTi5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2lucHV0LmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbGF6eS1yZXN1bHQuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9saXN0LmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL25vLXdvcmstcmVzdWx0LmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbm9kZS5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3BhcnNlLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcGFyc2VyLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcG9zdGNzcy5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3ByZXZpb3VzLW1hcC5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3Byb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3Jlc3VsdC5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3Jvb3QuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9ydWxlLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvc3RyaW5naWZpZXIuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9zeW1ib2xzLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvdG9rZW5pemUuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi93YXJuLW9uY2UuanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvc2FuaXRpemUtaHRtbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vbm9kZV9tb2R1bGVzL3Nhbml0aXplLWh0bWwvbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iamVjdC9kaXN0L2lzLXBsYWluLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViLy4vd2Vic3JjL2JhZGVsLmpzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi93ZWJzcmMvcXVpei5qcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViL2lnbm9yZWR8RDpcXGxvZ2FuXFxnaXRodWJcXGJyYWVuaWFrc1xcd2ViXFxub2RlX21vZHVsZXNcXHBvc3Rjc3NcXGxpYnwuL3Rlcm1pbmFsLWhpZ2hsaWdodCIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViL2lnbm9yZWR8RDpcXGxvZ2FuXFxnaXRodWJcXGJyYWVuaWFrc1xcd2ViXFxub2RlX21vZHVsZXNcXHBvc3Rjc3NcXGxpYnxmcyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViL2lnbm9yZWR8RDpcXGxvZ2FuXFxnaXRodWJcXGJyYWVuaWFrc1xcd2ViXFxub2RlX21vZHVsZXNcXHBvc3Rjc3NcXGxpYnxwYXRoIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvaWdub3JlZHxEOlxcbG9nYW5cXGdpdGh1YlxcYnJhZW5pYWtzXFx3ZWJcXG5vZGVfbW9kdWxlc1xccG9zdGNzc1xcbGlifHNvdXJjZS1tYXAtanMiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi9pZ25vcmVkfEQ6XFxsb2dhblxcZ2l0aHViXFxicmFlbmlha3NcXHdlYlxcbm9kZV9tb2R1bGVzXFxwb3N0Y3NzXFxsaWJ8dXJsIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi9ub2RlX21vZHVsZXMvbmFub2lkL25vbi1zZWN1cmUvaW5kZXguY2pzIiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9icmFlbmlha3Mtd2ViL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vYnJhZW5pYWtzLXdlYi93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2JyYWVuaWFrcy13ZWIvLi93ZWJzcmMvZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hdHRyaWJ1dGVOYW1lcyA9IGV4cG9ydHMuZWxlbWVudE5hbWVzID0gdm9pZCAwO1xuZXhwb3J0cy5lbGVtZW50TmFtZXMgPSBuZXcgTWFwKFtcbiAgICBcImFsdEdseXBoXCIsXG4gICAgXCJhbHRHbHlwaERlZlwiLFxuICAgIFwiYWx0R2x5cGhJdGVtXCIsXG4gICAgXCJhbmltYXRlQ29sb3JcIixcbiAgICBcImFuaW1hdGVNb3Rpb25cIixcbiAgICBcImFuaW1hdGVUcmFuc2Zvcm1cIixcbiAgICBcImNsaXBQYXRoXCIsXG4gICAgXCJmZUJsZW5kXCIsXG4gICAgXCJmZUNvbG9yTWF0cml4XCIsXG4gICAgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIsXG4gICAgXCJmZUNvbXBvc2l0ZVwiLFxuICAgIFwiZmVDb252b2x2ZU1hdHJpeFwiLFxuICAgIFwiZmVEaWZmdXNlTGlnaHRpbmdcIixcbiAgICBcImZlRGlzcGxhY2VtZW50TWFwXCIsXG4gICAgXCJmZURpc3RhbnRMaWdodFwiLFxuICAgIFwiZmVEcm9wU2hhZG93XCIsXG4gICAgXCJmZUZsb29kXCIsXG4gICAgXCJmZUZ1bmNBXCIsXG4gICAgXCJmZUZ1bmNCXCIsXG4gICAgXCJmZUZ1bmNHXCIsXG4gICAgXCJmZUZ1bmNSXCIsXG4gICAgXCJmZUdhdXNzaWFuQmx1clwiLFxuICAgIFwiZmVJbWFnZVwiLFxuICAgIFwiZmVNZXJnZVwiLFxuICAgIFwiZmVNZXJnZU5vZGVcIixcbiAgICBcImZlTW9ycGhvbG9neVwiLFxuICAgIFwiZmVPZmZzZXRcIixcbiAgICBcImZlUG9pbnRMaWdodFwiLFxuICAgIFwiZmVTcGVjdWxhckxpZ2h0aW5nXCIsXG4gICAgXCJmZVNwb3RMaWdodFwiLFxuICAgIFwiZmVUaWxlXCIsXG4gICAgXCJmZVR1cmJ1bGVuY2VcIixcbiAgICBcImZvcmVpZ25PYmplY3RcIixcbiAgICBcImdseXBoUmVmXCIsXG4gICAgXCJsaW5lYXJHcmFkaWVudFwiLFxuICAgIFwicmFkaWFsR3JhZGllbnRcIixcbiAgICBcInRleHRQYXRoXCIsXG5dLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBbdmFsLnRvTG93ZXJDYXNlKCksIHZhbF07IH0pKTtcbmV4cG9ydHMuYXR0cmlidXRlTmFtZXMgPSBuZXcgTWFwKFtcbiAgICBcImRlZmluaXRpb25VUkxcIixcbiAgICBcImF0dHJpYnV0ZU5hbWVcIixcbiAgICBcImF0dHJpYnV0ZVR5cGVcIixcbiAgICBcImJhc2VGcmVxdWVuY3lcIixcbiAgICBcImJhc2VQcm9maWxlXCIsXG4gICAgXCJjYWxjTW9kZVwiLFxuICAgIFwiY2xpcFBhdGhVbml0c1wiLFxuICAgIFwiZGlmZnVzZUNvbnN0YW50XCIsXG4gICAgXCJlZGdlTW9kZVwiLFxuICAgIFwiZmlsdGVyVW5pdHNcIixcbiAgICBcImdseXBoUmVmXCIsXG4gICAgXCJncmFkaWVudFRyYW5zZm9ybVwiLFxuICAgIFwiZ3JhZGllbnRVbml0c1wiLFxuICAgIFwia2VybmVsTWF0cml4XCIsXG4gICAgXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gICAgXCJrZXlQb2ludHNcIixcbiAgICBcImtleVNwbGluZXNcIixcbiAgICBcImtleVRpbWVzXCIsXG4gICAgXCJsZW5ndGhBZGp1c3RcIixcbiAgICBcImxpbWl0aW5nQ29uZUFuZ2xlXCIsXG4gICAgXCJtYXJrZXJIZWlnaHRcIixcbiAgICBcIm1hcmtlclVuaXRzXCIsXG4gICAgXCJtYXJrZXJXaWR0aFwiLFxuICAgIFwibWFza0NvbnRlbnRVbml0c1wiLFxuICAgIFwibWFza1VuaXRzXCIsXG4gICAgXCJudW1PY3RhdmVzXCIsXG4gICAgXCJwYXRoTGVuZ3RoXCIsXG4gICAgXCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsXG4gICAgXCJwYXR0ZXJuVHJhbnNmb3JtXCIsXG4gICAgXCJwYXR0ZXJuVW5pdHNcIixcbiAgICBcInBvaW50c0F0WFwiLFxuICAgIFwicG9pbnRzQXRZXCIsXG4gICAgXCJwb2ludHNBdFpcIixcbiAgICBcInByZXNlcnZlQWxwaGFcIixcbiAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICBcInByaW1pdGl2ZVVuaXRzXCIsXG4gICAgXCJyZWZYXCIsXG4gICAgXCJyZWZZXCIsXG4gICAgXCJyZXBlYXRDb3VudFwiLFxuICAgIFwicmVwZWF0RHVyXCIsXG4gICAgXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcbiAgICBcInJlcXVpcmVkRmVhdHVyZXNcIixcbiAgICBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICBcInNwZWN1bGFyRXhwb25lbnRcIixcbiAgICBcInNwcmVhZE1ldGhvZFwiLFxuICAgIFwic3RhcnRPZmZzZXRcIixcbiAgICBcInN0ZERldmlhdGlvblwiLFxuICAgIFwic3RpdGNoVGlsZXNcIixcbiAgICBcInN1cmZhY2VTY2FsZVwiLFxuICAgIFwic3lzdGVtTGFuZ3VhZ2VcIixcbiAgICBcInRhYmxlVmFsdWVzXCIsXG4gICAgXCJ0YXJnZXRYXCIsXG4gICAgXCJ0YXJnZXRZXCIsXG4gICAgXCJ0ZXh0TGVuZ3RoXCIsXG4gICAgXCJ2aWV3Qm94XCIsXG4gICAgXCJ2aWV3VGFyZ2V0XCIsXG4gICAgXCJ4Q2hhbm5lbFNlbGVjdG9yXCIsXG4gICAgXCJ5Q2hhbm5lbFNlbGVjdG9yXCIsXG4gICAgXCJ6b29tQW5kUGFuXCIsXG5dLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBbdmFsLnRvTG93ZXJDYXNlKCksIHZhbF07IH0pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZW5kZXIgPSB2b2lkIDA7XG4vKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG52YXIgRWxlbWVudFR5cGUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpKTtcbnZhciBlbnRpdGllc18xID0gcmVxdWlyZShcImVudGl0aWVzXCIpO1xuLyoqXG4gKiBNaXhlZC1jYXNlIFNWRyBhbmQgTWF0aE1MIHRhZ3MgJiBhdHRyaWJ1dGVzXG4gKiByZWNvZ25pemVkIGJ5IHRoZSBIVE1MIHBhcnNlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNwYXJzaW5nLW1haW4taW5mb3JlaWduXG4gKi9cbnZhciBmb3JlaWduTmFtZXNfanNfMSA9IHJlcXVpcmUoXCIuL2ZvcmVpZ25OYW1lcy5qc1wiKTtcbnZhciB1bmVuY29kZWRFbGVtZW50cyA9IG5ldyBTZXQoW1xuICAgIFwic3R5bGVcIixcbiAgICBcInNjcmlwdFwiLFxuICAgIFwieG1wXCIsXG4gICAgXCJpZnJhbWVcIixcbiAgICBcIm5vZW1iZWRcIixcbiAgICBcIm5vZnJhbWVzXCIsXG4gICAgXCJwbGFpbnRleHRcIixcbiAgICBcIm5vc2NyaXB0XCIsXG5dKTtcbmZ1bmN0aW9uIHJlcGxhY2VRdW90ZXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIik7XG59XG4vKipcbiAqIEZvcm1hdCBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEF0dHJpYnV0ZXMoYXR0cmlidXRlcywgb3B0cykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWF0dHJpYnV0ZXMpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgZW5jb2RlID0gKChfYSA9IG9wdHMuZW5jb2RlRW50aXRpZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdHMuZGVjb2RlRW50aXRpZXMpID09PSBmYWxzZVxuICAgICAgICA/IHJlcGxhY2VRdW90ZXNcbiAgICAgICAgOiBvcHRzLnhtbE1vZGUgfHwgb3B0cy5lbmNvZGVFbnRpdGllcyAhPT0gXCJ1dGY4XCJcbiAgICAgICAgICAgID8gZW50aXRpZXNfMS5lbmNvZGVYTUxcbiAgICAgICAgICAgIDogZW50aXRpZXNfMS5lc2NhcGVBdHRyaWJ1dGU7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgdmFsdWUgPSAoX2EgPSBhdHRyaWJ1dGVzW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIGlmIChvcHRzLnhtbE1vZGUgPT09IFwiZm9yZWlnblwiKSB7XG4gICAgICAgICAgICAvKiBGaXggdXAgbWl4ZWQtY2FzZSBhdHRyaWJ1dGUgbmFtZXMgKi9cbiAgICAgICAgICAgIGtleSA9IChfYiA9IGZvcmVpZ25OYW1lc19qc18xLmF0dHJpYnV0ZU5hbWVzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLmVtcHR5QXR0cnMgJiYgIW9wdHMueG1sTW9kZSAmJiB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIj1cXFwiXCIpLmNvbmNhdChlbmNvZGUodmFsdWUpLCBcIlxcXCJcIik7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xufVxuLyoqXG4gKiBTZWxmLWVuY2xvc2luZyB0YWdzXG4gKi9cbnZhciBzaW5nbGVUYWcgPSBuZXcgU2V0KFtcbiAgICBcImFyZWFcIixcbiAgICBcImJhc2VcIixcbiAgICBcImJhc2Vmb250XCIsXG4gICAgXCJiclwiLFxuICAgIFwiY29sXCIsXG4gICAgXCJjb21tYW5kXCIsXG4gICAgXCJlbWJlZFwiLFxuICAgIFwiZnJhbWVcIixcbiAgICBcImhyXCIsXG4gICAgXCJpbWdcIixcbiAgICBcImlucHV0XCIsXG4gICAgXCJpc2luZGV4XCIsXG4gICAgXCJrZXlnZW5cIixcbiAgICBcImxpbmtcIixcbiAgICBcIm1ldGFcIixcbiAgICBcInBhcmFtXCIsXG4gICAgXCJzb3VyY2VcIixcbiAgICBcInRyYWNrXCIsXG4gICAgXCJ3YnJcIixcbl0pO1xuLyoqXG4gKiBSZW5kZXJzIGEgRE9NIG5vZGUgb3IgYW4gYXJyYXkgb2YgRE9NIG5vZGVzIHRvIGEgc3RyaW5nLlxuICpcbiAqIENhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSBlcXVpdmFsZW50IG9mIHRoZSBgb3V0ZXJIVE1MYCBvZiB0aGUgcGFzc2VkIG5vZGUocykuXG4gKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSBvcHRpb25zIENoYW5nZXMgc2VyaWFsaXphdGlvbiBiZWhhdmlvclxuICovXG5mdW5jdGlvbiByZW5kZXIobm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG5vZGVzID0gXCJsZW5ndGhcIiBpbiBub2RlID8gbm9kZSA6IFtub2RlXTtcbiAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dHB1dCArPSByZW5kZXJOb2RlKG5vZGVzW2ldLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVuZGVyO1xuZnVuY3Rpb24gcmVuZGVyTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZS5Sb290OlxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcihub2RlLmNoaWxkcmVuLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBkb24ndCB1c2UgYERvY3R5cGVgIHlldFxuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlLkRvY3R5cGU6XG4gICAgICAgIGNhc2UgRWxlbWVudFR5cGUuRGlyZWN0aXZlOlxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlckRpcmVjdGl2ZShub2RlKTtcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZS5Db21tZW50OlxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlckNvbW1lbnQobm9kZSk7XG4gICAgICAgIGNhc2UgRWxlbWVudFR5cGUuQ0RBVEE6XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyQ2RhdGEobm9kZSk7XG4gICAgICAgIGNhc2UgRWxlbWVudFR5cGUuU2NyaXB0OlxuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlLlN0eWxlOlxuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlLlRhZzpcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJUYWcobm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgRWxlbWVudFR5cGUuVGV4dDpcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJUZXh0KG5vZGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cbnZhciBmb3JlaWduTW9kZUludGVncmF0aW9uUG9pbnRzID0gbmV3IFNldChbXG4gICAgXCJtaVwiLFxuICAgIFwibW9cIixcbiAgICBcIm1uXCIsXG4gICAgXCJtc1wiLFxuICAgIFwibXRleHRcIixcbiAgICBcImFubm90YXRpb24teG1sXCIsXG4gICAgXCJmb3JlaWduT2JqZWN0XCIsXG4gICAgXCJkZXNjXCIsXG4gICAgXCJ0aXRsZVwiLFxuXSk7XG52YXIgZm9yZWlnbkVsZW1lbnRzID0gbmV3IFNldChbXCJzdmdcIiwgXCJtYXRoXCJdKTtcbmZ1bmN0aW9uIHJlbmRlclRhZyhlbGVtLCBvcHRzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIEhhbmRsZSBTVkcgLyBNYXRoTUwgaW4gSFRNTFxuICAgIGlmIChvcHRzLnhtbE1vZGUgPT09IFwiZm9yZWlnblwiKSB7XG4gICAgICAgIC8qIEZpeCB1cCBtaXhlZC1jYXNlIGVsZW1lbnQgbmFtZXMgKi9cbiAgICAgICAgZWxlbS5uYW1lID0gKF9hID0gZm9yZWlnbk5hbWVzX2pzXzEuZWxlbWVudE5hbWVzLmdldChlbGVtLm5hbWUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlbGVtLm5hbWU7XG4gICAgICAgIC8qIEV4aXQgZm9yZWlnbiBtb2RlIGF0IGludGVncmF0aW9uIHBvaW50cyAqL1xuICAgICAgICBpZiAoZWxlbS5wYXJlbnQgJiZcbiAgICAgICAgICAgIGZvcmVpZ25Nb2RlSW50ZWdyYXRpb25Qb2ludHMuaGFzKGVsZW0ucGFyZW50Lm5hbWUpKSB7XG4gICAgICAgICAgICBvcHRzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdHMpLCB7IHhtbE1vZGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0cy54bWxNb2RlICYmIGZvcmVpZ25FbGVtZW50cy5oYXMoZWxlbS5uYW1lKSkge1xuICAgICAgICBvcHRzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdHMpLCB7IHhtbE1vZGU6IFwiZm9yZWlnblwiIH0pO1xuICAgIH1cbiAgICB2YXIgdGFnID0gXCI8XCIuY29uY2F0KGVsZW0ubmFtZSk7XG4gICAgdmFyIGF0dHJpYnMgPSBmb3JtYXRBdHRyaWJ1dGVzKGVsZW0uYXR0cmlicywgb3B0cyk7XG4gICAgaWYgKGF0dHJpYnMpIHtcbiAgICAgICAgdGFnICs9IFwiIFwiLmNvbmNhdChhdHRyaWJzKTtcbiAgICB9XG4gICAgaWYgKGVsZW0uY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmXG4gICAgICAgIChvcHRzLnhtbE1vZGVcbiAgICAgICAgICAgID8gLy8gSW4gWE1MIG1vZGUgb3IgZm9yZWlnbiBtb2RlLCBhbmQgdXNlciBoYXNuJ3QgZXhwbGljaXRseSB0dXJuZWQgb2ZmIHNlbGYtY2xvc2luZyB0YWdzXG4gICAgICAgICAgICAgICAgb3B0cy5zZWxmQ2xvc2luZ1RhZ3MgIT09IGZhbHNlXG4gICAgICAgICAgICA6IC8vIFVzZXIgZXhwbGljaXRseSBhc2tlZCBmb3Igc2VsZi1jbG9zaW5nIHRhZ3MsIGV2ZW4gaW4gSFRNTCBtb2RlXG4gICAgICAgICAgICAgICAgb3B0cy5zZWxmQ2xvc2luZ1RhZ3MgJiYgc2luZ2xlVGFnLmhhcyhlbGVtLm5hbWUpKSkge1xuICAgICAgICBpZiAoIW9wdHMueG1sTW9kZSlcbiAgICAgICAgICAgIHRhZyArPSBcIiBcIjtcbiAgICAgICAgdGFnICs9IFwiLz5cIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhZyArPSBcIj5cIjtcbiAgICAgICAgaWYgKGVsZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGFnICs9IHJlbmRlcihlbGVtLmNoaWxkcmVuLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy54bWxNb2RlIHx8ICFzaW5nbGVUYWcuaGFzKGVsZW0ubmFtZSkpIHtcbiAgICAgICAgICAgIHRhZyArPSBcIjwvXCIuY29uY2F0KGVsZW0ubmFtZSwgXCI+XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5mdW5jdGlvbiByZW5kZXJEaXJlY3RpdmUoZWxlbSkge1xuICAgIHJldHVybiBcIjxcIi5jb25jYXQoZWxlbS5kYXRhLCBcIj5cIik7XG59XG5mdW5jdGlvbiByZW5kZXJUZXh0KGVsZW0sIG9wdHMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGRhdGEgPSBlbGVtLmRhdGEgfHwgXCJcIjtcbiAgICAvLyBJZiBlbnRpdGllcyB3ZXJlbid0IGRlY29kZWQsIG5vIG5lZWQgdG8gZW5jb2RlIHRoZW0gYmFja1xuICAgIGlmICgoKF9hID0gb3B0cy5lbmNvZGVFbnRpdGllcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3B0cy5kZWNvZGVFbnRpdGllcykgIT09IGZhbHNlICYmXG4gICAgICAgICEoIW9wdHMueG1sTW9kZSAmJlxuICAgICAgICAgICAgZWxlbS5wYXJlbnQgJiZcbiAgICAgICAgICAgIHVuZW5jb2RlZEVsZW1lbnRzLmhhcyhlbGVtLnBhcmVudC5uYW1lKSkpIHtcbiAgICAgICAgZGF0YSA9XG4gICAgICAgICAgICBvcHRzLnhtbE1vZGUgfHwgb3B0cy5lbmNvZGVFbnRpdGllcyAhPT0gXCJ1dGY4XCJcbiAgICAgICAgICAgICAgICA/ICgwLCBlbnRpdGllc18xLmVuY29kZVhNTCkoZGF0YSlcbiAgICAgICAgICAgICAgICA6ICgwLCBlbnRpdGllc18xLmVzY2FwZVRleHQpKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNkYXRhKGVsZW0pIHtcbiAgICByZXR1cm4gXCI8IVtDREFUQVtcIi5jb25jYXQoZWxlbS5jaGlsZHJlblswXS5kYXRhLCBcIl1dPlwiKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbW1lbnQoZWxlbSkge1xuICAgIHJldHVybiBcIjwhLS1cIi5jb25jYXQoZWxlbS5kYXRhLCBcIi0tPlwiKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Eb2N0eXBlID0gZXhwb3J0cy5DREFUQSA9IGV4cG9ydHMuVGFnID0gZXhwb3J0cy5TdHlsZSA9IGV4cG9ydHMuU2NyaXB0ID0gZXhwb3J0cy5Db21tZW50ID0gZXhwb3J0cy5EaXJlY3RpdmUgPSBleHBvcnRzLlRleHQgPSBleHBvcnRzLlJvb3QgPSBleHBvcnRzLmlzVGFnID0gZXhwb3J0cy5FbGVtZW50VHlwZSA9IHZvaWQgMDtcbi8qKiBUeXBlcyBvZiBlbGVtZW50cyBmb3VuZCBpbiBodG1scGFyc2VyMidzIERPTSAqL1xudmFyIEVsZW1lbnRUeXBlO1xuKGZ1bmN0aW9uIChFbGVtZW50VHlwZSkge1xuICAgIC8qKiBUeXBlIGZvciB0aGUgcm9vdCBlbGVtZW50IG9mIGEgZG9jdW1lbnQgKi9cbiAgICBFbGVtZW50VHlwZVtcIlJvb3RcIl0gPSBcInJvb3RcIjtcbiAgICAvKiogVHlwZSBmb3IgVGV4dCAqL1xuICAgIEVsZW1lbnRUeXBlW1wiVGV4dFwiXSA9IFwidGV4dFwiO1xuICAgIC8qKiBUeXBlIGZvciA8PyAuLi4gPz4gKi9cbiAgICBFbGVtZW50VHlwZVtcIkRpcmVjdGl2ZVwiXSA9IFwiZGlyZWN0aXZlXCI7XG4gICAgLyoqIFR5cGUgZm9yIDwhLS0gLi4uIC0tPiAqL1xuICAgIEVsZW1lbnRUeXBlW1wiQ29tbWVudFwiXSA9IFwiY29tbWVudFwiO1xuICAgIC8qKiBUeXBlIGZvciA8c2NyaXB0PiB0YWdzICovXG4gICAgRWxlbWVudFR5cGVbXCJTY3JpcHRcIl0gPSBcInNjcmlwdFwiO1xuICAgIC8qKiBUeXBlIGZvciA8c3R5bGU+IHRhZ3MgKi9cbiAgICBFbGVtZW50VHlwZVtcIlN0eWxlXCJdID0gXCJzdHlsZVwiO1xuICAgIC8qKiBUeXBlIGZvciBBbnkgdGFnICovXG4gICAgRWxlbWVudFR5cGVbXCJUYWdcIl0gPSBcInRhZ1wiO1xuICAgIC8qKiBUeXBlIGZvciA8IVtDREFUQVsgLi4uIF1dPiAqL1xuICAgIEVsZW1lbnRUeXBlW1wiQ0RBVEFcIl0gPSBcImNkYXRhXCI7XG4gICAgLyoqIFR5cGUgZm9yIDwhZG9jdHlwZSAuLi4+ICovXG4gICAgRWxlbWVudFR5cGVbXCJEb2N0eXBlXCJdID0gXCJkb2N0eXBlXCI7XG59KShFbGVtZW50VHlwZSA9IGV4cG9ydHMuRWxlbWVudFR5cGUgfHwgKGV4cG9ydHMuRWxlbWVudFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgYSB0YWcgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBlbGVtIEVsZW1lbnQgdG8gdGVzdFxuICovXG5mdW5jdGlvbiBpc1RhZyhlbGVtKSB7XG4gICAgcmV0dXJuIChlbGVtLnR5cGUgPT09IEVsZW1lbnRUeXBlLlRhZyB8fFxuICAgICAgICBlbGVtLnR5cGUgPT09IEVsZW1lbnRUeXBlLlNjcmlwdCB8fFxuICAgICAgICBlbGVtLnR5cGUgPT09IEVsZW1lbnRUeXBlLlN0eWxlKTtcbn1cbmV4cG9ydHMuaXNUYWcgPSBpc1RhZztcbi8vIEV4cG9ydHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4vKiogVHlwZSBmb3IgdGhlIHJvb3QgZWxlbWVudCBvZiBhIGRvY3VtZW50ICovXG5leHBvcnRzLlJvb3QgPSBFbGVtZW50VHlwZS5Sb290O1xuLyoqIFR5cGUgZm9yIFRleHQgKi9cbmV4cG9ydHMuVGV4dCA9IEVsZW1lbnRUeXBlLlRleHQ7XG4vKiogVHlwZSBmb3IgPD8gLi4uID8+ICovXG5leHBvcnRzLkRpcmVjdGl2ZSA9IEVsZW1lbnRUeXBlLkRpcmVjdGl2ZTtcbi8qKiBUeXBlIGZvciA8IS0tIC4uLiAtLT4gKi9cbmV4cG9ydHMuQ29tbWVudCA9IEVsZW1lbnRUeXBlLkNvbW1lbnQ7XG4vKiogVHlwZSBmb3IgPHNjcmlwdD4gdGFncyAqL1xuZXhwb3J0cy5TY3JpcHQgPSBFbGVtZW50VHlwZS5TY3JpcHQ7XG4vKiogVHlwZSBmb3IgPHN0eWxlPiB0YWdzICovXG5leHBvcnRzLlN0eWxlID0gRWxlbWVudFR5cGUuU3R5bGU7XG4vKiogVHlwZSBmb3IgQW55IHRhZyAqL1xuZXhwb3J0cy5UYWcgPSBFbGVtZW50VHlwZS5UYWc7XG4vKiogVHlwZSBmb3IgPCFbQ0RBVEFbIC4uLiBdXT4gKi9cbmV4cG9ydHMuQ0RBVEEgPSBFbGVtZW50VHlwZS5DREFUQTtcbi8qKiBUeXBlIGZvciA8IWRvY3R5cGUgLi4uPiAqL1xuZXhwb3J0cy5Eb2N0eXBlID0gRWxlbWVudFR5cGUuRG9jdHlwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRvbUhhbmRsZXIgPSB2b2lkIDA7XG52YXIgZG9tZWxlbWVudHR5cGVfMSA9IHJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKTtcbnZhciBub2RlX2pzXzEgPSByZXF1aXJlKFwiLi9ub2RlLmpzXCIpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25vZGUuanNcIiksIGV4cG9ydHMpO1xuLy8gRGVmYXVsdCBvcHRpb25zXG52YXIgZGVmYXVsdE9wdHMgPSB7XG4gICAgd2l0aFN0YXJ0SW5kaWNlczogZmFsc2UsXG4gICAgd2l0aEVuZEluZGljZXM6IGZhbHNlLFxuICAgIHhtbE1vZGU6IGZhbHNlLFxufTtcbnZhciBEb21IYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBDYWxsZWQgb25jZSBwYXJzaW5nIGhhcyBjb21wbGV0ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU2V0dGluZ3MgZm9yIHRoZSBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSBlbGVtZW50Q0IgQ2FsbGJhY2sgd2hlbmV2ZXIgYSB0YWcgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERvbUhhbmRsZXIoY2FsbGJhY2ssIG9wdGlvbnMsIGVsZW1lbnRDQikge1xuICAgICAgICAvKiogVGhlIGVsZW1lbnRzIG9mIHRoZSBET00gKi9cbiAgICAgICAgdGhpcy5kb20gPSBbXTtcbiAgICAgICAgLyoqIFRoZSByb290IGVsZW1lbnQgZm9yIHRoZSBET00gKi9cbiAgICAgICAgdGhpcy5yb290ID0gbmV3IG5vZGVfanNfMS5Eb2N1bWVudCh0aGlzLmRvbSk7XG4gICAgICAgIC8qKiBJbmRpY2F0ZWQgd2hldGhlciBwYXJzaW5nIGhhcyBiZWVuIGNvbXBsZXRlZC4gKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIC8qKiBTdGFjayBvZiBvcGVuIHRhZ3MuICovXG4gICAgICAgIHRoaXMudGFnU3RhY2sgPSBbdGhpcy5yb290XTtcbiAgICAgICAgLyoqIEEgZGF0YSBub2RlIHRoYXQgaXMgc3RpbGwgYmVpbmcgd3JpdHRlbiB0by4gKi9cbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHBhcnNlciBpbnN0YW5jZS4gVXNlZCBmb3IgbG9jYXRpb24gaW5mb3JtYXRpb24uICovXG4gICAgICAgIHRoaXMucGFyc2VyID0gbnVsbDtcbiAgICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBza2lwIGFyZ3VtZW50cywgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBlbGVtZW50Q0IgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjayAhPT0gbnVsbCAmJiBjYWxsYmFjayAhPT0gdm9pZCAwID8gY2FsbGJhY2sgOiBudWxsO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiBkZWZhdWx0T3B0cztcbiAgICAgICAgdGhpcy5lbGVtZW50Q0IgPSBlbGVtZW50Q0IgIT09IG51bGwgJiYgZWxlbWVudENCICE9PSB2b2lkIDAgPyBlbGVtZW50Q0IgOiBudWxsO1xuICAgIH1cbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbnBhcnNlcmluaXQgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH07XG4gICAgLy8gUmVzZXRzIHRoZSBoYW5kbGVyIGJhY2sgdG8gc3RhcnRpbmcgc3RhdGVcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRvbSA9IFtdO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgbm9kZV9qc18xLkRvY3VtZW50KHRoaXMuZG9tKTtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGFnU3RhY2sgPSBbdGhpcy5yb290XTtcbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbnVsbDtcbiAgICB9O1xuICAgIC8vIFNpZ25hbHMgdGhlIGhhbmRsZXIgdGhhdCBwYXJzaW5nIGlzIGRvbmVcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZUNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLmhhbmRsZUNhbGxiYWNrKGVycm9yKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY2xvc2V0YWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGFzdE5vZGUgPSBudWxsO1xuICAgICAgICB2YXIgZWxlbSA9IHRoaXMudGFnU3RhY2sucG9wKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2l0aEVuZEluZGljZXMpIHtcbiAgICAgICAgICAgIGVsZW0uZW5kSW5kZXggPSB0aGlzLnBhcnNlci5lbmRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbGVtZW50Q0IpXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRDQihlbGVtKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9ub3BlbnRhZyA9IGZ1bmN0aW9uIChuYW1lLCBhdHRyaWJzKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5vcHRpb25zLnhtbE1vZGUgPyBkb21lbGVtZW50dHlwZV8xLkVsZW1lbnRUeXBlLlRhZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBuZXcgbm9kZV9qc18xLkVsZW1lbnQobmFtZSwgYXR0cmlicywgdW5kZWZpbmVkLCB0eXBlKTtcbiAgICAgICAgdGhpcy5hZGROb2RlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnRhZ1N0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbnRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbGFzdE5vZGUgPSB0aGlzLmxhc3ROb2RlO1xuICAgICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gZG9tZWxlbWVudHR5cGVfMS5FbGVtZW50VHlwZS5UZXh0KSB7XG4gICAgICAgICAgICBsYXN0Tm9kZS5kYXRhICs9IGRhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLndpdGhFbmRJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgbGFzdE5vZGUuZW5kSW5kZXggPSB0aGlzLnBhcnNlci5lbmRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IG5vZGVfanNfMS5UZXh0KGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5hZGROb2RlKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY29tbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3ROb2RlICYmIHRoaXMubGFzdE5vZGUudHlwZSA9PT0gZG9tZWxlbWVudHR5cGVfMS5FbGVtZW50VHlwZS5Db21tZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3ROb2RlLmRhdGEgKz0gZGF0YTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBub2RlX2pzXzEuQ29tbWVudChkYXRhKTtcbiAgICAgICAgdGhpcy5hZGROb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmxhc3ROb2RlID0gbm9kZTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY29tbWVudGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbmNkYXRhc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IG5vZGVfanNfMS5UZXh0KFwiXCIpO1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBub2RlX2pzXzEuQ0RBVEEoW3RleHRdKTtcbiAgICAgICAgdGhpcy5hZGROb2RlKG5vZGUpO1xuICAgICAgICB0ZXh0LnBhcmVudCA9IG5vZGU7XG4gICAgICAgIHRoaXMubGFzdE5vZGUgPSB0ZXh0O1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25jZGF0YWVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IG5vZGVfanNfMS5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obmFtZSwgZGF0YSk7XG4gICAgICAgIHRoaXMuYWRkTm9kZShub2RlKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUNhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGVycm9yLCB0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5hZGROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMudGFnU3RhY2tbdGhpcy50YWdTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2l0aFN0YXJ0SW5kaWNlcykge1xuICAgICAgICAgICAgbm9kZS5zdGFydEluZGV4ID0gdGhpcy5wYXJzZXIuc3RhcnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndpdGhFbmRJbmRpY2VzKSB7XG4gICAgICAgICAgICBub2RlLmVuZEluZGV4ID0gdGhpcy5wYXJzZXIuZW5kSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgIG5vZGUucHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHByZXZpb3VzU2libGluZy5uZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRG9tSGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLkRvbUhhbmRsZXIgPSBEb21IYW5kbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gRG9tSGFuZGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNsb25lTm9kZSA9IGV4cG9ydHMuaGFzQ2hpbGRyZW4gPSBleHBvcnRzLmlzRG9jdW1lbnQgPSBleHBvcnRzLmlzRGlyZWN0aXZlID0gZXhwb3J0cy5pc0NvbW1lbnQgPSBleHBvcnRzLmlzVGV4dCA9IGV4cG9ydHMuaXNDREFUQSA9IGV4cG9ydHMuaXNUYWcgPSBleHBvcnRzLkVsZW1lbnQgPSBleHBvcnRzLkRvY3VtZW50ID0gZXhwb3J0cy5DREFUQSA9IGV4cG9ydHMuTm9kZVdpdGhDaGlsZHJlbiA9IGV4cG9ydHMuUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gZXhwb3J0cy5Db21tZW50ID0gZXhwb3J0cy5UZXh0ID0gZXhwb3J0cy5EYXRhTm9kZSA9IGV4cG9ydHMuTm9kZSA9IHZvaWQgMDtcbnZhciBkb21lbGVtZW50dHlwZV8xID0gcmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpO1xuLyoqXG4gKiBUaGlzIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgdGhlIHByb3RvdHlwZSBmb3IgTm9kZXMgd2hlbiBjcmVhdGluZyBhXG4gKiBET00tTGV2ZWwtMS1jb21wbGlhbnQgc3RydWN0dXJlLlxuICovXG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKCkge1xuICAgICAgICAvKiogUGFyZW50IG9mIHRoZSBub2RlICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgLyoqIFByZXZpb3VzIHNpYmxpbmcgKi9cbiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgLyoqIE5leHQgc2libGluZyAqL1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICAvKiogVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBub2RlLiBSZXF1aXJlcyBgd2l0aFN0YXJ0SW5kaWNlc2Agb24gdGhlIGhhbmRsZXIgdG8gYmUgYHRydWUuICovXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgZW5kIGluZGV4IG9mIHRoZSBub2RlLiBSZXF1aXJlcyBgd2l0aEVuZEluZGljZXNgIG9uIHRoZSBoYW5kbGVyIHRvIGJlIGB0cnVlLiAqL1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCBcInBhcmVudE5vZGVcIiwge1xuICAgICAgICAvLyBSZWFkLXdyaXRlIGFsaWFzZXMgZm9yIHByb3BlcnRpZXNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbWUgYXMge0BsaW5rIHBhcmVudH0uXG4gICAgICAgICAqIFtET00gc3BlY10oaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnKS1jb21wYXRpYmxlIGFsaWFzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIFwicHJldmlvdXNTaWJsaW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbWUgYXMge0BsaW5rIHByZXZ9LlxuICAgICAgICAgKiBbRE9NIHNwZWNdKGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZyktY29tcGF0aWJsZSBhbGlhcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocHJldikge1xuICAgICAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgXCJuZXh0U2libGluZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHtAbGluayBuZXh0fS5cbiAgICAgICAgICogW0RPTSBzcGVjXShodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcpLWNvbXBhdGlibGUgYWxpYXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGlzIG5vZGUsIGFuZCBvcHRpb25hbGx5IGl0cyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWN1cnNpdmUgQ2xvbmUgY2hpbGQgbm9kZXMgYXMgd2VsbC5cbiAgICAgKiBAcmV0dXJucyBBIGNsb25lIG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIE5vZGUucHJvdG90eXBlLmNsb25lTm9kZSA9IGZ1bmN0aW9uIChyZWN1cnNpdmUpIHtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBjbG9uZU5vZGUodGhpcywgcmVjdXJzaXZlKTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG4vKipcbiAqIEEgbm9kZSB0aGF0IGNvbnRhaW5zIHNvbWUgZGF0YS5cbiAqL1xudmFyIERhdGFOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRhTm9kZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgY29udGVudCBvZiB0aGUgZGF0YSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YU5vZGUoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcIm5vZGVWYWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHtAbGluayBkYXRhfS5cbiAgICAgICAgICogW0RPTSBzcGVjXShodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcpLWNvbXBhdGlibGUgYWxpYXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRGF0YU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRGF0YU5vZGUgPSBEYXRhTm9kZTtcbi8qKlxuICogVGV4dCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICovXG52YXIgVGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IGRvbWVsZW1lbnR0eXBlXzEuRWxlbWVudFR5cGUuVGV4dDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIFwibm9kZVR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRleHQ7XG59KERhdGFOb2RlKSk7XG5leHBvcnRzLlRleHQgPSBUZXh0O1xuLyoqXG4gKiBDb21tZW50cyB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICovXG52YXIgQ29tbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21tZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IGRvbWVsZW1lbnR0eXBlXzEuRWxlbWVudFR5cGUuQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tbWVudC5wcm90b3R5cGUsIFwibm9kZVR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvbW1lbnQ7XG59KERhdGFOb2RlKSk7XG5leHBvcnRzLkNvbW1lbnQgPSBDb21tZW50O1xuLyoqXG4gKiBQcm9jZXNzaW5nIGluc3RydWN0aW9ucywgaW5jbHVkaW5nIGRvYyB0eXBlcy5cbiAqL1xudmFyIFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb2Nlc3NpbmdJbnN0cnVjdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRhdGEpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy50eXBlID0gZG9tZWxlbWVudHR5cGVfMS5FbGVtZW50VHlwZS5EaXJlY3RpdmU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb2Nlc3NpbmdJbnN0cnVjdGlvbi5wcm90b3R5cGUsIFwibm9kZVR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb2Nlc3NpbmdJbnN0cnVjdGlvbjtcbn0oRGF0YU5vZGUpKTtcbmV4cG9ydHMuUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuLyoqXG4gKiBBIGBOb2RlYCB0aGF0IGNhbiBoYXZlIGNoaWxkcmVuLlxuICovXG52YXIgTm9kZVdpdGhDaGlsZHJlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9kZVdpdGhDaGlsZHJlbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIG5vZGUuIE9ubHkgY2VydGFpbiBub2RlIHR5cGVzIGNhbiBoYXZlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vZGVXaXRoQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZVdpdGhDaGlsZHJlbi5wcm90b3R5cGUsIFwiZmlyc3RDaGlsZFwiLCB7XG4gICAgICAgIC8vIEFsaWFzZXNcbiAgICAgICAgLyoqIEZpcnN0IGNoaWxkIG9mIHRoZSBub2RlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNoaWxkcmVuWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGVXaXRoQ2hpbGRyZW4ucHJvdG90eXBlLCBcImxhc3RDaGlsZFwiLCB7XG4gICAgICAgIC8qKiBMYXN0IGNoaWxkIG9mIHRoZSBub2RlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlV2l0aENoaWxkcmVuLnByb3RvdHlwZSwgXCJjaGlsZE5vZGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbWUgYXMge0BsaW5rIGNoaWxkcmVufS5cbiAgICAgICAgICogW0RPTSBzcGVjXShodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcpLWNvbXBhdGlibGUgYWxpYXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE5vZGVXaXRoQ2hpbGRyZW47XG59KE5vZGUpKTtcbmV4cG9ydHMuTm9kZVdpdGhDaGlsZHJlbiA9IE5vZGVXaXRoQ2hpbGRyZW47XG52YXIgQ0RBVEEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENEQVRBLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENEQVRBKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IGRvbWVsZW1lbnR0eXBlXzEuRWxlbWVudFR5cGUuQ0RBVEE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENEQVRBLnByb3RvdHlwZSwgXCJub2RlVHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ0RBVEE7XG59KE5vZGVXaXRoQ2hpbGRyZW4pKTtcbmV4cG9ydHMuQ0RBVEEgPSBDREFUQTtcbi8qKlxuICogVGhlIHJvb3Qgbm9kZSBvZiB0aGUgZG9jdW1lbnQuXG4gKi9cbnZhciBEb2N1bWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9jdW1lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gZG9tZWxlbWVudHR5cGVfMS5FbGVtZW50VHlwZS5Sb290O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2N1bWVudC5wcm90b3R5cGUsIFwibm9kZVR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERvY3VtZW50O1xufShOb2RlV2l0aENoaWxkcmVuKSk7XG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG4vKipcbiAqIEFuIGVsZW1lbnQgd2l0aGluIHRoZSBET00uXG4gKi9cbnZhciBFbGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbGVtZW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHRhZywgZWcuIGBkaXZgLCBgc3BhbmAuXG4gICAgICogQHBhcmFtIGF0dHJpYnMgT2JqZWN0IG1hcHBpbmcgYXR0cmlidXRlIG5hbWVzIHRvIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnQobmFtZSwgYXR0cmlicywgY2hpbGRyZW4sIHR5cGUpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHsgY2hpbGRyZW4gPSBbXTsgfVxuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBuYW1lID09PSBcInNjcmlwdFwiXG4gICAgICAgICAgICA/IGRvbWVsZW1lbnR0eXBlXzEuRWxlbWVudFR5cGUuU2NyaXB0XG4gICAgICAgICAgICA6IG5hbWUgPT09IFwic3R5bGVcIlxuICAgICAgICAgICAgICAgID8gZG9tZWxlbWVudHR5cGVfMS5FbGVtZW50VHlwZS5TdHlsZVxuICAgICAgICAgICAgICAgIDogZG9tZWxlbWVudHR5cGVfMS5FbGVtZW50VHlwZS5UYWc7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2hpbGRyZW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5hdHRyaWJzID0gYXR0cmlicztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVsZW1lbnQucHJvdG90eXBlLCBcIm5vZGVUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbGVtZW50LnByb3RvdHlwZSwgXCJ0YWdOYW1lXCIsIHtcbiAgICAgICAgLy8gRE9NIExldmVsIDEgYWxpYXNlc1xuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyB7QGxpbmsgbmFtZX0uXG4gICAgICAgICAqIFtET00gc3BlY10oaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnKS1jb21wYXRpYmxlIGFsaWFzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVsZW1lbnQucHJvdG90eXBlLCBcImF0dHJpYnV0ZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hdHRyaWJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuYXR0cmlic1tuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiAoX2EgPSBfdGhpc1tcIngtYXR0cmlic05hbWVzcGFjZVwiXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IChfYiA9IF90aGlzW1wieC1hdHRyaWJzUHJlZml4XCJdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbmFtZV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBFbGVtZW50O1xufShOb2RlV2l0aENoaWxkcmVuKSk7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuLyoqXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBub2RlIGlzIGEgYEVsZW1lbnRgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNUYWcobm9kZSkge1xuICAgIHJldHVybiAoMCwgZG9tZWxlbWVudHR5cGVfMS5pc1RhZykobm9kZSk7XG59XG5leHBvcnRzLmlzVGFnID0gaXNUYWc7XG4vKipcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG5vZGUgaGFzIHRoZSB0eXBlIGBDREFUQWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0NEQVRBKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBkb21lbGVtZW50dHlwZV8xLkVsZW1lbnRUeXBlLkNEQVRBO1xufVxuZXhwb3J0cy5pc0NEQVRBID0gaXNDREFUQTtcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbm9kZSBoYXMgdGhlIHR5cGUgYFRleHRgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBkb21lbGVtZW50dHlwZV8xLkVsZW1lbnRUeXBlLlRleHQ7XG59XG5leHBvcnRzLmlzVGV4dCA9IGlzVGV4dDtcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbm9kZSBoYXMgdGhlIHR5cGUgYENvbW1lbnRgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNDb21tZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBkb21lbGVtZW50dHlwZV8xLkVsZW1lbnRUeXBlLkNvbW1lbnQ7XG59XG5leHBvcnRzLmlzQ29tbWVudCA9IGlzQ29tbWVudDtcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbm9kZSBoYXMgdGhlIHR5cGUgYFByb2Nlc3NpbmdJbnN0cnVjdGlvbmAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0RpcmVjdGl2ZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gZG9tZWxlbWVudHR5cGVfMS5FbGVtZW50VHlwZS5EaXJlY3RpdmU7XG59XG5leHBvcnRzLmlzRGlyZWN0aXZlID0gaXNEaXJlY3RpdmU7XG4vKipcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG5vZGUgaGFzIHRoZSB0eXBlIGBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25gLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gZG9tZWxlbWVudHR5cGVfMS5FbGVtZW50VHlwZS5Sb290O1xufVxuZXhwb3J0cy5pc0RvY3VtZW50ID0gaXNEb2N1bWVudDtcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbm9kZSBoYXMgY2hpbGRyZW4sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBoYXNDaGlsZHJlbihub2RlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBcImNoaWxkcmVuXCIpO1xufVxuZXhwb3J0cy5oYXNDaGlsZHJlbiA9IGhhc0NoaWxkcmVuO1xuLyoqXG4gKiBDbG9uZSBhIG5vZGUsIGFuZCBvcHRpb25hbGx5IGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gcmVjdXJzaXZlIENsb25lIGNoaWxkIG5vZGVzIGFzIHdlbGwuXG4gKiBAcmV0dXJucyBBIGNsb25lIG9mIHRoZSBub2RlLlxuICovXG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSwgcmVjdXJzaXZlKSB7XG4gICAgaWYgKHJlY3Vyc2l2ZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2l2ZSA9IGZhbHNlOyB9XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBUZXh0KG5vZGUuZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29tbWVudChub2RlKSkge1xuICAgICAgICByZXN1bHQgPSBuZXcgQ29tbWVudChub2RlLmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1RhZyhub2RlKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSByZWN1cnNpdmUgPyBjbG9uZUNoaWxkcmVuKG5vZGUuY2hpbGRyZW4pIDogW107XG4gICAgICAgIHZhciBjbG9uZV8xID0gbmV3IEVsZW1lbnQobm9kZS5uYW1lLCBfX2Fzc2lnbih7fSwgbm9kZS5hdHRyaWJzKSwgY2hpbGRyZW4pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gKGNoaWxkLnBhcmVudCA9IGNsb25lXzEpOyB9KTtcbiAgICAgICAgaWYgKG5vZGUubmFtZXNwYWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsb25lXzEubmFtZXNwYWNlID0gbm9kZS5uYW1lc3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVbXCJ4LWF0dHJpYnNOYW1lc3BhY2VcIl0pIHtcbiAgICAgICAgICAgIGNsb25lXzFbXCJ4LWF0dHJpYnNOYW1lc3BhY2VcIl0gPSBfX2Fzc2lnbih7fSwgbm9kZVtcIngtYXR0cmlic05hbWVzcGFjZVwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVbXCJ4LWF0dHJpYnNQcmVmaXhcIl0pIHtcbiAgICAgICAgICAgIGNsb25lXzFbXCJ4LWF0dHJpYnNQcmVmaXhcIl0gPSBfX2Fzc2lnbih7fSwgbm9kZVtcIngtYXR0cmlic1ByZWZpeFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gY2xvbmVfMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDREFUQShub2RlKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSByZWN1cnNpdmUgPyBjbG9uZUNoaWxkcmVuKG5vZGUuY2hpbGRyZW4pIDogW107XG4gICAgICAgIHZhciBjbG9uZV8yID0gbmV3IENEQVRBKGNoaWxkcmVuKTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIChjaGlsZC5wYXJlbnQgPSBjbG9uZV8yKTsgfSk7XG4gICAgICAgIHJlc3VsdCA9IGNsb25lXzI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcmVjdXJzaXZlID8gY2xvbmVDaGlsZHJlbihub2RlLmNoaWxkcmVuKSA6IFtdO1xuICAgICAgICB2YXIgY2xvbmVfMyA9IG5ldyBEb2N1bWVudChjaGlsZHJlbik7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAoY2hpbGQucGFyZW50ID0gY2xvbmVfMyk7IH0pO1xuICAgICAgICBpZiAobm9kZVtcIngtbW9kZVwiXSkge1xuICAgICAgICAgICAgY2xvbmVfM1tcIngtbW9kZVwiXSA9IG5vZGVbXCJ4LW1vZGVcIl07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gY2xvbmVfMztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEaXJlY3RpdmUobm9kZSkpIHtcbiAgICAgICAgdmFyIGluc3RydWN0aW9uID0gbmV3IFByb2Nlc3NpbmdJbnN0cnVjdGlvbihub2RlLm5hbWUsIG5vZGUuZGF0YSk7XG4gICAgICAgIGlmIChub2RlW1wieC1uYW1lXCJdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9uW1wieC1uYW1lXCJdID0gbm9kZVtcIngtbmFtZVwiXTtcbiAgICAgICAgICAgIGluc3RydWN0aW9uW1wieC1wdWJsaWNJZFwiXSA9IG5vZGVbXCJ4LXB1YmxpY0lkXCJdO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bXCJ4LXN5c3RlbUlkXCJdID0gbm9kZVtcIngtc3lzdGVtSWRcIl07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaW5zdHJ1Y3Rpb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQgeWV0OiBcIi5jb25jYXQobm9kZS50eXBlKSk7XG4gICAgfVxuICAgIHJlc3VsdC5zdGFydEluZGV4ID0gbm9kZS5zdGFydEluZGV4O1xuICAgIHJlc3VsdC5lbmRJbmRleCA9IG5vZGUuZW5kSW5kZXg7XG4gICAgaWYgKG5vZGUuc291cmNlQ29kZUxvY2F0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnNvdXJjZUNvZGVMb2NhdGlvbiA9IG5vZGUuc291cmNlQ29kZUxvY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jbG9uZU5vZGUgPSBjbG9uZU5vZGU7XG5mdW5jdGlvbiBjbG9uZUNoaWxkcmVuKGNoaWxkcykge1xuICAgIHZhciBjaGlsZHJlbiA9IGNoaWxkcy5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjbG9uZU5vZGUoY2hpbGQsIHRydWUpOyB9KTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLnByZXYgPSBjaGlsZHJlbltpIC0gMV07XG4gICAgICAgIGNoaWxkcmVuW2kgLSAxXS5uZXh0ID0gY2hpbGRyZW5baV07XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRGZWVkID0gdm9pZCAwO1xudmFyIHN0cmluZ2lmeV9qc18xID0gcmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpO1xudmFyIGxlZ2FjeV9qc18xID0gcmVxdWlyZShcIi4vbGVnYWN5LmpzXCIpO1xuLyoqXG4gKiBHZXQgdGhlIGZlZWQgb2JqZWN0IGZyb20gdGhlIHJvb3Qgb2YgYSBET00gdHJlZS5cbiAqXG4gKiBAY2F0ZWdvcnkgRmVlZHNcbiAqIEBwYXJhbSBkb2MgLSBUaGUgRE9NIHRvIHRvIGV4dHJhY3QgdGhlIGZlZWQgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBmZWVkLlxuICovXG5mdW5jdGlvbiBnZXRGZWVkKGRvYykge1xuICAgIHZhciBmZWVkUm9vdCA9IGdldE9uZUVsZW1lbnQoaXNWYWxpZEZlZWQsIGRvYyk7XG4gICAgcmV0dXJuICFmZWVkUm9vdFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBmZWVkUm9vdC5uYW1lID09PSBcImZlZWRcIlxuICAgICAgICAgICAgPyBnZXRBdG9tRmVlZChmZWVkUm9vdClcbiAgICAgICAgICAgIDogZ2V0UnNzRmVlZChmZWVkUm9vdCk7XG59XG5leHBvcnRzLmdldEZlZWQgPSBnZXRGZWVkO1xuLyoqXG4gKiBQYXJzZSBhbiBBdG9tIGZlZWQuXG4gKlxuICogQHBhcmFtIGZlZWRSb290IFRoZSByb290IG9mIHRoZSBmZWVkLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBmZWVkLlxuICovXG5mdW5jdGlvbiBnZXRBdG9tRmVlZChmZWVkUm9vdCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgY2hpbGRzID0gZmVlZFJvb3QuY2hpbGRyZW47XG4gICAgdmFyIGZlZWQgPSB7XG4gICAgICAgIHR5cGU6IFwiYXRvbVwiLFxuICAgICAgICBpdGVtczogKDAsIGxlZ2FjeV9qc18xLmdldEVsZW1lbnRzQnlUYWdOYW1lKShcImVudHJ5XCIsIGNoaWxkcykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpdGVtLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0geyBtZWRpYTogZ2V0TWVkaWFFbGVtZW50cyhjaGlsZHJlbikgfTtcbiAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiaWRcIiwgXCJpZFwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGVudHJ5LCBcInRpdGxlXCIsIFwidGl0bGVcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgdmFyIGhyZWYgPSAoX2EgPSBnZXRPbmVFbGVtZW50KFwibGlua1wiLCBjaGlsZHJlbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRyaWJzW1wiaHJlZlwiXTtcbiAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgZW50cnkubGluayA9IGhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBmZXRjaChcInN1bW1hcnlcIiwgY2hpbGRyZW4pIHx8IGZldGNoKFwiY29udGVudFwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHB1YkRhdGUgPSBmZXRjaChcInVwZGF0ZWRcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgaWYgKHB1YkRhdGUpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5wdWJEYXRlID0gbmV3IERhdGUocHViRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgIH0pLFxuICAgIH07XG4gICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImlkXCIsIFwiaWRcIiwgY2hpbGRzKTtcbiAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHMpO1xuICAgIHZhciBocmVmID0gKF9hID0gZ2V0T25lRWxlbWVudChcImxpbmtcIiwgY2hpbGRzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJpYnNbXCJocmVmXCJdO1xuICAgIGlmIChocmVmKSB7XG4gICAgICAgIGZlZWQubGluayA9IGhyZWY7XG4gICAgfVxuICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJkZXNjcmlwdGlvblwiLCBcInN1YnRpdGxlXCIsIGNoaWxkcyk7XG4gICAgdmFyIHVwZGF0ZWQgPSBmZXRjaChcInVwZGF0ZWRcIiwgY2hpbGRzKTtcbiAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICBmZWVkLnVwZGF0ZWQgPSBuZXcgRGF0ZSh1cGRhdGVkKTtcbiAgICB9XG4gICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImF1dGhvclwiLCBcImVtYWlsXCIsIGNoaWxkcywgdHJ1ZSk7XG4gICAgcmV0dXJuIGZlZWQ7XG59XG4vKipcbiAqIFBhcnNlIGEgUlNTIGZlZWQuXG4gKlxuICogQHBhcmFtIGZlZWRSb290IFRoZSByb290IG9mIHRoZSBmZWVkLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBmZWVkLlxuICovXG5mdW5jdGlvbiBnZXRSc3NGZWVkKGZlZWRSb290KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgY2hpbGRzID0gKF9iID0gKF9hID0gZ2V0T25lRWxlbWVudChcImNoYW5uZWxcIiwgZmVlZFJvb3QuY2hpbGRyZW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGRyZW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgIHZhciBmZWVkID0ge1xuICAgICAgICB0eXBlOiBmZWVkUm9vdC5uYW1lLnN1YnN0cigwLCAzKSxcbiAgICAgICAgaWQ6IFwiXCIsXG4gICAgICAgIGl0ZW1zOiAoMCwgbGVnYWN5X2pzXzEuZ2V0RWxlbWVudHNCeVRhZ05hbWUpKFwiaXRlbVwiLCBmZWVkUm9vdC5jaGlsZHJlbikubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpdGVtLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0geyBtZWRpYTogZ2V0TWVkaWFFbGVtZW50cyhjaGlsZHJlbikgfTtcbiAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiaWRcIiwgXCJndWlkXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGVudHJ5LCBcImxpbmtcIiwgXCJsaW5rXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiZGVzY3JpcHRpb25cIiwgXCJkZXNjcmlwdGlvblwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgcHViRGF0ZSA9IGZldGNoKFwicHViRGF0ZVwiLCBjaGlsZHJlbikgfHwgZmV0Y2goXCJkYzpkYXRlXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGlmIChwdWJEYXRlKVxuICAgICAgICAgICAgICAgIGVudHJ5LnB1YkRhdGUgPSBuZXcgRGF0ZShwdWJEYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgfSksXG4gICAgfTtcbiAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHMpO1xuICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJsaW5rXCIsIFwibGlua1wiLCBjaGlsZHMpO1xuICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJkZXNjcmlwdGlvblwiLCBcImRlc2NyaXB0aW9uXCIsIGNoaWxkcyk7XG4gICAgdmFyIHVwZGF0ZWQgPSBmZXRjaChcImxhc3RCdWlsZERhdGVcIiwgY2hpbGRzKTtcbiAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICBmZWVkLnVwZGF0ZWQgPSBuZXcgRGF0ZSh1cGRhdGVkKTtcbiAgICB9XG4gICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImF1dGhvclwiLCBcIm1hbmFnaW5nRWRpdG9yXCIsIGNoaWxkcywgdHJ1ZSk7XG4gICAgcmV0dXJuIGZlZWQ7XG59XG52YXIgTUVESUFfS0VZU19TVFJJTkcgPSBbXCJ1cmxcIiwgXCJ0eXBlXCIsIFwibGFuZ1wiXTtcbnZhciBNRURJQV9LRVlTX0lOVCA9IFtcbiAgICBcImZpbGVTaXplXCIsXG4gICAgXCJiaXRyYXRlXCIsXG4gICAgXCJmcmFtZXJhdGVcIixcbiAgICBcInNhbXBsaW5ncmF0ZVwiLFxuICAgIFwiY2hhbm5lbHNcIixcbiAgICBcImR1cmF0aW9uXCIsXG4gICAgXCJoZWlnaHRcIixcbiAgICBcIndpZHRoXCIsXG5dO1xuLyoqXG4gKiBHZXQgYWxsIG1lZGlhIGVsZW1lbnRzIG9mIGEgZmVlZCBpdGVtLlxuICpcbiAqIEBwYXJhbSB3aGVyZSBOb2RlcyB0byBzZWFyY2ggaW4uXG4gKiBAcmV0dXJucyBNZWRpYSBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gZ2V0TWVkaWFFbGVtZW50cyh3aGVyZSkge1xuICAgIHJldHVybiAoMCwgbGVnYWN5X2pzXzEuZ2V0RWxlbWVudHNCeVRhZ05hbWUpKFwibWVkaWE6Y29udGVudFwiLCB3aGVyZSkubWFwKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBhdHRyaWJzID0gZWxlbS5hdHRyaWJzO1xuICAgICAgICB2YXIgbWVkaWEgPSB7XG4gICAgICAgICAgICBtZWRpdW06IGF0dHJpYnNbXCJtZWRpdW1cIl0sXG4gICAgICAgICAgICBpc0RlZmF1bHQ6ICEhYXR0cmlic1tcImlzRGVmYXVsdFwiXSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBNRURJQV9LRVlTX1NUUklOR18xID0gTUVESUFfS0VZU19TVFJJTkc7IF9pIDwgTUVESUFfS0VZU19TVFJJTkdfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWIgPSBNRURJQV9LRVlTX1NUUklOR18xW19pXTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJzW2F0dHJpYl0pIHtcbiAgICAgICAgICAgICAgICBtZWRpYVthdHRyaWJdID0gYXR0cmlic1thdHRyaWJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgTUVESUFfS0VZU19JTlRfMSA9IE1FRElBX0tFWVNfSU5UOyBfYSA8IE1FRElBX0tFWVNfSU5UXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmliID0gTUVESUFfS0VZU19JTlRfMVtfYV07XG4gICAgICAgICAgICBpZiAoYXR0cmlic1thdHRyaWJdKSB7XG4gICAgICAgICAgICAgICAgbWVkaWFbYXR0cmliXSA9IHBhcnNlSW50KGF0dHJpYnNbYXR0cmliXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJzW1wiZXhwcmVzc2lvblwiXSkge1xuICAgICAgICAgICAgbWVkaWEuZXhwcmVzc2lvbiA9IGF0dHJpYnNbXCJleHByZXNzaW9uXCJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZWRpYTtcbiAgICB9KTtcbn1cbi8qKlxuICogR2V0IG9uZSBlbGVtZW50IGJ5IHRhZyBuYW1lLlxuICpcbiAqIEBwYXJhbSB0YWdOYW1lIFRhZyBuYW1lIHRvIGxvb2sgZm9yXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIHNlYXJjaCBpblxuICogQHJldHVybnMgVGhlIGVsZW1lbnQgb3IgbnVsbFxuICovXG5mdW5jdGlvbiBnZXRPbmVFbGVtZW50KHRhZ05hbWUsIG5vZGUpIHtcbiAgICByZXR1cm4gKDAsIGxlZ2FjeV9qc18xLmdldEVsZW1lbnRzQnlUYWdOYW1lKSh0YWdOYW1lLCBub2RlLCB0cnVlLCAxKVswXTtcbn1cbi8qKlxuICogR2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgYW4gZWxlbWVudCB3aXRoIGEgY2VydGFpbiB0YWcgbmFtZS5cbiAqXG4gKiBAcGFyYW0gdGFnTmFtZSBUYWcgbmFtZSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSB3aGVyZSBOb2RlIHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSByZWN1cnNlIFdoZXRoZXIgdG8gcmVjdXJzZSBpbnRvIGNoaWxkIG5vZGVzLlxuICogQHJldHVybnMgVGhlIHRleHQgY29udGVudCBvZiB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmV0Y2godGFnTmFtZSwgd2hlcmUsIHJlY3Vyc2UpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSBmYWxzZTsgfVxuICAgIHJldHVybiAoMCwgc3RyaW5naWZ5X2pzXzEudGV4dENvbnRlbnQpKCgwLCBsZWdhY3lfanNfMS5nZXRFbGVtZW50c0J5VGFnTmFtZSkodGFnTmFtZSwgd2hlcmUsIHJlY3Vyc2UsIDEpKS50cmltKCk7XG59XG4vKipcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0byBhbiBvYmplY3QgaWYgaXQgaGFzIGEgdmFsdWUuXG4gKlxuICogQHBhcmFtIG9iaiBPYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB0YWdOYW1lIFRhZyBuYW1lIHRoYXQgY29udGFpbnMgdGhlIGNvbmRpdGlvbmFsbHkgYWRkZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB3aGVyZSBFbGVtZW50IHRvIHNlYXJjaCBmb3IgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0gcmVjdXJzZSBXaGV0aGVyIHRvIHJlY3Vyc2UgaW50byBjaGlsZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gYWRkQ29uZGl0aW9uYWxseShvYmosIHByb3AsIHRhZ05hbWUsIHdoZXJlLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gZmFsc2U7IH1cbiAgICB2YXIgdmFsID0gZmV0Y2godGFnTmFtZSwgd2hlcmUsIHJlY3Vyc2UpO1xuICAgIGlmICh2YWwpXG4gICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGVsZW1lbnQgaXMgYSBmZWVkIHJvb3Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIGFuIGVsZW1lbnQgaXMgYSBmZWVkIHJvb3Qgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEZlZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IFwicnNzXCIgfHwgdmFsdWUgPT09IFwiZmVlZFwiIHx8IHZhbHVlID09PSBcInJkZjpSREZcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZlZWRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmlxdWVTb3J0ID0gZXhwb3J0cy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA9IGV4cG9ydHMuRG9jdW1lbnRQb3NpdGlvbiA9IGV4cG9ydHMucmVtb3ZlU3Vic2V0cyA9IHZvaWQgMDtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygbm9kZXMsIHJlbW92ZSBhbnkgbWVtYmVyIHRoYXQgaXMgY29udGFpbmVkIGJ5IGFub3RoZXJcbiAqIG1lbWJlci5cbiAqXG4gKiBAY2F0ZWdvcnkgSGVscGVyc1xuICogQHBhcmFtIG5vZGVzIE5vZGVzIHRvIGZpbHRlci5cbiAqIEByZXR1cm5zIFJlbWFpbmluZyBub2RlcyB0aGF0IGFyZW4ndCBjb250YWluZWQgYnkgb3RoZXIgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVN1YnNldHMobm9kZXMpIHtcbiAgICB2YXIgaWR4ID0gbm9kZXMubGVuZ3RoO1xuICAgIC8qXG4gICAgICogQ2hlY2sgaWYgZWFjaCBub2RlIChvciBvbmUgb2YgaXRzIGFuY2VzdG9ycykgaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlXG4gICAgICogYXJyYXkuXG4gICAgICovXG4gICAgd2hpbGUgKC0taWR4ID49IDApIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpZHhdO1xuICAgICAgICAvKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIG5vZGUgaWYgaXQgaXMgbm90IHVuaXF1ZS5cbiAgICAgICAgICogV2UgYXJlIGdvaW5nIHRocm91Z2ggdGhlIGFycmF5IGZyb20gdGhlIGVuZCwgc28gd2Ugb25seVxuICAgICAgICAgKiBoYXZlIHRvIGNoZWNrIG5vZGVzIHRoYXQgcHJlY2VlZCB0aGUgbm9kZSB1bmRlciBjb25zaWRlcmF0aW9uIGluIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpZHggPiAwICYmIG5vZGVzLmxhc3RJbmRleE9mKG5vZGUsIGlkeCAtIDEpID49IDApIHtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgYW5jZXN0b3IgPSBub2RlLnBhcmVudDsgYW5jZXN0b3I7IGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5jbHVkZXMoYW5jZXN0b3IpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZXhwb3J0cy5yZW1vdmVTdWJzZXRzID0gcmVtb3ZlU3Vic2V0cztcbi8qKlxuICogQGNhdGVnb3J5IEhlbHBlcnNcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tbm9kZS1jb21wYXJlZG9jdW1lbnRwb3NpdGlvbn1cbiAqL1xudmFyIERvY3VtZW50UG9zaXRpb247XG4oZnVuY3Rpb24gKERvY3VtZW50UG9zaXRpb24pIHtcbiAgICBEb2N1bWVudFBvc2l0aW9uW0RvY3VtZW50UG9zaXRpb25bXCJESVNDT05ORUNURURcIl0gPSAxXSA9IFwiRElTQ09OTkVDVEVEXCI7XG4gICAgRG9jdW1lbnRQb3NpdGlvbltEb2N1bWVudFBvc2l0aW9uW1wiUFJFQ0VESU5HXCJdID0gMl0gPSBcIlBSRUNFRElOR1wiO1xuICAgIERvY3VtZW50UG9zaXRpb25bRG9jdW1lbnRQb3NpdGlvbltcIkZPTExPV0lOR1wiXSA9IDRdID0gXCJGT0xMT1dJTkdcIjtcbiAgICBEb2N1bWVudFBvc2l0aW9uW0RvY3VtZW50UG9zaXRpb25bXCJDT05UQUlOU1wiXSA9IDhdID0gXCJDT05UQUlOU1wiO1xuICAgIERvY3VtZW50UG9zaXRpb25bRG9jdW1lbnRQb3NpdGlvbltcIkNPTlRBSU5FRF9CWVwiXSA9IDE2XSA9IFwiQ09OVEFJTkVEX0JZXCI7XG59KShEb2N1bWVudFBvc2l0aW9uID0gZXhwb3J0cy5Eb2N1bWVudFBvc2l0aW9uIHx8IChleHBvcnRzLkRvY3VtZW50UG9zaXRpb24gPSB7fSkpO1xuLyoqXG4gKiBDb21wYXJlIHRoZSBwb3NpdGlvbiBvZiBvbmUgbm9kZSBhZ2FpbnN0IGFub3RoZXIgbm9kZSBpbiBhbnkgb3RoZXIgZG9jdW1lbnQsXG4gKiByZXR1cm5pbmcgYSBiaXRtYXNrIHdpdGggdGhlIHZhbHVlcyBmcm9tIHtAbGluayBEb2N1bWVudFBvc2l0aW9ufS5cbiAqXG4gKiBEb2N1bWVudCBvcmRlcjpcbiAqID4gVGhlcmUgaXMgYW4gb3JkZXJpbmcsIGRvY3VtZW50IG9yZGVyLCBkZWZpbmVkIG9uIGFsbCB0aGUgbm9kZXMgaW4gdGhlXG4gKiA+IGRvY3VtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gKiA+IFhNTCByZXByZXNlbnRhdGlvbiBvZiBlYWNoIG5vZGUgb2NjdXJzIGluIHRoZSBYTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gKiA+IGRvY3VtZW50IGFmdGVyIGV4cGFuc2lvbiBvZiBnZW5lcmFsIGVudGl0aWVzLiBUaHVzLCB0aGUgZG9jdW1lbnQgZWxlbWVudFxuICogPiBub2RlIHdpbGwgYmUgdGhlIGZpcnN0IG5vZGUuIEVsZW1lbnQgbm9kZXMgb2NjdXIgYmVmb3JlIHRoZWlyIGNoaWxkcmVuLlxuICogPiBUaHVzLCBkb2N1bWVudCBvcmRlciBvcmRlcnMgZWxlbWVudCBub2RlcyBpbiBvcmRlciBvZiB0aGUgb2NjdXJyZW5jZSBvZlxuICogPiB0aGVpciBzdGFydC10YWcgaW4gdGhlIFhNTCAoYWZ0ZXIgZXhwYW5zaW9uIG9mIGVudGl0aWVzKS4gVGhlIGF0dHJpYnV0ZVxuICogPiBub2RlcyBvZiBhbiBlbGVtZW50IG9jY3VyIGFmdGVyIHRoZSBlbGVtZW50IGFuZCBiZWZvcmUgaXRzIGNoaWxkcmVuLiBUaGVcbiAqID4gcmVsYXRpdmUgb3JkZXIgb2YgYXR0cmlidXRlIG5vZGVzIGlzIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudC5cbiAqXG4gKiBTb3VyY2U6XG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2dsb3NzYXJ5Lmh0bWwjZHQtZG9jdW1lbnQtb3JkZXJcbiAqXG4gKiBAY2F0ZWdvcnkgSGVscGVyc1xuICogQHBhcmFtIG5vZGVBIFRoZSBmaXJzdCBub2RlIHRvIHVzZSBpbiB0aGUgY29tcGFyaXNvblxuICogQHBhcmFtIG5vZGVCIFRoZSBzZWNvbmQgbm9kZSB0byB1c2UgaW4gdGhlIGNvbXBhcmlzb25cbiAqIEByZXR1cm5zIEEgYml0bWFzayBkZXNjcmliaW5nIHRoZSBpbnB1dCBub2RlcycgcmVsYXRpdmUgcG9zaXRpb24uXG4gKlxuICogU2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tbm9kZS1jb21wYXJlZG9jdW1lbnRwb3NpdGlvbiBmb3JcbiAqIGEgZGVzY3JpcHRpb24gb2YgdGhlc2UgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlQSwgbm9kZUIpIHtcbiAgICB2YXIgYVBhcmVudHMgPSBbXTtcbiAgICB2YXIgYlBhcmVudHMgPSBbXTtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgY3VycmVudCA9ICgwLCBkb21oYW5kbGVyXzEuaGFzQ2hpbGRyZW4pKG5vZGVBKSA/IG5vZGVBIDogbm9kZUEucGFyZW50O1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIGFQYXJlbnRzLnVuc2hpZnQoY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgY3VycmVudCA9ICgwLCBkb21oYW5kbGVyXzEuaGFzQ2hpbGRyZW4pKG5vZGVCKSA/IG5vZGVCIDogbm9kZUIucGFyZW50O1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIGJQYXJlbnRzLnVuc2hpZnQoY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgdmFyIG1heElkeCA9IE1hdGgubWluKGFQYXJlbnRzLmxlbmd0aCwgYlBhcmVudHMubGVuZ3RoKTtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB3aGlsZSAoaWR4IDwgbWF4SWR4ICYmIGFQYXJlbnRzW2lkeF0gPT09IGJQYXJlbnRzW2lkeF0pIHtcbiAgICAgICAgaWR4Kys7XG4gICAgfVxuICAgIGlmIChpZHggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIERvY3VtZW50UG9zaXRpb24uRElTQ09OTkVDVEVEO1xuICAgIH1cbiAgICB2YXIgc2hhcmVkUGFyZW50ID0gYVBhcmVudHNbaWR4IC0gMV07XG4gICAgdmFyIHNpYmxpbmdzID0gc2hhcmVkUGFyZW50LmNoaWxkcmVuO1xuICAgIHZhciBhU2libGluZyA9IGFQYXJlbnRzW2lkeF07XG4gICAgdmFyIGJTaWJsaW5nID0gYlBhcmVudHNbaWR4XTtcbiAgICBpZiAoc2libGluZ3MuaW5kZXhPZihhU2libGluZykgPiBzaWJsaW5ncy5pbmRleE9mKGJTaWJsaW5nKSkge1xuICAgICAgICBpZiAoc2hhcmVkUGFyZW50ID09PSBub2RlQikge1xuICAgICAgICAgICAgcmV0dXJuIERvY3VtZW50UG9zaXRpb24uRk9MTE9XSU5HIHwgRG9jdW1lbnRQb3NpdGlvbi5DT05UQUlORURfQlk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERvY3VtZW50UG9zaXRpb24uRk9MTE9XSU5HO1xuICAgIH1cbiAgICBpZiAoc2hhcmVkUGFyZW50ID09PSBub2RlQSkge1xuICAgICAgICByZXR1cm4gRG9jdW1lbnRQb3NpdGlvbi5QUkVDRURJTkcgfCBEb2N1bWVudFBvc2l0aW9uLkNPTlRBSU5TO1xuICAgIH1cbiAgICByZXR1cm4gRG9jdW1lbnRQb3NpdGlvbi5QUkVDRURJTkc7XG59XG5leHBvcnRzLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID0gY29tcGFyZURvY3VtZW50UG9zaXRpb247XG4vKipcbiAqIFNvcnQgYW4gYXJyYXkgb2Ygbm9kZXMgYmFzZWQgb24gdGhlaXIgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LFxuICogcmVtb3ZpbmcgYW55IGR1cGxpY2F0ZSBub2Rlcy4gSWYgdGhlIGFycmF5IGNvbnRhaW5zIG5vZGVzIHRoYXQgZG8gbm90IGJlbG9uZ1xuICogdG8gdGhlIHNhbWUgZG9jdW1lbnQsIHNvcnQgb3JkZXIgaXMgdW5zcGVjaWZpZWQuXG4gKlxuICogQGNhdGVnb3J5IEhlbHBlcnNcbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBET00gbm9kZXMuXG4gKiBAcmV0dXJucyBDb2xsZWN0aW9uIG9mIHVuaXF1ZSBub2Rlcywgc29ydGVkIGluIGRvY3VtZW50IG9yZGVyLlxuICovXG5mdW5jdGlvbiB1bmlxdWVTb3J0KG5vZGVzKSB7XG4gICAgbm9kZXMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUsIGksIGFycikgeyByZXR1cm4gIWFyci5pbmNsdWRlcyhub2RlLCBpICsgMSk7IH0pO1xuICAgIG5vZGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSwgYik7XG4gICAgICAgIGlmIChyZWxhdGl2ZSAmIERvY3VtZW50UG9zaXRpb24uUFJFQ0VESU5HKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVsYXRpdmUgJiBEb2N1bWVudFBvc2l0aW9uLkZPTExPV0lORykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZXhwb3J0cy51bmlxdWVTb3J0ID0gdW5pcXVlU29ydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzQ2hpbGRyZW4gPSBleHBvcnRzLmlzRG9jdW1lbnQgPSBleHBvcnRzLmlzQ29tbWVudCA9IGV4cG9ydHMuaXNUZXh0ID0gZXhwb3J0cy5pc0NEQVRBID0gZXhwb3J0cy5pc1RhZyA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYXZlcnNhbC5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWFuaXB1bGF0aW9uLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9xdWVyeWluZy5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGVnYWN5LmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mZWVkcy5qc1wiKSwgZXhwb3J0cyk7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIHRoZXNlIG1ldGhvZHMgZnJvbSBgZG9taGFuZGxlcmAgZGlyZWN0bHkuICovXG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcImRvbWhhbmRsZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1RhZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9taGFuZGxlcl8xLmlzVGFnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNDREFUQVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9taGFuZGxlcl8xLmlzQ0RBVEE7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1RleHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWhhbmRsZXJfMS5pc1RleHQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NvbW1lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWhhbmRsZXJfMS5pc0NvbW1lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0RvY3VtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb21oYW5kbGVyXzEuaXNEb2N1bWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc0NoaWxkcmVuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb21oYW5kbGVyXzEuaGFzQ2hpbGRyZW47IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ1R5cGUgPSBleHBvcnRzLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gZXhwb3J0cy5nZXRFbGVtZW50QnlJZCA9IGV4cG9ydHMuZ2V0RWxlbWVudHMgPSBleHBvcnRzLnRlc3RFbGVtZW50ID0gdm9pZCAwO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xudmFyIHF1ZXJ5aW5nX2pzXzEgPSByZXF1aXJlKFwiLi9xdWVyeWluZy5qc1wiKTtcbi8qKlxuICogQSBtYXAgb2YgZnVuY3Rpb25zIHRvIGNoZWNrIG5vZGVzIGFnYWluc3QuXG4gKi9cbnZhciBDaGVja3MgPSB7XG4gICAgdGFnX25hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuICgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pICYmIG5hbWUoZWxlbS5uYW1lKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSBcIipcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWhhbmRsZXJfMS5pc1RhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuICgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pICYmIGVsZW0ubmFtZSA9PT0gbmFtZTsgfTtcbiAgICB9LFxuICAgIHRhZ190eXBlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB0eXBlKGVsZW0udHlwZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnR5cGUgPT09IHR5cGU7IH07XG4gICAgfSxcbiAgICB0YWdfY29udGFpbnM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuICgwLCBkb21oYW5kbGVyXzEuaXNUZXh0KShlbGVtKSAmJiBkYXRhKGVsZW0uZGF0YSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiAoMCwgZG9taGFuZGxlcl8xLmlzVGV4dCkoZWxlbSkgJiYgZWxlbS5kYXRhID09PSBkYXRhOyB9O1xuICAgIH0sXG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gY2hlY2sgd2hldGhlciBhIG5vZGUgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgcGFydGljdWxhclxuICogdmFsdWUuXG4gKlxuICogQHBhcmFtIGF0dHJpYiBBdHRyaWJ1dGUgdG8gY2hlY2suXG4gKiBAcGFyYW0gdmFsdWUgQXR0cmlidXRlIHZhbHVlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0byBjaGVjayB3aGV0aGVyIHRoZSBhIG5vZGUgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIGFcbiAqICAgcGFydGljdWxhciB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmliQ2hlY2soYXR0cmliLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuICgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pICYmIHZhbHVlKGVsZW0uYXR0cmlic1thdHRyaWJdKTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiAoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbGVtKSAmJiBlbGVtLmF0dHJpYnNbYXR0cmliXSA9PT0gdmFsdWU7IH07XG59XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHRydWVgIGlmIGVpdGhlciBvZiB0aGUgaW5wdXQgZnVuY3Rpb25zXG4gKiByZXR1cm5zIGB0cnVlYCBmb3IgYSBub2RlLlxuICpcbiAqIEBwYXJhbSBhIEZpcnN0IGZ1bmN0aW9uIHRvIGNvbWJpbmUuXG4gKiBAcGFyYW0gYiBTZWNvbmQgZnVuY3Rpb24gdG8gY29tYmluZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGFraW5nIGEgbm9kZSBhbmQgcmV0dXJuaW5nIGB0cnVlYCBpZiBlaXRoZXIgb2YgdGhlIGlucHV0XG4gKiAgIGZ1bmN0aW9ucyByZXR1cm5zIGB0cnVlYCBmb3IgdGhlIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVGdW5jcyhhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBhKGVsZW0pIHx8IGIoZWxlbSk7IH07XG59XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFsbCBjaGVja3MgaW4gYG9wdGlvbnNgIGFuZCByZXR1cm5zIGB0cnVlYFxuICogaWYgYW55IG9mIHRoZW0gbWF0Y2ggYSBub2RlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCBkZXNjcmliaW5nIG5vZGVzIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFsbCBjaGVja3MgaW4gYG9wdGlvbnNgIGFuZCByZXR1cm5zIGB0cnVlYFxuICogICBpZiBhbnkgb2YgdGhlbSBtYXRjaCBhIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVUZXN0KG9wdGlvbnMpIHtcbiAgICB2YXIgZnVuY3MgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQ2hlY2tzLCBrZXkpXG4gICAgICAgICAgICA/IENoZWNrc1trZXldKHZhbHVlKVxuICAgICAgICAgICAgOiBnZXRBdHRyaWJDaGVjayhrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3MubGVuZ3RoID09PSAwID8gbnVsbCA6IGZ1bmNzLnJlZHVjZShjb21iaW5lRnVuY3MpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIG5vZGUgbWF0Y2hlcyB0aGUgZGVzY3JpcHRpb24gaW4gYG9wdGlvbnNgLlxuICpcbiAqIEBjYXRlZ29yeSBMZWdhY3kgUXVlcnkgRnVuY3Rpb25zXG4gKiBAcGFyYW0gb3B0aW9ucyBBbiBvYmplY3QgZGVzY3JpYmluZyBub2RlcyB0byBsb29rIGZvci5cbiAqIEBwYXJhbSBub2RlIFRoZSBlbGVtZW50IHRvIHRlc3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhlIGRlc2NyaXB0aW9uIGluIGBvcHRpb25zYC5cbiAqL1xuZnVuY3Rpb24gdGVzdEVsZW1lbnQob3B0aW9ucywgbm9kZSkge1xuICAgIHZhciB0ZXN0ID0gY29tcGlsZVRlc3Qob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRlc3QgPyB0ZXN0KG5vZGUpIDogdHJ1ZTtcbn1cbmV4cG9ydHMudGVzdEVsZW1lbnQgPSB0ZXN0RWxlbWVudDtcbi8qKlxuICogUmV0dXJucyBhbGwgbm9kZXMgdGhhdCBtYXRjaCBgb3B0aW9uc2AuXG4gKlxuICogQGNhdGVnb3J5IExlZ2FjeSBRdWVyeSBGdW5jdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCBkZXNjcmliaW5nIG5vZGVzIHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIG5vZGVzIE5vZGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBBbGwgbm9kZXMgdGhhdCBtYXRjaCBgb3B0aW9uc2AuXG4gKi9cbmZ1bmN0aW9uIGdldEVsZW1lbnRzKG9wdGlvbnMsIG5vZGVzLCByZWN1cnNlLCBsaW1pdCkge1xuICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gSW5maW5pdHk7IH1cbiAgICB2YXIgdGVzdCA9IGNvbXBpbGVUZXN0KG9wdGlvbnMpO1xuICAgIHJldHVybiB0ZXN0ID8gKDAsIHF1ZXJ5aW5nX2pzXzEuZmlsdGVyKSh0ZXN0LCBub2RlcywgcmVjdXJzZSwgbGltaXQpIDogW107XG59XG5leHBvcnRzLmdldEVsZW1lbnRzID0gZ2V0RWxlbWVudHM7XG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gKlxuICogQGNhdGVnb3J5IExlZ2FjeSBRdWVyeSBGdW5jdGlvbnNcbiAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIElEIGF0dHJpYnV0ZSB2YWx1ZSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSBub2RlcyBOb2RlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQsIG5vZGVzLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpXG4gICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICByZXR1cm4gKDAsIHF1ZXJ5aW5nX2pzXzEuZmluZE9uZSkoZ2V0QXR0cmliQ2hlY2soXCJpZFwiLCBpZCksIG5vZGVzLCByZWN1cnNlKTtcbn1cbmV4cG9ydHMuZ2V0RWxlbWVudEJ5SWQgPSBnZXRFbGVtZW50QnlJZDtcbi8qKlxuICogUmV0dXJucyBhbGwgbm9kZXMgd2l0aCB0aGUgc3VwcGxpZWQgYHRhZ05hbWVgLlxuICpcbiAqIEBjYXRlZ29yeSBMZWdhY3kgUXVlcnkgRnVuY3Rpb25zXG4gKiBAcGFyYW0gdGFnTmFtZSBUYWcgbmFtZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIG5vZGVzIE5vZGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBBbGwgbm9kZXMgd2l0aCB0aGUgc3VwcGxpZWQgYHRhZ05hbWVgLlxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lLCBub2RlcywgcmVjdXJzZSwgbGltaXQpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIHJldHVybiAoMCwgcXVlcnlpbmdfanNfMS5maWx0ZXIpKENoZWNrc1tcInRhZ19uYW1lXCJdKHRhZ05hbWUpLCBub2RlcywgcmVjdXJzZSwgbGltaXQpO1xufVxuZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGdldEVsZW1lbnRzQnlUYWdOYW1lO1xuLyoqXG4gKiBSZXR1cm5zIGFsbCBub2RlcyB3aXRoIHRoZSBzdXBwbGllZCBgdHlwZWAuXG4gKlxuICogQGNhdGVnb3J5IExlZ2FjeSBRdWVyeSBGdW5jdGlvbnNcbiAqIEBwYXJhbSB0eXBlIEVsZW1lbnQgdHlwZSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSBub2RlcyBOb2RlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0gbGltaXQgTWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgQWxsIG5vZGVzIHdpdGggdGhlIHN1cHBsaWVkIGB0eXBlYC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVRhZ1R5cGUodHlwZSwgbm9kZXMsIHJlY3Vyc2UsIGxpbWl0KSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gSW5maW5pdHk7IH1cbiAgICByZXR1cm4gKDAsIHF1ZXJ5aW5nX2pzXzEuZmlsdGVyKShDaGVja3NbXCJ0YWdfdHlwZVwiXSh0eXBlKSwgbm9kZXMsIHJlY3Vyc2UsIGxpbWl0KTtcbn1cbmV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ1R5cGUgPSBnZXRFbGVtZW50c0J5VGFnVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlZ2FjeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJlcGVuZCA9IGV4cG9ydHMucHJlcGVuZENoaWxkID0gZXhwb3J0cy5hcHBlbmQgPSBleHBvcnRzLmFwcGVuZENoaWxkID0gZXhwb3J0cy5yZXBsYWNlRWxlbWVudCA9IGV4cG9ydHMucmVtb3ZlRWxlbWVudCA9IHZvaWQgMDtcbi8qKlxuICogUmVtb3ZlIGFuIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gYmUgcmVtb3ZlZFxuICovXG5mdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW0pIHtcbiAgICBpZiAoZWxlbS5wcmV2KVxuICAgICAgICBlbGVtLnByZXYubmV4dCA9IGVsZW0ubmV4dDtcbiAgICBpZiAoZWxlbS5uZXh0KVxuICAgICAgICBlbGVtLm5leHQucHJldiA9IGVsZW0ucHJldjtcbiAgICBpZiAoZWxlbS5wYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkcyA9IGVsZW0ucGFyZW50LmNoaWxkcmVuO1xuICAgICAgICB2YXIgY2hpbGRzSW5kZXggPSBjaGlsZHMubGFzdEluZGV4T2YoZWxlbSk7XG4gICAgICAgIGlmIChjaGlsZHNJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBjaGlsZHMuc3BsaWNlKGNoaWxkc0luZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtLm5leHQgPSBudWxsO1xuICAgIGVsZW0ucHJldiA9IG51bGw7XG4gICAgZWxlbS5wYXJlbnQgPSBudWxsO1xufVxuZXhwb3J0cy5yZW1vdmVFbGVtZW50ID0gcmVtb3ZlRWxlbWVudDtcbi8qKlxuICogUmVwbGFjZSBhbiBlbGVtZW50IGluIHRoZSBkb21cbiAqXG4gKiBAY2F0ZWdvcnkgTWFuaXB1bGF0aW9uXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBiZSByZXBsYWNlZFxuICogQHBhcmFtIHJlcGxhY2VtZW50IFRoZSBlbGVtZW50IHRvIGJlIGFkZGVkXG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VFbGVtZW50KGVsZW0sIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHByZXYgPSAocmVwbGFjZW1lbnQucHJldiA9IGVsZW0ucHJldik7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgICAgcHJldi5uZXh0ID0gcmVwbGFjZW1lbnQ7XG4gICAgfVxuICAgIHZhciBuZXh0ID0gKHJlcGxhY2VtZW50Lm5leHQgPSBlbGVtLm5leHQpO1xuICAgIGlmIChuZXh0KSB7XG4gICAgICAgIG5leHQucHJldiA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gKHJlcGxhY2VtZW50LnBhcmVudCA9IGVsZW0ucGFyZW50KTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZHMgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNoaWxkc1tjaGlsZHMubGFzdEluZGV4T2YoZWxlbSldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIGVsZW0ucGFyZW50ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLnJlcGxhY2VFbGVtZW50ID0gcmVwbGFjZUVsZW1lbnQ7XG4vKipcbiAqIEFwcGVuZCBhIGNoaWxkIHRvIGFuIGVsZW1lbnQuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQHBhcmFtIHBhcmVudCBUaGUgZWxlbWVudCB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0gY2hpbGQgVGhlIGVsZW1lbnQgdG8gYmUgYWRkZWQgYXMgYSBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50LCBjaGlsZCkge1xuICAgIHJlbW92ZUVsZW1lbnQoY2hpbGQpO1xuICAgIGNoaWxkLm5leHQgPSBudWxsO1xuICAgIGNoaWxkLnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAocGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpID4gMSkge1xuICAgICAgICB2YXIgc2libGluZyA9IHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMl07XG4gICAgICAgIHNpYmxpbmcubmV4dCA9IGNoaWxkO1xuICAgICAgICBjaGlsZC5wcmV2ID0gc2libGluZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoaWxkLnByZXYgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuYXBwZW5kQ2hpbGQgPSBhcHBlbmRDaGlsZDtcbi8qKlxuICogQXBwZW5kIGFuIGVsZW1lbnQgYWZ0ZXIgYW5vdGhlci5cbiAqXG4gKiBAY2F0ZWdvcnkgTWFuaXB1bGF0aW9uXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBhcHBlbmQgYWZ0ZXIuXG4gKiBAcGFyYW0gbmV4dCBUaGUgZWxlbWVudCBiZSBhZGRlZC5cbiAqL1xuZnVuY3Rpb24gYXBwZW5kKGVsZW0sIG5leHQpIHtcbiAgICByZW1vdmVFbGVtZW50KG5leHQpO1xuICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudDtcbiAgICB2YXIgY3Vyck5leHQgPSBlbGVtLm5leHQ7XG4gICAgbmV4dC5uZXh0ID0gY3Vyck5leHQ7XG4gICAgbmV4dC5wcmV2ID0gZWxlbTtcbiAgICBlbGVtLm5leHQgPSBuZXh0O1xuICAgIG5leHQucGFyZW50ID0gcGFyZW50O1xuICAgIGlmIChjdXJyTmV4dCkge1xuICAgICAgICBjdXJyTmV4dC5wcmV2ID0gbmV4dDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcyA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgIGNoaWxkcy5zcGxpY2UoY2hpbGRzLmxhc3RJbmRleE9mKGN1cnJOZXh0KSwgMCwgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5leHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXBwZW5kID0gYXBwZW5kO1xuLyoqXG4gKiBQcmVwZW5kIGEgY2hpbGQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgTWFuaXB1bGF0aW9uXG4gKiBAcGFyYW0gcGFyZW50IFRoZSBlbGVtZW50IHRvIHByZXBlbmQgYmVmb3JlLlxuICogQHBhcmFtIGNoaWxkIFRoZSBlbGVtZW50IHRvIGJlIGFkZGVkIGFzIGEgY2hpbGQuXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgcmVtb3ZlRWxlbWVudChjaGlsZCk7XG4gICAgY2hpbGQucGFyZW50ID0gcGFyZW50O1xuICAgIGNoaWxkLnByZXYgPSBudWxsO1xuICAgIGlmIChwYXJlbnQuY2hpbGRyZW4udW5zaGlmdChjaGlsZCkgIT09IDEpIHtcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBwYXJlbnQuY2hpbGRyZW5bMV07XG4gICAgICAgIHNpYmxpbmcucHJldiA9IGNoaWxkO1xuICAgICAgICBjaGlsZC5uZXh0ID0gc2libGluZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoaWxkLm5leHQgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMucHJlcGVuZENoaWxkID0gcHJlcGVuZENoaWxkO1xuLyoqXG4gKiBQcmVwZW5kIGFuIGVsZW1lbnQgYmVmb3JlIGFub3RoZXIuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gcHJlcGVuZCBiZWZvcmUuXG4gKiBAcGFyYW0gcHJldiBUaGUgZWxlbWVudCBiZSBhZGRlZC5cbiAqL1xuZnVuY3Rpb24gcHJlcGVuZChlbGVtLCBwcmV2KSB7XG4gICAgcmVtb3ZlRWxlbWVudChwcmV2KTtcbiAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGRzID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjaGlsZHMuc3BsaWNlKGNoaWxkcy5pbmRleE9mKGVsZW0pLCAwLCBwcmV2KTtcbiAgICB9XG4gICAgaWYgKGVsZW0ucHJldikge1xuICAgICAgICBlbGVtLnByZXYubmV4dCA9IHByZXY7XG4gICAgfVxuICAgIHByZXYucGFyZW50ID0gcGFyZW50O1xuICAgIHByZXYucHJldiA9IGVsZW0ucHJldjtcbiAgICBwcmV2Lm5leHQgPSBlbGVtO1xuICAgIGVsZW0ucHJldiA9IHByZXY7XG59XG5leHBvcnRzLnByZXBlbmQgPSBwcmVwZW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFuaXB1bGF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5maW5kQWxsID0gZXhwb3J0cy5leGlzdHNPbmUgPSBleHBvcnRzLmZpbmRPbmUgPSBleHBvcnRzLmZpbmRPbmVDaGlsZCA9IGV4cG9ydHMuZmluZCA9IGV4cG9ydHMuZmlsdGVyID0gdm9pZCAwO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xuLyoqXG4gKiBTZWFyY2ggYSBub2RlIGFuZCBpdHMgY2hpbGRyZW4gZm9yIG5vZGVzIHBhc3NpbmcgYSB0ZXN0IGZ1bmN0aW9uLiBJZiBgbm9kZWAgaXMgbm90IGFuIGFycmF5LCBpdCB3aWxsIGJlIHdyYXBwZWQgaW4gb25lLlxuICpcbiAqIEBjYXRlZ29yeSBRdWVyeWluZ1xuICogQHBhcmFtIHRlc3QgRnVuY3Rpb24gdG8gdGVzdCBub2RlcyBvbi5cbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gc2VhcmNoLiBXaWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgc2V0IGlmIGl0IG1hdGNoZXMuXG4gKiBAcGFyYW0gcmVjdXJzZSBBbHNvIGNvbnNpZGVyIGNoaWxkIG5vZGVzLlxuICogQHBhcmFtIGxpbWl0IE1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIHJldHVybi5cbiAqIEByZXR1cm5zIEFsbCBub2RlcyBwYXNzaW5nIGB0ZXN0YC5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKHRlc3QsIG5vZGUsIHJlY3Vyc2UsIGxpbWl0KSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gSW5maW5pdHk7IH1cbiAgICByZXR1cm4gZmluZCh0ZXN0LCBBcnJheS5pc0FycmF5KG5vZGUpID8gbm9kZSA6IFtub2RlXSwgcmVjdXJzZSwgbGltaXQpO1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG4vKipcbiAqIFNlYXJjaCBhbiBhcnJheSBvZiBub2RlcyBhbmQgdGhlaXIgY2hpbGRyZW4gZm9yIG5vZGVzIHBhc3NpbmcgYSB0ZXN0IGZ1bmN0aW9uLlxuICpcbiAqIEBjYXRlZ29yeSBRdWVyeWluZ1xuICogQHBhcmFtIHRlc3QgRnVuY3Rpb24gdG8gdGVzdCBub2RlcyBvbi5cbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0byBzZWFyY2guXG4gKiBAcGFyYW0gcmVjdXJzZSBBbHNvIGNvbnNpZGVyIGNoaWxkIG5vZGVzLlxuICogQHBhcmFtIGxpbWl0IE1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIHJldHVybi5cbiAqIEByZXR1cm5zIEFsbCBub2RlcyBwYXNzaW5nIGB0ZXN0YC5cbiAqL1xuZnVuY3Rpb24gZmluZCh0ZXN0LCBub2RlcywgcmVjdXJzZSwgbGltaXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgLyoqIFN0YWNrIG9mIHRoZSBhcnJheXMgd2UgYXJlIGxvb2tpbmcgYXQuICovXG4gICAgdmFyIG5vZGVTdGFjayA9IFtub2Rlc107XG4gICAgLyoqIFN0YWNrIG9mIHRoZSBpbmRpY2VzIHdpdGhpbiB0aGUgYXJyYXlzLiAqL1xuICAgIHZhciBpbmRleFN0YWNrID0gWzBdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSBjdXJyZW50IGFycmF5IGhhcyBhbnkgbW9yZSBlbGVtZW50cyB0byBsb29rIGF0LlxuICAgICAgICBpZiAoaW5kZXhTdGFja1swXSA+PSBub2RlU3RhY2tbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIG1vcmUgYXJyYXlzIHRvIGxvb2sgYXQsIHdlIGFyZSBkb25lLlxuICAgICAgICAgICAgaWYgKGluZGV4U3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcmVtb3ZlIHRoZSBjdXJyZW50IGFycmF5IGZyb20gdGhlIHN0YWNrLlxuICAgICAgICAgICAgbm9kZVN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICBpbmRleFN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAvLyBMb29wIGJhY2sgdG8gdGhlIHN0YXJ0IHRvIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgYXJyYXkuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbSA9IG5vZGVTdGFja1swXVtpbmRleFN0YWNrWzBdKytdO1xuICAgICAgICBpZiAodGVzdChlbGVtKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbSk7XG4gICAgICAgICAgICBpZiAoLS1saW1pdCA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY3Vyc2UgJiYgKDAsIGRvbWhhbmRsZXJfMS5oYXNDaGlsZHJlbikoZWxlbSkgJiYgZWxlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQWRkIHRoZSBjaGlsZHJlbiB0byB0aGUgc3RhY2suIFdlIGFyZSBkZXB0aC1maXJzdCwgc28gdGhpcyBpc1xuICAgICAgICAgICAgICogdGhlIG5leHQgYXJyYXkgd2UgbG9vayBhdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5kZXhTdGFjay51bnNoaWZ0KDApO1xuICAgICAgICAgICAgbm9kZVN0YWNrLnVuc2hpZnQoZWxlbS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgZWxlbWVudCBpbnNpZGUgb2YgYW4gYXJyYXkgdGhhdCBtYXRjaGVzIGEgdGVzdCBmdW5jdGlvbi4gVGhpcyBpcyBhbiBhbGlhcyBmb3IgYEFycmF5LnByb3RvdHlwZS5maW5kYC5cbiAqXG4gKiBAY2F0ZWdvcnkgUXVlcnlpbmdcbiAqIEBwYXJhbSB0ZXN0IEZ1bmN0aW9uIHRvIHRlc3Qgbm9kZXMgb24uXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdG8gc2VhcmNoLlxuICogQHJldHVybnMgVGhlIGZpcnN0IG5vZGUgaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIGB0ZXN0YC5cbiAqIEBkZXByZWNhdGVkIFVzZSBgQXJyYXkucHJvdG90eXBlLmZpbmRgIGRpcmVjdGx5LlxuICovXG5mdW5jdGlvbiBmaW5kT25lQ2hpbGQodGVzdCwgbm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMuZmluZCh0ZXN0KTtcbn1cbmV4cG9ydHMuZmluZE9uZUNoaWxkID0gZmluZE9uZUNoaWxkO1xuLyoqXG4gKiBGaW5kcyBvbmUgZWxlbWVudCBpbiBhIHRyZWUgdGhhdCBwYXNzZXMgYSB0ZXN0LlxuICpcbiAqIEBjYXRlZ29yeSBRdWVyeWluZ1xuICogQHBhcmFtIHRlc3QgRnVuY3Rpb24gdG8gdGVzdCBub2RlcyBvbi5cbiAqIEBwYXJhbSBub2RlcyBOb2RlIG9yIGFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgbm9kZSB0aGF0IHBhc3NlcyBgdGVzdGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmRPbmUodGVzdCwgbm9kZXMsIHJlY3Vyc2UpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgdmFyIGVsZW0gPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoICYmICFlbGVtOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKCEoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShub2RlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGVzdChub2RlKSkge1xuICAgICAgICAgICAgZWxlbSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVjdXJzZSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVsZW0gPSBmaW5kT25lKHRlc3QsIG5vZGUuY2hpbGRyZW4sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtO1xufVxuZXhwb3J0cy5maW5kT25lID0gZmluZE9uZTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdHJlZSBvZiBub2RlcyBjb250YWlucyBhdCBsZWFzdCBvbmUgbm9kZSBwYXNzaW5nIGEgdGVzdC5cbiAqXG4gKiBAY2F0ZWdvcnkgUXVlcnlpbmdcbiAqIEBwYXJhbSB0ZXN0IEZ1bmN0aW9uIHRvIHRlc3Qgbm9kZXMgb24uXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdG8gc2VhcmNoLlxuICogQHJldHVybnMgV2hldGhlciBhIHRyZWUgb2Ygbm9kZXMgY29udGFpbnMgYXQgbGVhc3Qgb25lIG5vZGUgcGFzc2luZyB0aGUgdGVzdC5cbiAqL1xuZnVuY3Rpb24gZXhpc3RzT25lKHRlc3QsIG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLnNvbWUoZnVuY3Rpb24gKGNoZWNrZWQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGNoZWNrZWQpICYmXG4gICAgICAgICAgICAodGVzdChjaGVja2VkKSB8fCBleGlzdHNPbmUodGVzdCwgY2hlY2tlZC5jaGlsZHJlbikpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5leGlzdHNPbmUgPSBleGlzdHNPbmU7XG4vKipcbiAqIFNlYXJjaCBhbiBhcnJheSBvZiBub2RlcyBhbmQgdGhlaXIgY2hpbGRyZW4gZm9yIGVsZW1lbnRzIHBhc3NpbmcgYSB0ZXN0IGZ1bmN0aW9uLlxuICpcbiAqIFNhbWUgYXMgYGZpbmRgLCBidXQgbGltaXRlZCB0byBlbGVtZW50cyBhbmQgd2l0aCBsZXNzIG9wdGlvbnMsIGxlYWRpbmcgdG8gcmVkdWNlZCBjb21wbGV4aXR5LlxuICpcbiAqIEBjYXRlZ29yeSBRdWVyeWluZ1xuICogQHBhcmFtIHRlc3QgRnVuY3Rpb24gdG8gdGVzdCBub2RlcyBvbi5cbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0byBzZWFyY2guXG4gKiBAcmV0dXJucyBBbGwgbm9kZXMgcGFzc2luZyBgdGVzdGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmRBbGwodGVzdCwgbm9kZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG5vZGVTdGFjayA9IFtub2Rlc107XG4gICAgdmFyIGluZGV4U3RhY2sgPSBbMF07XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoaW5kZXhTdGFja1swXSA+PSBub2RlU3RhY2tbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHJlbW92ZSB0aGUgY3VycmVudCBhcnJheSBmcm9tIHRoZSBzdGFjay5cbiAgICAgICAgICAgIG5vZGVTdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgaW5kZXhTdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgLy8gTG9vcCBiYWNrIHRvIHRoZSBzdGFydCB0byBjb250aW51ZSB3aXRoIHRoZSBuZXh0IGFycmF5LlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW0gPSBub2RlU3RhY2tbMF1baW5kZXhTdGFja1swXSsrXTtcbiAgICAgICAgaWYgKCEoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbGVtKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodGVzdChlbGVtKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW0pO1xuICAgICAgICBpZiAoZWxlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbmRleFN0YWNrLnVuc2hpZnQoMCk7XG4gICAgICAgICAgICBub2RlU3RhY2sudW5zaGlmdChlbGVtLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZmluZEFsbCA9IGZpbmRBbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeWluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5uZXJUZXh0ID0gZXhwb3J0cy50ZXh0Q29udGVudCA9IGV4cG9ydHMuZ2V0VGV4dCA9IGV4cG9ydHMuZ2V0SW5uZXJIVE1MID0gZXhwb3J0cy5nZXRPdXRlckhUTUwgPSB2b2lkIDA7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcImRvbWhhbmRsZXJcIik7XG52YXIgZG9tX3NlcmlhbGl6ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG9tLXNlcmlhbGl6ZXJcIikpO1xudmFyIGRvbWVsZW1lbnR0eXBlXzEgPSByZXF1aXJlKFwiZG9tZWxlbWVudHR5cGVcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBTdHJpbmdpZnlcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYGRvbS1zZXJpYWxpemVyYCBtb2R1bGUgZGlyZWN0bHkuXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGdldCB0aGUgb3V0ZXIgSFRNTCBvZi5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHNlcmlhbGl6YXRpb24uXG4gKiBAcmV0dXJucyBgbm9kZWAncyBvdXRlciBIVE1MLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgZG9tX3NlcmlhbGl6ZXJfMS5kZWZhdWx0KShub2RlLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2V0T3V0ZXJIVE1MID0gZ2V0T3V0ZXJIVE1MO1xuLyoqXG4gKiBAY2F0ZWdvcnkgU3RyaW5naWZ5XG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBkb20tc2VyaWFsaXplcmAgbW9kdWxlIGRpcmVjdGx5LlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBnZXQgdGhlIGlubmVyIEhUTUwgb2YuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBzZXJpYWxpemF0aW9uLlxuICogQHJldHVybnMgYG5vZGVgJ3MgaW5uZXIgSFRNTC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5uZXJIVE1MKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIGRvbWhhbmRsZXJfMS5oYXNDaGlsZHJlbikobm9kZSlcbiAgICAgICAgPyBub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gZ2V0T3V0ZXJIVE1MKG5vZGUsIG9wdGlvbnMpOyB9KS5qb2luKFwiXCIpXG4gICAgICAgIDogXCJcIjtcbn1cbmV4cG9ydHMuZ2V0SW5uZXJIVE1MID0gZ2V0SW5uZXJIVE1MO1xuLyoqXG4gKiBHZXQgYSBub2RlJ3MgaW5uZXIgdGV4dC4gU2FtZSBhcyBgdGV4dENvbnRlbnRgLCBidXQgaW5zZXJ0cyBuZXdsaW5lcyBmb3IgYDxicj5gIHRhZ3MuIElnbm9yZXMgY29tbWVudHMuXG4gKlxuICogQGNhdGVnb3J5IFN0cmluZ2lmeVxuICogQGRlcHJlY2F0ZWQgVXNlIGB0ZXh0Q29udGVudGAgaW5zdGVhZC5cbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gZ2V0IHRoZSBpbm5lciB0ZXh0IG9mLlxuICogQHJldHVybnMgYG5vZGVgJ3MgaW5uZXIgdGV4dC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dChub2RlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlLm1hcChnZXRUZXh0KS5qb2luKFwiXCIpO1xuICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShub2RlKSlcbiAgICAgICAgcmV0dXJuIG5vZGUubmFtZSA9PT0gXCJiclwiID8gXCJcXG5cIiA6IGdldFRleHQobm9kZS5jaGlsZHJlbik7XG4gICAgaWYgKCgwLCBkb21oYW5kbGVyXzEuaXNDREFUQSkobm9kZSkpXG4gICAgICAgIHJldHVybiBnZXRUZXh0KG5vZGUuY2hpbGRyZW4pO1xuICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmlzVGV4dCkobm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlLmRhdGE7XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnRzLmdldFRleHQgPSBnZXRUZXh0O1xuLyoqXG4gKiBHZXQgYSBub2RlJ3MgdGV4dCBjb250ZW50LiBJZ25vcmVzIGNvbW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBTdHJpbmdpZnlcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gZ2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YuXG4gKiBAcmV0dXJucyBgbm9kZWAncyB0ZXh0IGNvbnRlbnQuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS90ZXh0Q29udGVudH1cbiAqL1xuZnVuY3Rpb24gdGV4dENvbnRlbnQobm9kZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5tYXAodGV4dENvbnRlbnQpLmpvaW4oXCJcIik7XG4gICAgaWYgKCgwLCBkb21oYW5kbGVyXzEuaGFzQ2hpbGRyZW4pKG5vZGUpICYmICEoMCwgZG9taGFuZGxlcl8xLmlzQ29tbWVudCkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb250ZW50KG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc1RleHQpKG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5kYXRhO1xuICAgIHJldHVybiBcIlwiO1xufVxuZXhwb3J0cy50ZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xuLyoqXG4gKiBHZXQgYSBub2RlJ3MgaW5uZXIgdGV4dCwgaWdub3JpbmcgYDxzY3JpcHQ+YCBhbmQgYDxzdHlsZT5gIHRhZ3MuIElnbm9yZXMgY29tbWVudHMuXG4gKlxuICogQGNhdGVnb3J5IFN0cmluZ2lmeVxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBnZXQgdGhlIGlubmVyIHRleHQgb2YuXG4gKiBAcmV0dXJucyBgbm9kZWAncyBpbm5lciB0ZXh0LlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvaW5uZXJUZXh0fVxuICovXG5mdW5jdGlvbiBpbm5lclRleHQobm9kZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5tYXAoaW5uZXJUZXh0KS5qb2luKFwiXCIpO1xuICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShub2RlKSAmJiAobm9kZS50eXBlID09PSBkb21lbGVtZW50dHlwZV8xLkVsZW1lbnRUeXBlLlRhZyB8fCAoMCwgZG9taGFuZGxlcl8xLmlzQ0RBVEEpKG5vZGUpKSkge1xuICAgICAgICByZXR1cm4gaW5uZXJUZXh0KG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc1RleHQpKG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5kYXRhO1xuICAgIHJldHVybiBcIlwiO1xufVxuZXhwb3J0cy5pbm5lclRleHQgPSBpbm5lclRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdpZnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByZXZFbGVtZW50U2libGluZyA9IGV4cG9ydHMubmV4dEVsZW1lbnRTaWJsaW5nID0gZXhwb3J0cy5nZXROYW1lID0gZXhwb3J0cy5oYXNBdHRyaWIgPSBleHBvcnRzLmdldEF0dHJpYnV0ZVZhbHVlID0gZXhwb3J0cy5nZXRTaWJsaW5ncyA9IGV4cG9ydHMuZ2V0UGFyZW50ID0gZXhwb3J0cy5nZXRDaGlsZHJlbiA9IHZvaWQgMDtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcbi8qKlxuICogR2V0IGEgbm9kZSdzIGNoaWxkcmVuLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzYWxcbiAqIEBwYXJhbSBlbGVtIE5vZGUgdG8gZ2V0IHRoZSBjaGlsZHJlbiBvZi5cbiAqIEByZXR1cm5zIGBlbGVtYCdzIGNoaWxkcmVuLCBvciBhbiBlbXB0eSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oZWxlbSkge1xuICAgIHJldHVybiAoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShlbGVtKSA/IGVsZW0uY2hpbGRyZW4gOiBbXTtcbn1cbmV4cG9ydHMuZ2V0Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbjtcbi8qKlxuICogR2V0IGEgbm9kZSdzIHBhcmVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2FsXG4gKiBAcGFyYW0gZWxlbSBOb2RlIHRvIGdldCB0aGUgcGFyZW50IG9mLlxuICogQHJldHVybnMgYGVsZW1gJ3MgcGFyZW50IG5vZGUsIG9yIGBudWxsYCBpZiBgZWxlbWAgaXMgYSByb290IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0ucGFyZW50IHx8IG51bGw7XG59XG5leHBvcnRzLmdldFBhcmVudCA9IGdldFBhcmVudDtcbi8qKlxuICogR2V0cyBhbiBlbGVtZW50cyBzaWJsaW5ncywgaW5jbHVkaW5nIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBBdHRlbXB0cyB0byBnZXQgdGhlIGNoaWxkcmVuIHRocm91Z2ggdGhlIGVsZW1lbnQncyBwYXJlbnQgZmlyc3QuIElmIHdlIGRvbid0XG4gKiBoYXZlIGEgcGFyZW50ICh0aGUgZWxlbWVudCBpcyBhIHJvb3Qgbm9kZSksIHdlIHdhbGsgdGhlIGVsZW1lbnQncyBgcHJldmAgJlxuICogYG5leHRgIHRvIGdldCBhbGwgcmVtYWluaW5nIG5vZGVzLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzYWxcbiAqIEBwYXJhbSBlbGVtIEVsZW1lbnQgdG8gZ2V0IHRoZSBzaWJsaW5ncyBvZi5cbiAqIEByZXR1cm5zIGBlbGVtYCdzIHNpYmxpbmdzLCBpbmNsdWRpbmcgYGVsZW1gLlxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5ncyhlbGVtKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGVsZW0pO1xuICAgIGlmIChwYXJlbnQgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHBhcmVudCk7XG4gICAgdmFyIHNpYmxpbmdzID0gW2VsZW1dO1xuICAgIHZhciBwcmV2ID0gZWxlbS5wcmV2LCBuZXh0ID0gZWxlbS5uZXh0O1xuICAgIHdoaWxlIChwcmV2ICE9IG51bGwpIHtcbiAgICAgICAgc2libGluZ3MudW5zaGlmdChwcmV2KTtcbiAgICAgICAgKF9hID0gcHJldiwgcHJldiA9IF9hLnByZXYpO1xuICAgIH1cbiAgICB3aGlsZSAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNpYmxpbmdzLnB1c2gobmV4dCk7XG4gICAgICAgIChfYiA9IG5leHQsIG5leHQgPSBfYi5uZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpYmxpbmdzO1xufVxuZXhwb3J0cy5nZXRTaWJsaW5ncyA9IGdldFNpYmxpbmdzO1xuLyoqXG4gKiBHZXRzIGFuIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNhbFxuICogQHBhcmFtIGVsZW0gRWxlbWVudCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIEF0dHJpYnV0ZSBuYW1lIHRvIHJldHJpZXZlLlxuICogQHJldHVybnMgVGhlIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWUsIG9yIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBlbGVtLmF0dHJpYnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtuYW1lXTtcbn1cbmV4cG9ydHMuZ2V0QXR0cmlidXRlVmFsdWUgPSBnZXRBdHRyaWJ1dGVWYWx1ZTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBoYXMgYW4gYXR0cmlidXRlLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzYWxcbiAqIEBwYXJhbSBlbGVtIEVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcGFyYW0gbmFtZSBBdHRyaWJ1dGUgbmFtZSB0byBsb29rIGZvci5cbiAqIEByZXR1cm5zIFJldHVybnMgd2hldGhlciBgZWxlbWAgaGFzIHRoZSBhdHRyaWJ1dGUgYG5hbWVgLlxuICovXG5mdW5jdGlvbiBoYXNBdHRyaWIoZWxlbSwgbmFtZSkge1xuICAgIHJldHVybiAoZWxlbS5hdHRyaWJzICE9IG51bGwgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW0uYXR0cmlicywgbmFtZSkgJiZcbiAgICAgICAgZWxlbS5hdHRyaWJzW25hbWVdICE9IG51bGwpO1xufVxuZXhwb3J0cy5oYXNBdHRyaWIgPSBoYXNBdHRyaWI7XG4vKipcbiAqIEdldCB0aGUgdGFnIG5hbWUgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2FsXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIG5hbWUgZm9yLlxuICogQHJldHVybnMgVGhlIHRhZyBuYW1lIG9mIGBlbGVtYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZShlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0ubmFtZTtcbn1cbmV4cG9ydHMuZ2V0TmFtZSA9IGdldE5hbWU7XG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgZWxlbWVudCBzaWJsaW5nIG9mIGEgbm9kZS5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2FsXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIG5leHQgc2libGluZyBvZi5cbiAqIEByZXR1cm5zIGBlbGVtYCdzIG5leHQgc2libGluZyB0aGF0IGlzIGEgdGFnLCBvciBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gbmV4dFxuICogc2libGluZy5cbiAqL1xuZnVuY3Rpb24gbmV4dEVsZW1lbnRTaWJsaW5nKGVsZW0pIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIG5leHQgPSBlbGVtLm5leHQ7XG4gICAgd2hpbGUgKG5leHQgIT09IG51bGwgJiYgISgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKG5leHQpKVxuICAgICAgICAoX2EgPSBuZXh0LCBuZXh0ID0gX2EubmV4dCk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5leHBvcnRzLm5leHRFbGVtZW50U2libGluZyA9IG5leHRFbGVtZW50U2libGluZztcbi8qKlxuICogUmV0dXJucyB0aGUgcHJldmlvdXMgZWxlbWVudCBzaWJsaW5nIG9mIGEgbm9kZS5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2FsXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YuXG4gKiBAcmV0dXJucyBgZWxlbWAncyBwcmV2aW91cyBzaWJsaW5nIHRoYXQgaXMgYSB0YWcsIG9yIGBudWxsYCBpZiB0aGVyZSBpcyBub1xuICogcHJldmlvdXMgc2libGluZy5cbiAqL1xuZnVuY3Rpb24gcHJldkVsZW1lbnRTaWJsaW5nKGVsZW0pIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHByZXYgPSBlbGVtLnByZXY7XG4gICAgd2hpbGUgKHByZXYgIT09IG51bGwgJiYgISgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKHByZXYpKVxuICAgICAgICAoX2EgPSBwcmV2LCBwcmV2ID0gX2EucHJldik7XG4gICAgcmV0dXJuIHByZXY7XG59XG5leHBvcnRzLnByZXZFbGVtZW50U2libGluZyA9IHByZXZFbGVtZW50U2libGluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYXZlcnNhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVYTUwgPSBleHBvcnRzLmRlY29kZUhUTUxTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUxBdHRyaWJ1dGUgPSBleHBvcnRzLmRlY29kZUhUTUwgPSBleHBvcnRzLmRldGVybWluZUJyYW5jaCA9IGV4cG9ydHMuRW50aXR5RGVjb2RlciA9IGV4cG9ydHMuRGVjb2RpbmdNb2RlID0gZXhwb3J0cy5CaW5UcmllRmxhZ3MgPSBleHBvcnRzLmZyb21Db2RlUG9pbnQgPSBleHBvcnRzLnJlcGxhY2VDb2RlUG9pbnQgPSBleHBvcnRzLmRlY29kZUNvZGVQb2ludCA9IGV4cG9ydHMueG1sRGVjb2RlVHJlZSA9IGV4cG9ydHMuaHRtbERlY29kZVRyZWUgPSB2b2lkIDA7XG52YXIgZGVjb2RlX2RhdGFfaHRtbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2dlbmVyYXRlZC9kZWNvZGUtZGF0YS1odG1sLmpzXCIpKTtcbmV4cG9ydHMuaHRtbERlY29kZVRyZWUgPSBkZWNvZGVfZGF0YV9odG1sX2pzXzEuZGVmYXVsdDtcbnZhciBkZWNvZGVfZGF0YV94bWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9nZW5lcmF0ZWQvZGVjb2RlLWRhdGEteG1sLmpzXCIpKTtcbmV4cG9ydHMueG1sRGVjb2RlVHJlZSA9IGRlY29kZV9kYXRhX3htbF9qc18xLmRlZmF1bHQ7XG52YXIgZGVjb2RlX2NvZGVwb2ludF9qc18xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2RlY29kZV9jb2RlcG9pbnQuanNcIikpO1xuZXhwb3J0cy5kZWNvZGVDb2RlUG9pbnQgPSBkZWNvZGVfY29kZXBvaW50X2pzXzEuZGVmYXVsdDtcbnZhciBkZWNvZGVfY29kZXBvaW50X2pzXzIgPSByZXF1aXJlKFwiLi9kZWNvZGVfY29kZXBvaW50LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVwbGFjZUNvZGVQb2ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlX2NvZGVwb2ludF9qc18yLnJlcGxhY2VDb2RlUG9pbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tQ29kZVBvaW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfY29kZXBvaW50X2pzXzIuZnJvbUNvZGVQb2ludDsgfSB9KTtcbnZhciBDaGFyQ29kZXM7XG4oZnVuY3Rpb24gKENoYXJDb2Rlcykge1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJOVU1cIl0gPSAzNV0gPSBcIk5VTVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJTRU1JXCJdID0gNTldID0gXCJTRU1JXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkVRVUFMU1wiXSA9IDYxXSA9IFwiRVFVQUxTXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlpFUk9cIl0gPSA0OF0gPSBcIlpFUk9cIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTklORVwiXSA9IDU3XSA9IFwiTklORVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMT1dFUl9BXCJdID0gOTddID0gXCJMT1dFUl9BXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkxPV0VSX0ZcIl0gPSAxMDJdID0gXCJMT1dFUl9GXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkxPV0VSX1hcIl0gPSAxMjBdID0gXCJMT1dFUl9YXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkxPV0VSX1pcIl0gPSAxMjJdID0gXCJMT1dFUl9aXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlVQUEVSX0FcIl0gPSA2NV0gPSBcIlVQUEVSX0FcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiVVBQRVJfRlwiXSA9IDcwXSA9IFwiVVBQRVJfRlwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJVUFBFUl9aXCJdID0gOTBdID0gXCJVUFBFUl9aXCI7XG59KShDaGFyQ29kZXMgfHwgKENoYXJDb2RlcyA9IHt9KSk7XG4vKiogQml0IHRoYXQgbmVlZHMgdG8gYmUgc2V0IHRvIGNvbnZlcnQgYW4gdXBwZXIgY2FzZSBBU0NJSSBjaGFyYWN0ZXIgdG8gbG93ZXIgY2FzZSAqL1xudmFyIFRPX0xPV0VSX0JJVCA9IDMyO1xudmFyIEJpblRyaWVGbGFncztcbihmdW5jdGlvbiAoQmluVHJpZUZsYWdzKSB7XG4gICAgQmluVHJpZUZsYWdzW0JpblRyaWVGbGFnc1tcIlZBTFVFX0xFTkdUSFwiXSA9IDQ5MTUyXSA9IFwiVkFMVUVfTEVOR1RIXCI7XG4gICAgQmluVHJpZUZsYWdzW0JpblRyaWVGbGFnc1tcIkJSQU5DSF9MRU5HVEhcIl0gPSAxNjI1Nl0gPSBcIkJSQU5DSF9MRU5HVEhcIjtcbiAgICBCaW5UcmllRmxhZ3NbQmluVHJpZUZsYWdzW1wiSlVNUF9UQUJMRVwiXSA9IDEyN10gPSBcIkpVTVBfVEFCTEVcIjtcbn0pKEJpblRyaWVGbGFncyA9IGV4cG9ydHMuQmluVHJpZUZsYWdzIHx8IChleHBvcnRzLkJpblRyaWVGbGFncyA9IHt9KSk7XG5mdW5jdGlvbiBpc051bWJlcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gQ2hhckNvZGVzLlpFUk8gJiYgY29kZSA8PSBDaGFyQ29kZXMuTklORTtcbn1cbmZ1bmN0aW9uIGlzSGV4YWRlY2ltYWxDaGFyYWN0ZXIoY29kZSkge1xuICAgIHJldHVybiAoKGNvZGUgPj0gQ2hhckNvZGVzLlVQUEVSX0EgJiYgY29kZSA8PSBDaGFyQ29kZXMuVVBQRVJfRikgfHxcbiAgICAgICAgKGNvZGUgPj0gQ2hhckNvZGVzLkxPV0VSX0EgJiYgY29kZSA8PSBDaGFyQ29kZXMuTE9XRVJfRikpO1xufVxuZnVuY3Rpb24gaXNBc2NpaUFscGhhTnVtZXJpYyhjb2RlKSB7XG4gICAgcmV0dXJuICgoY29kZSA+PSBDaGFyQ29kZXMuVVBQRVJfQSAmJiBjb2RlIDw9IENoYXJDb2Rlcy5VUFBFUl9aKSB8fFxuICAgICAgICAoY29kZSA+PSBDaGFyQ29kZXMuTE9XRVJfQSAmJiBjb2RlIDw9IENoYXJDb2Rlcy5MT1dFUl9aKSB8fFxuICAgICAgICBpc051bWJlcihjb2RlKSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGlzIGEgdmFsaWQgZW5kIGNoYXJhY3RlciBmb3IgYW4gZW50aXR5IGluIGFuIGF0dHJpYnV0ZS5cbiAqXG4gKiBBdHRyaWJ1dGUgdmFsdWVzIHRoYXQgYXJlbid0IHRlcm1pbmF0ZWQgcHJvcGVybHkgYXJlbid0IHBhcnNlZCwgYW5kIHNob3VsZG4ndCBsZWFkIHRvIGEgcGFyc2VyIGVycm9yLlxuICogU2VlIHRoZSBleGFtcGxlIGluIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNuYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlLXN0YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRW50aXR5SW5BdHRyaWJ1dGVJbnZhbGlkRW5kKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gQ2hhckNvZGVzLkVRVUFMUyB8fCBpc0FzY2lpQWxwaGFOdW1lcmljKGNvZGUpO1xufVxudmFyIEVudGl0eURlY29kZXJTdGF0ZTtcbihmdW5jdGlvbiAoRW50aXR5RGVjb2RlclN0YXRlKSB7XG4gICAgRW50aXR5RGVjb2RlclN0YXRlW0VudGl0eURlY29kZXJTdGF0ZVtcIkVudGl0eVN0YXJ0XCJdID0gMF0gPSBcIkVudGl0eVN0YXJ0XCI7XG4gICAgRW50aXR5RGVjb2RlclN0YXRlW0VudGl0eURlY29kZXJTdGF0ZVtcIk51bWVyaWNTdGFydFwiXSA9IDFdID0gXCJOdW1lcmljU3RhcnRcIjtcbiAgICBFbnRpdHlEZWNvZGVyU3RhdGVbRW50aXR5RGVjb2RlclN0YXRlW1wiTnVtZXJpY0RlY2ltYWxcIl0gPSAyXSA9IFwiTnVtZXJpY0RlY2ltYWxcIjtcbiAgICBFbnRpdHlEZWNvZGVyU3RhdGVbRW50aXR5RGVjb2RlclN0YXRlW1wiTnVtZXJpY0hleFwiXSA9IDNdID0gXCJOdW1lcmljSGV4XCI7XG4gICAgRW50aXR5RGVjb2RlclN0YXRlW0VudGl0eURlY29kZXJTdGF0ZVtcIk5hbWVkRW50aXR5XCJdID0gNF0gPSBcIk5hbWVkRW50aXR5XCI7XG59KShFbnRpdHlEZWNvZGVyU3RhdGUgfHwgKEVudGl0eURlY29kZXJTdGF0ZSA9IHt9KSk7XG52YXIgRGVjb2RpbmdNb2RlO1xuKGZ1bmN0aW9uIChEZWNvZGluZ01vZGUpIHtcbiAgICAvKiogRW50aXRpZXMgaW4gdGV4dCBub2RlcyB0aGF0IGNhbiBlbmQgd2l0aCBhbnkgY2hhcmFjdGVyLiAqL1xuICAgIERlY29kaW5nTW9kZVtEZWNvZGluZ01vZGVbXCJMZWdhY3lcIl0gPSAwXSA9IFwiTGVnYWN5XCI7XG4gICAgLyoqIE9ubHkgYWxsb3cgZW50aXRpZXMgdGVybWluYXRlZCB3aXRoIGEgc2VtaWNvbG9uLiAqL1xuICAgIERlY29kaW5nTW9kZVtEZWNvZGluZ01vZGVbXCJTdHJpY3RcIl0gPSAxXSA9IFwiU3RyaWN0XCI7XG4gICAgLyoqIEVudGl0aWVzIGluIGF0dHJpYnV0ZXMgaGF2ZSBsaW1pdGF0aW9ucyBvbiBlbmRpbmcgY2hhcmFjdGVycy4gKi9cbiAgICBEZWNvZGluZ01vZGVbRGVjb2RpbmdNb2RlW1wiQXR0cmlidXRlXCJdID0gMl0gPSBcIkF0dHJpYnV0ZVwiO1xufSkoRGVjb2RpbmdNb2RlID0gZXhwb3J0cy5EZWNvZGluZ01vZGUgfHwgKGV4cG9ydHMuRGVjb2RpbmdNb2RlID0ge30pKTtcbi8qKlxuICogVG9rZW4gZGVjb2RlciB3aXRoIHN1cHBvcnQgb2Ygd3JpdGluZyBwYXJ0aWFsIGVudGl0aWVzLlxuICovXG52YXIgRW50aXR5RGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbnRpdHlEZWNvZGVyKFxuICAgIC8qKiBUaGUgdHJlZSB1c2VkIHRvIGRlY29kZSBlbnRpdGllcy4gKi9cbiAgICBkZWNvZGVUcmVlLCBcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGNvZGVwb2ludCBpcyBkZWNvZGVkLlxuICAgICAqXG4gICAgICogRm9yIG11bHRpLWJ5dGUgbmFtZWQgZW50aXRpZXMsIHRoaXMgd2lsbCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsXG4gICAgICogd2l0aCB0aGUgc2Vjb25kIGNvZGVwb2ludCwgYW5kIHRoZSBzYW1lIGBjb25zdW1lZGAgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZXBvaW50IFRoZSBkZWNvZGVkIGNvZGVwb2ludC5cbiAgICAgKiBAcGFyYW0gY29uc3VtZWQgVGhlIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZGVjb2Rlci5cbiAgICAgKi9cbiAgICBlbWl0Q29kZVBvaW50LCBcbiAgICAvKiogQW4gb2JqZWN0IHRoYXQgaXMgdXNlZCB0byBwcm9kdWNlIGVycm9ycy4gKi9cbiAgICBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVUcmVlID0gZGVjb2RlVHJlZTtcbiAgICAgICAgdGhpcy5lbWl0Q29kZVBvaW50ID0gZW1pdENvZGVQb2ludDtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGVjb2Rlci4gKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IEVudGl0eURlY29kZXJTdGF0ZS5FbnRpdHlTdGFydDtcbiAgICAgICAgLyoqIENoYXJhY3RlcnMgdGhhdCB3ZXJlIGNvbnN1bWVkIHdoaWxlIHBhcnNpbmcgYW4gZW50aXR5LiAqL1xuICAgICAgICB0aGlzLmNvbnN1bWVkID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXN1bHQgb2YgdGhlIGVudGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogRWl0aGVyIHRoZSByZXN1bHQgaW5kZXggb2YgYSBudW1lcmljIGVudGl0eSwgb3IgdGhlIGNvZGVwb2ludCBvZiBhXG4gICAgICAgICAqIG51bWVyaWMgZW50aXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXN1bHQgPSAwO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGRlY29kZSB0cmVlLiAqL1xuICAgICAgICB0aGlzLnRyZWVJbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCB3ZXJlIGNvbnN1bWVkIGluIGV4Y2Vzcy4gKi9cbiAgICAgICAgdGhpcy5leGNlc3MgPSAxO1xuICAgICAgICAvKiogVGhlIG1vZGUgaW4gd2hpY2ggdGhlIGRlY29kZXIgaXMgb3BlcmF0aW5nLiAqL1xuICAgICAgICB0aGlzLmRlY29kZU1vZGUgPSBEZWNvZGluZ01vZGUuU3RyaWN0O1xuICAgIH1cbiAgICAvKiogUmVzZXRzIHRoZSBpbnN0YW5jZSB0byBtYWtlIGl0IHJldXNhYmxlLiAqL1xuICAgIEVudGl0eURlY29kZXIucHJvdG90eXBlLnN0YXJ0RW50aXR5ID0gZnVuY3Rpb24gKGRlY29kZU1vZGUpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVNb2RlID0gZGVjb2RlTW9kZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEVudGl0eURlY29kZXJTdGF0ZS5FbnRpdHlTdGFydDtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSAwO1xuICAgICAgICB0aGlzLnRyZWVJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZXhjZXNzID0gMTtcbiAgICAgICAgdGhpcy5jb25zdW1lZCA9IDE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBhbiBlbnRpdHkgdG8gdGhlIGRlY29kZXIuIFRoaXMgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIHBhcnRpYWwgZW50aXRpZXMuXG4gICAgICogSWYgdGhlIGVudGl0eSBpcyBpbmNvbXBsZXRlLCB0aGUgZGVjb2RlciB3aWxsIHJldHVybiAtMS5cbiAgICAgKlxuICAgICAqIE1pcnJvcnMgdGhlIGltcGxlbWVudGF0aW9uIG9mIGBnZXREZWNvZGVyYCwgYnV0IHdpdGggdGhlIGFiaWxpdHkgdG8gc3RvcCBkZWNvZGluZyBpZiB0aGVcbiAgICAgKiBlbnRpdHkgaXMgaW5jb21wbGV0ZSwgYW5kIHJlc3VtZSB3aGVuIHRoZSBuZXh0IHN0cmluZyBpcyB3cml0dGVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0cmluZyBUaGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGVudGl0eSAob3IgYSBjb250aW51YXRpb24gb2YgdGhlIGVudGl0eSkuXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBlbnRpdHkgYmVnaW5zLiBTaG91bGQgYmUgMCBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgY2FsbC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCB3ZXJlIGNvbnN1bWVkLCBvciAtMSBpZiB0aGUgZW50aXR5IGlzIGluY29tcGxldGUuXG4gICAgICovXG4gICAgRW50aXR5RGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyLCBvZmZzZXQpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5FbnRpdHlTdGFydDoge1xuICAgICAgICAgICAgICAgIGlmIChzdHIuY2hhckNvZGVBdChvZmZzZXQpID09PSBDaGFyQ29kZXMuTlVNKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY1N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtZXJpY1N0YXJ0KHN0ciwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBFbnRpdHlEZWNvZGVyU3RhdGUuTmFtZWRFbnRpdHk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOYW1lZEVudGl0eShzdHIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OdW1lcmljU3RhcnQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU51bWVyaWNTdGFydChzdHIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OdW1lcmljRGVjaW1hbDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtZXJpY0RlY2ltYWwoc3RyLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY0hleDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtZXJpY0hleChzdHIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OYW1lZEVudGl0eToge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlTmFtZWRFbnRpdHkoc3RyLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyBiZXR3ZWVuIHRoZSBudW1lcmljIGRlY2ltYWwgYW5kIGhleGFkZWNpbWFsIHN0YXRlcy5cbiAgICAgKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gdGhlIGBOdW1lcmljIGNoYXJhY3RlciByZWZlcmVuY2Ugc3RhdGVgIGluIHRoZSBIVE1MIHNwZWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgZW50aXR5IChvciBhIGNvbnRpbnVhdGlvbiBvZiB0aGUgZW50aXR5KS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBjdXJyZW50IG9mZnNldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCB3ZXJlIGNvbnN1bWVkLCBvciAtMSBpZiB0aGUgZW50aXR5IGlzIGluY29tcGxldGUuXG4gICAgICovXG4gICAgRW50aXR5RGVjb2Rlci5wcm90b3R5cGUuc3RhdGVOdW1lcmljU3RhcnQgPSBmdW5jdGlvbiAoc3RyLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA+PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHIuY2hhckNvZGVBdChvZmZzZXQpIHwgVE9fTE9XRVJfQklUKSA9PT0gQ2hhckNvZGVzLkxPV0VSX1gpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY0hleDtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZWQgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtZXJpY0hleChzdHIsIG9mZnNldCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY0RlY2ltYWw7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtZXJpY0RlY2ltYWwoc3RyLCBvZmZzZXQpO1xuICAgIH07XG4gICAgRW50aXR5RGVjb2Rlci5wcm90b3R5cGUuYWRkVG9OdW1lcmljUmVzdWx0ID0gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGVuZCwgYmFzZSkge1xuICAgICAgICBpZiAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICAgICAgdmFyIGRpZ2l0Q291bnQgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCAqIE1hdGgucG93KGJhc2UsIGRpZ2l0Q291bnQpICtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoc3RyLnN1YnN0cihzdGFydCwgZGlnaXRDb3VudCksIGJhc2UpO1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lZCArPSBkaWdpdENvdW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBoZXhhZGVjaW1hbCBudW1lcmljIGVudGl0eS5cbiAgICAgKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gdGhlIGBIZXhhZGVtaWNhbCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHN0YXRlYCBpbiB0aGUgSFRNTCBzcGVjLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGVudGl0eSAob3IgYSBjb250aW51YXRpb24gb2YgdGhlIGVudGl0eSkuXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgY3VycmVudCBvZmZzZXQuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBjb25zdW1lZCwgb3IgLTEgaWYgdGhlIGVudGl0eSBpcyBpbmNvbXBsZXRlLlxuICAgICAqL1xuICAgIEVudGl0eURlY29kZXIucHJvdG90eXBlLnN0YXRlTnVtZXJpY0hleCA9IGZ1bmN0aW9uIChzdHIsIG9mZnNldCkge1xuICAgICAgICB2YXIgc3RhcnRJZHggPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2hhciA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoY2hhcikgfHwgaXNIZXhhZGVjaW1hbENoYXJhY3RlcihjaGFyKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb051bWVyaWNSZXN1bHQoc3RyLCBzdGFydElkeCwgb2Zmc2V0LCAxNik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdE51bWVyaWNFbnRpdHkoY2hhciwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRUb051bWVyaWNSZXN1bHQoc3RyLCBzdGFydElkeCwgb2Zmc2V0LCAxNik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGRlY2ltYWwgbnVtZXJpYyBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBFcXVpdmFsZW50IHRvIHRoZSBgRGVjaW1hbCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHN0YXRlYCBpbiB0aGUgSFRNTCBzcGVjLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGVudGl0eSAob3IgYSBjb250aW51YXRpb24gb2YgdGhlIGVudGl0eSkuXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgY3VycmVudCBvZmZzZXQuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBjb25zdW1lZCwgb3IgLTEgaWYgdGhlIGVudGl0eSBpcyBpbmNvbXBsZXRlLlxuICAgICAqL1xuICAgIEVudGl0eURlY29kZXIucHJvdG90eXBlLnN0YXRlTnVtZXJpY0RlY2ltYWwgPSBmdW5jdGlvbiAoc3RyLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHN0YXJ0SWR4ID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoYXIgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRvTnVtZXJpY1Jlc3VsdChzdHIsIHN0YXJ0SWR4LCBvZmZzZXQsIDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0TnVtZXJpY0VudGl0eShjaGFyLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRvTnVtZXJpY1Jlc3VsdChzdHIsIHN0YXJ0SWR4LCBvZmZzZXQsIDEwKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYW5kIGVtaXQgYSBudW1lcmljIGVudGl0eS5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudHMgdGhlIGxvZ2ljIGZyb20gdGhlIGBIZXhhZGVtaWNhbCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHN0YXJ0XG4gICAgICogc3RhdGVgIGFuZCBgTnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlIGVuZCBzdGF0ZWAgaW4gdGhlIEhUTUwgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXN0Q3AgVGhlIGxhc3QgY29kZSBwb2ludCBvZiB0aGUgZW50aXR5LiBVc2VkIHRvIHNlZSBpZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgIGVudGl0eSB3YXMgdGVybWluYXRlZCB3aXRoIGEgc2VtaWNvbG9uLlxuICAgICAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBUaGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBiZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBjb25zdW1lZC4gVXNlZCB0byB2YWxpZGF0ZSB0aGF0IGF0IGxlYXN0IG9uZSBkaWdpdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB3YXMgY29uc3VtZWQuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBjb25zdW1lZC5cbiAgICAgKi9cbiAgICBFbnRpdHlEZWNvZGVyLnByb3RvdHlwZS5lbWl0TnVtZXJpY0VudGl0eSA9IGZ1bmN0aW9uIChsYXN0Q3AsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gRW5zdXJlIHdlIGNvbnN1bWVkIGF0IGxlYXN0IG9uZSBkaWdpdC5cbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZWQgPD0gZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuZXJyb3JzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJzZW5jZU9mRGlnaXRzSW5OdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlKHRoaXMuY29uc3VtZWQpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCBpZiB0aGlzIGlzIGEgbGVnaXQgZW5kIG9mIHRoZSBlbnRpdHlcbiAgICAgICAgaWYgKGxhc3RDcCA9PT0gQ2hhckNvZGVzLlNFTUkpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZWQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlY29kZU1vZGUgPT09IERlY29kaW5nTW9kZS5TdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdENvZGVQb2ludCgoMCwgZGVjb2RlX2NvZGVwb2ludF9qc18xLnJlcGxhY2VDb2RlUG9pbnQpKHRoaXMucmVzdWx0KSwgdGhpcy5jb25zdW1lZCk7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycykge1xuICAgICAgICAgICAgaWYgKGxhc3RDcCAhPT0gQ2hhckNvZGVzLlNFTUkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5taXNzaW5nU2VtaWNvbG9uQWZ0ZXJDaGFyYWN0ZXJSZWZlcmVuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnZhbGlkYXRlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZSh0aGlzLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBuYW1lZCBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBFcXVpdmFsZW50IHRvIHRoZSBgTmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSBzdGF0ZWAgaW4gdGhlIEhUTUwgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBlbnRpdHkgKG9yIGEgY29udGludWF0aW9uIG9mIHRoZSBlbnRpdHkpLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIGN1cnJlbnQgb2Zmc2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdlcmUgY29uc3VtZWQsIG9yIC0xIGlmIHRoZSBlbnRpdHkgaXMgaW5jb21wbGV0ZS5cbiAgICAgKi9cbiAgICBFbnRpdHlEZWNvZGVyLnByb3RvdHlwZS5zdGF0ZU5hbWVkRW50aXR5ID0gZnVuY3Rpb24gKHN0ciwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBkZWNvZGVUcmVlID0gdGhpcy5kZWNvZGVUcmVlO1xuICAgICAgICB2YXIgY3VycmVudCA9IGRlY29kZVRyZWVbdGhpcy50cmVlSW5kZXhdO1xuICAgICAgICAvLyBUaGUgbWFzayBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSB2YWx1ZSwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGJ5dGUuXG4gICAgICAgIHZhciB2YWx1ZUxlbmd0aCA9IChjdXJyZW50ICYgQmluVHJpZUZsYWdzLlZBTFVFX0xFTkdUSCkgPj4gMTQ7XG4gICAgICAgIGZvciAoOyBvZmZzZXQgPCBzdHIubGVuZ3RoOyBvZmZzZXQrKywgdGhpcy5leGNlc3MrKykge1xuICAgICAgICAgICAgdmFyIGNoYXIgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy50cmVlSW5kZXggPSBkZXRlcm1pbmVCcmFuY2goZGVjb2RlVHJlZSwgY3VycmVudCwgdGhpcy50cmVlSW5kZXggKyBNYXRoLm1heCgxLCB2YWx1ZUxlbmd0aCksIGNoYXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJlZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgcGFyc2luZyBhbiBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb2RlTW9kZSA9PT0gRGVjb2RpbmdNb2RlLkF0dHJpYnV0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkbid0IGhhdmUgY29uc3VtZWQgYW55IGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZUxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCB0aGVyZSBzaG91bGQgYmUgbm8gaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRW50aXR5SW5BdHRyaWJ1dGVJbnZhbGlkRW5kKGNoYXIpKSlcbiAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5lbWl0Tm90VGVybWluYXRlZE5hbWVkRW50aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gZGVjb2RlVHJlZVt0aGlzLnRyZWVJbmRleF07XG4gICAgICAgICAgICB2YWx1ZUxlbmd0aCA9IChjdXJyZW50ICYgQmluVHJpZUZsYWdzLlZBTFVFX0xFTkdUSCkgPj4gMTQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYnJhbmNoIGlzIGEgdmFsdWUsIHN0b3JlIGl0IGFuZCBjb250aW51ZVxuICAgICAgICAgICAgaWYgKHZhbHVlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVudGl0eSBpcyB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uLCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gQ2hhckNvZGVzLlNFTUkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdE5hbWVkRW50aXR5RGF0YSh0aGlzLnRyZWVJbmRleCwgdmFsdWVMZW5ndGgsIHRoaXMuY29uc3VtZWQgKyB0aGlzLmV4Y2Vzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhIG5vbi10ZXJtaW5hdGVkIChsZWdhY3kpIGVudGl0eSB3aGlsZSBwYXJzaW5nIHN0cmljdGx5LCB0aGVuIGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVNb2RlICE9PSBEZWNvZGluZ01vZGUuU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy50cmVlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZWQgKz0gdGhpcy5leGNlc3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhjZXNzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBhIG5hbWVkIGVudGl0eSB0aGF0IHdhcyBub3QgdGVybWluYXRlZCB3aXRoIGEgc2VtaWNvbG9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbnN1bWVkLlxuICAgICAqL1xuICAgIEVudGl0eURlY29kZXIucHJvdG90eXBlLmVtaXROb3RUZXJtaW5hdGVkTmFtZWRFbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iID0gdGhpcywgcmVzdWx0ID0gX2IucmVzdWx0LCBkZWNvZGVUcmVlID0gX2IuZGVjb2RlVHJlZTtcbiAgICAgICAgdmFyIHZhbHVlTGVuZ3RoID0gKGRlY29kZVRyZWVbcmVzdWx0XSAmIEJpblRyaWVGbGFncy5WQUxVRV9MRU5HVEgpID4+IDE0O1xuICAgICAgICB0aGlzLmVtaXROYW1lZEVudGl0eURhdGEocmVzdWx0LCB2YWx1ZUxlbmd0aCwgdGhpcy5jb25zdW1lZCk7XG4gICAgICAgIChfYSA9IHRoaXMuZXJyb3JzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWlzc2luZ1NlbWljb2xvbkFmdGVyQ2hhcmFjdGVyUmVmZXJlbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBhIG5hbWVkIGVudGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXN1bHQgVGhlIGluZGV4IG9mIHRoZSBlbnRpdHkgaW4gdGhlIGRlY29kZSB0cmVlLlxuICAgICAqIEBwYXJhbSB2YWx1ZUxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBlbnRpdHkuXG4gICAgICogQHBhcmFtIGNvbnN1bWVkIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb25zdW1lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb25zdW1lZC5cbiAgICAgKi9cbiAgICBFbnRpdHlEZWNvZGVyLnByb3RvdHlwZS5lbWl0TmFtZWRFbnRpdHlEYXRhID0gZnVuY3Rpb24gKHJlc3VsdCwgdmFsdWVMZW5ndGgsIGNvbnN1bWVkKSB7XG4gICAgICAgIHZhciBkZWNvZGVUcmVlID0gdGhpcy5kZWNvZGVUcmVlO1xuICAgICAgICB0aGlzLmVtaXRDb2RlUG9pbnQodmFsdWVMZW5ndGggPT09IDFcbiAgICAgICAgICAgID8gZGVjb2RlVHJlZVtyZXN1bHRdICYgfkJpblRyaWVGbGFncy5WQUxVRV9MRU5HVEhcbiAgICAgICAgICAgIDogZGVjb2RlVHJlZVtyZXN1bHQgKyAxXSwgY29uc3VtZWQpO1xuICAgICAgICBpZiAodmFsdWVMZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIC8vIEZvciBtdWx0aS1ieXRlIHZhbHVlcywgd2UgbmVlZCB0byBlbWl0IHRoZSBzZWNvbmQgYnl0ZS5cbiAgICAgICAgICAgIHRoaXMuZW1pdENvZGVQb2ludChkZWNvZGVUcmVlW3Jlc3VsdCArIDJdLCBjb25zdW1lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN1bWVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2lnbmFsIHRvIHRoZSBwYXJzZXIgdGhhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCB3YXMgcmVhY2hlZC5cbiAgICAgKlxuICAgICAqIFJlbWFpbmluZyBkYXRhIHdpbGwgYmUgZW1pdHRlZCBhbmQgcmVsZXZhbnQgZXJyb3JzIHdpbGwgYmUgcHJvZHVjZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29uc3VtZWQuXG4gICAgICovXG4gICAgRW50aXR5RGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBFbnRpdHlEZWNvZGVyU3RhdGUuTmFtZWRFbnRpdHk6IHtcbiAgICAgICAgICAgICAgICAvLyBFbWl0IGEgbmFtZWQgZW50aXR5IGlmIHdlIGhhdmUgb25lLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5kZWNvZGVNb2RlICE9PSBEZWNvZGluZ01vZGUuQXR0cmlidXRlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9PT0gdGhpcy50cmVlSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5lbWl0Tm90VGVybWluYXRlZE5hbWVkRW50aXR5KClcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBlbWl0IGEgbnVtZXJpYyBlbnRpdHkgaWYgd2UgaGF2ZSBvbmUuXG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OdW1lcmljRGVjaW1hbDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXROdW1lcmljRW50aXR5KDAsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY0hleDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXROdW1lcmljRW50aXR5KDAsIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY1N0YXJ0OiB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5lcnJvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYnNlbmNlT2ZEaWdpdHNJbk51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UodGhpcy5jb25zdW1lZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5FbnRpdHlTdGFydDoge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiAwIGlmIHdlIGhhdmUgbm8gZW50aXR5LlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRW50aXR5RGVjb2Rlcjtcbn0oKSk7XG5leHBvcnRzLkVudGl0eURlY29kZXIgPSBFbnRpdHlEZWNvZGVyO1xuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBkZWNvZGVzIGVudGl0aWVzIGluIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBkZWNvZGVUcmVlIFRoZSBkZWNvZGUgdHJlZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBkZWNvZGVzIGVudGl0aWVzIGluIGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXREZWNvZGVyKGRlY29kZVRyZWUpIHtcbiAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICB2YXIgZGVjb2RlciA9IG5ldyBFbnRpdHlEZWNvZGVyKGRlY29kZVRyZWUsIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIChyZXQgKz0gKDAsIGRlY29kZV9jb2RlcG9pbnRfanNfMS5mcm9tQ29kZVBvaW50KShzdHIpKTsgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlY29kZVdpdGhUcmllKHN0ciwgZGVjb2RlTW9kZSkge1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHdoaWxlICgob2Zmc2V0ID0gc3RyLmluZGV4T2YoXCImXCIsIG9mZnNldCkpID49IDApIHtcbiAgICAgICAgICAgIHJldCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBvZmZzZXQpO1xuICAgICAgICAgICAgZGVjb2Rlci5zdGFydEVudGl0eShkZWNvZGVNb2RlKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBkZWNvZGVyLndyaXRlKHN0ciwgXG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBcIiZcIlxuICAgICAgICAgICAgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICBpZiAobGVuIDwgMCkge1xuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG9mZnNldCArIGRlY29kZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBvZmZzZXQgKyBsZW47XG4gICAgICAgICAgICAvLyBJZiBgbGVuYCBpcyAwLCBza2lwIHRoZSBjdXJyZW50IGAmYCBhbmQgY29udGludWUuXG4gICAgICAgICAgICBvZmZzZXQgPSBsZW4gPT09IDAgPyBsYXN0SW5kZXggKyAxIDogbGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSByZXQgKyBzdHIuc2xpY2UobGFzdEluZGV4KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGZpbmFsIHN0cmluZy5cbiAgICAgICAgcmV0ID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBicmFuY2ggb2YgdGhlIGN1cnJlbnQgbm9kZSB0aGF0IGlzIHRha2VuIGdpdmVuIHRoZSBjdXJyZW50XG4gKiBjaGFyYWN0ZXIuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB0cmF2ZXJzZSB0aGUgdHJpZS5cbiAqXG4gKiBAcGFyYW0gZGVjb2RlVHJlZSBUaGUgdHJpZS5cbiAqIEBwYXJhbSBjdXJyZW50IFRoZSBjdXJyZW50IG5vZGUuXG4gKiBAcGFyYW0gbm9kZUlkeCBUaGUgaW5kZXggcmlnaHQgYWZ0ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgaXRzIHZhbHVlLlxuICogQHBhcmFtIGNoYXIgVGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBuZXh0IG5vZGUsIG9yIC0xIGlmIG5vIGJyYW5jaCBpcyB0YWtlbi5cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQnJhbmNoKGRlY29kZVRyZWUsIGN1cnJlbnQsIG5vZGVJZHgsIGNoYXIpIHtcbiAgICB2YXIgYnJhbmNoQ291bnQgPSAoY3VycmVudCAmIEJpblRyaWVGbGFncy5CUkFOQ0hfTEVOR1RIKSA+PiA3O1xuICAgIHZhciBqdW1wT2Zmc2V0ID0gY3VycmVudCAmIEJpblRyaWVGbGFncy5KVU1QX1RBQkxFO1xuICAgIC8vIENhc2UgMTogU2luZ2xlIGJyYW5jaCBlbmNvZGVkIGluIGp1bXAgb2Zmc2V0XG4gICAgaWYgKGJyYW5jaENvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBqdW1wT2Zmc2V0ICE9PSAwICYmIGNoYXIgPT09IGp1bXBPZmZzZXQgPyBub2RlSWR4IDogLTE7XG4gICAgfVxuICAgIC8vIENhc2UgMjogTXVsdGlwbGUgYnJhbmNoZXMgZW5jb2RlZCBpbiBqdW1wIHRhYmxlXG4gICAgaWYgKGp1bXBPZmZzZXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gY2hhciAtIGp1bXBPZmZzZXQ7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gYnJhbmNoQ291bnRcbiAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgIDogZGVjb2RlVHJlZVtub2RlSWR4ICsgdmFsdWVdIC0gMTtcbiAgICB9XG4gICAgLy8gQ2FzZSAzOiBNdWx0aXBsZSBicmFuY2hlcyBlbmNvZGVkIGluIGRpY3Rpb25hcnlcbiAgICAvLyBCaW5hcnkgc2VhcmNoIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgIHZhciBsbyA9IG5vZGVJZHg7XG4gICAgdmFyIGhpID0gbG8gKyBicmFuY2hDb3VudCAtIDE7XG4gICAgd2hpbGUgKGxvIDw9IGhpKSB7XG4gICAgICAgIHZhciBtaWQgPSAobG8gKyBoaSkgPj4+IDE7XG4gICAgICAgIHZhciBtaWRWYWwgPSBkZWNvZGVUcmVlW21pZF07XG4gICAgICAgIGlmIChtaWRWYWwgPCBjaGFyKSB7XG4gICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWlkVmFsID4gY2hhcikge1xuICAgICAgICAgICAgaGkgPSBtaWQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVRyZWVbbWlkICsgYnJhbmNoQ291bnRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydHMuZGV0ZXJtaW5lQnJhbmNoID0gZGV0ZXJtaW5lQnJhbmNoO1xudmFyIGh0bWxEZWNvZGVyID0gZ2V0RGVjb2RlcihkZWNvZGVfZGF0YV9odG1sX2pzXzEuZGVmYXVsdCk7XG52YXIgeG1sRGVjb2RlciA9IGdldERlY29kZXIoZGVjb2RlX2RhdGFfeG1sX2pzXzEuZGVmYXVsdCk7XG4vKipcbiAqIERlY29kZXMgYW4gSFRNTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBtb2RlIFRoZSBkZWNvZGluZyBtb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBkZWNvZGVIVE1MKHN0ciwgbW9kZSkge1xuICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9IERlY29kaW5nTW9kZS5MZWdhY3k7IH1cbiAgICByZXR1cm4gaHRtbERlY29kZXIoc3RyLCBtb2RlKTtcbn1cbmV4cG9ydHMuZGVjb2RlSFRNTCA9IGRlY29kZUhUTUw7XG4vKipcbiAqIERlY29kZXMgYW4gSFRNTCBzdHJpbmcgaW4gYW4gYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUhUTUxBdHRyaWJ1dGUoc3RyKSB7XG4gICAgcmV0dXJuIGh0bWxEZWNvZGVyKHN0ciwgRGVjb2RpbmdNb2RlLkF0dHJpYnV0ZSk7XG59XG5leHBvcnRzLmRlY29kZUhUTUxBdHRyaWJ1dGUgPSBkZWNvZGVIVE1MQXR0cmlidXRlO1xuLyoqXG4gKiBEZWNvZGVzIGFuIEhUTUwgc3RyaW5nLCByZXF1aXJpbmcgYWxsIGVudGl0aWVzIHRvIGJlIHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24uXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlSFRNTFN0cmljdChzdHIpIHtcbiAgICByZXR1cm4gaHRtbERlY29kZXIoc3RyLCBEZWNvZGluZ01vZGUuU3RyaWN0KTtcbn1cbmV4cG9ydHMuZGVjb2RlSFRNTFN0cmljdCA9IGRlY29kZUhUTUxTdHJpY3Q7XG4vKipcbiAqIERlY29kZXMgYW4gWE1MIHN0cmluZywgcmVxdWlyaW5nIGFsbCBlbnRpdGllcyB0byBiZSB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uLlxuICpcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVhNTChzdHIpIHtcbiAgICByZXR1cm4geG1sRGVjb2RlcihzdHIsIERlY29kaW5nTW9kZS5TdHJpY3QpO1xufVxuZXhwb3J0cy5kZWNvZGVYTUwgPSBkZWNvZGVYTUw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvaGUvYmxvYi8zNmFmZTE3OTM5MjIyNmNmMWI2Y2NkYjE2ZWJiYjdhNWE4NDRkOTNhL3NyYy9oZS5qcyNMMTA2LUwxMzRcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwbGFjZUNvZGVQb2ludCA9IGV4cG9ydHMuZnJvbUNvZGVQb2ludCA9IHZvaWQgMDtcbnZhciBkZWNvZGVNYXAgPSBuZXcgTWFwKFtcbiAgICBbMCwgNjU1MzNdLFxuICAgIC8vIEMxIFVuaWNvZGUgY29udHJvbCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHJlcGxhY2VtZW50c1xuICAgIFsxMjgsIDgzNjRdLFxuICAgIFsxMzAsIDgyMThdLFxuICAgIFsxMzEsIDQwMl0sXG4gICAgWzEzMiwgODIyMl0sXG4gICAgWzEzMywgODIzMF0sXG4gICAgWzEzNCwgODIyNF0sXG4gICAgWzEzNSwgODIyNV0sXG4gICAgWzEzNiwgNzEwXSxcbiAgICBbMTM3LCA4MjQwXSxcbiAgICBbMTM4LCAzNTJdLFxuICAgIFsxMzksIDgyNDldLFxuICAgIFsxNDAsIDMzOF0sXG4gICAgWzE0MiwgMzgxXSxcbiAgICBbMTQ1LCA4MjE2XSxcbiAgICBbMTQ2LCA4MjE3XSxcbiAgICBbMTQ3LCA4MjIwXSxcbiAgICBbMTQ4LCA4MjIxXSxcbiAgICBbMTQ5LCA4MjI2XSxcbiAgICBbMTUwLCA4MjExXSxcbiAgICBbMTUxLCA4MjEyXSxcbiAgICBbMTUyLCA3MzJdLFxuICAgIFsxNTMsIDg0ODJdLFxuICAgIFsxNTQsIDM1M10sXG4gICAgWzE1NSwgODI1MF0sXG4gICAgWzE1NiwgMzM5XSxcbiAgICBbMTU4LCAzODJdLFxuICAgIFsxNTksIDM3Nl0sXG5dKTtcbi8qKlxuICogUG9seWZpbGwgZm9yIGBTdHJpbmcuZnJvbUNvZGVQb2ludGAuIEl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgc3RyaW5nIGZyb20gYSBVbmljb2RlIGNvZGUgcG9pbnQuXG4gKi9cbmV4cG9ydHMuZnJvbUNvZGVQb2ludCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvZXMtYnVpbHRpbnNcbihfYSA9IFN0cmluZy5mcm9tQ29kZVBvaW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmdW5jdGlvbiAoY29kZVBvaW50KSB7XG4gICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4ZmZmZikge1xuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMCk7XG4gICAgICAgIGNvZGVQb2ludCA9IDB4ZGMwMCB8IChjb2RlUG9pbnQgJiAweDNmZik7XG4gICAgfVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG4vKipcbiAqIFJlcGxhY2UgdGhlIGdpdmVuIGNvZGUgcG9pbnQgd2l0aCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpZiBpdCBpcyBhXG4gKiBzdXJyb2dhdGUgb3IgaXMgb3V0c2lkZSB0aGUgdmFsaWQgcmFuZ2UuIE90aGVyd2lzZSByZXR1cm4gdGhlIGNvZGVcbiAqIHBvaW50IHVuY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKChjb2RlUG9pbnQgPj0gMHhkODAwICYmIGNvZGVQb2ludCA8PSAweGRmZmYpIHx8IGNvZGVQb2ludCA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHJldHVybiAweGZmZmQ7XG4gICAgfVxuICAgIHJldHVybiAoX2EgPSBkZWNvZGVNYXAuZ2V0KGNvZGVQb2ludCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvZGVQb2ludDtcbn1cbmV4cG9ydHMucmVwbGFjZUNvZGVQb2ludCA9IHJlcGxhY2VDb2RlUG9pbnQ7XG4vKipcbiAqIFJlcGxhY2UgdGhlIGNvZGUgcG9pbnQgaWYgcmVsZXZhbnQsIHRoZW4gY29udmVydCBpdCB0byBhIHN0cmluZy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGZyb21Db2RlUG9pbnQocmVwbGFjZUNvZGVQb2ludChjb2RlUG9pbnQpKWAgaW5zdGVhZC5cbiAqIEBwYXJhbSBjb2RlUG9pbnQgVGhlIGNvZGUgcG9pbnQgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgY29kZSBwb2ludC5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5mcm9tQ29kZVBvaW50KShyZXBsYWNlQ29kZVBvaW50KGNvZGVQb2ludCkpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVjb2RlQ29kZVBvaW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlX2NvZGVwb2ludC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlTm9uQXNjaWlIVE1MID0gZXhwb3J0cy5lbmNvZGVIVE1MID0gdm9pZCAwO1xudmFyIGVuY29kZV9odG1sX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZ2VuZXJhdGVkL2VuY29kZS1odG1sLmpzXCIpKTtcbnZhciBlc2NhcGVfanNfMSA9IHJlcXVpcmUoXCIuL2VzY2FwZS5qc1wiKTtcbnZhciBodG1sUmVwbGFjZXIgPSAvW1xcdFxcbiEtLC4vOi1AWy1gXFxmey19JFxceDgwLVxcdUZGRkZdL2c7XG4vKipcbiAqIEVuY29kZXMgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0IHVzaW5nIEhUTUwgZW50aXRpZXMuIFRoaXMgaW5jbHVkZXNcbiAqIGNoYXJhY3RlcnMgdGhhdCBhcmUgdmFsaWQgQVNDSUkgY2hhcmFjdGVycyBpbiBIVE1MIGRvY3VtZW50cywgc3VjaCBhcyBgI2AuXG4gKlxuICogVG8gZ2V0IGEgbW9yZSBjb21wYWN0IG91dHB1dCwgY29uc2lkZXIgdXNpbmcgdGhlIGBlbmNvZGVOb25Bc2NpaUhUTUxgXG4gKiBmdW5jdGlvbiwgd2hpY2ggd2lsbCBvbmx5IGVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCB2YWxpZCBpbiBIVE1MXG4gKiBkb2N1bWVudHMsIGFzIHdlbGwgYXMgbm9uLUFTQ0lJIGNoYXJhY3RlcnMuXG4gKlxuICogSWYgYSBjaGFyYWN0ZXIgaGFzIG5vIGVxdWl2YWxlbnQgZW50aXR5LCBhIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlXG4gKiAoZWcuIGAmI3hmYztgKSB3aWxsIGJlIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUhUTUwoZGF0YSkge1xuICAgIHJldHVybiBlbmNvZGVIVE1MVHJpZVJlKGh0bWxSZXBsYWNlciwgZGF0YSk7XG59XG5leHBvcnRzLmVuY29kZUhUTUwgPSBlbmNvZGVIVE1MO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBIVE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgSFRNTCBlbnRpdGllcy4gVGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBlbmNvZGUgY2hhcmFjdGVycyB0aGF0XG4gKiBhcmUgdmFsaWQgaW4gSFRNTCBkb2N1bWVudHMsIHN1Y2ggYXMgYCNgLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYSBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZVxuICogKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBlbmNvZGVOb25Bc2NpaUhUTUwoZGF0YSkge1xuICAgIHJldHVybiBlbmNvZGVIVE1MVHJpZVJlKGVzY2FwZV9qc18xLnhtbFJlcGxhY2VyLCBkYXRhKTtcbn1cbmV4cG9ydHMuZW5jb2RlTm9uQXNjaWlIVE1MID0gZW5jb2RlTm9uQXNjaWlIVE1MO1xuZnVuY3Rpb24gZW5jb2RlSFRNTFRyaWVSZShyZWdFeHAsIHN0cikge1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHZhciBsYXN0SWR4ID0gMDtcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IHJlZ0V4cC5leGVjKHN0cikpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBpID0gbWF0Y2guaW5kZXg7XG4gICAgICAgIHJldCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJZHgsIGkpO1xuICAgICAgICB2YXIgY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgbmV4dCA9IGVuY29kZV9odG1sX2pzXzEuZGVmYXVsdC5nZXQoY2hhcik7XG4gICAgICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gV2UgYXJlIGluIGEgYnJhbmNoLiBUcnkgdG8gbWF0Y2ggdGhlIG5leHQgY2hhci5cbiAgICAgICAgICAgIGlmIChpICsgMSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBzdHIuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdHlwZW9mIG5leHQubiA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICA/IG5leHQubiA9PT0gbmV4dENoYXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV4dC5vXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IG5leHQubi5nZXQobmV4dENoYXIpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdElkeCA9IHJlZ0V4cC5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IG5leHQudjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtaWdodCBoYXZlIGEgdHJlZSBub2RlIHdpdGhvdXQgYSB2YWx1ZTsgc2tpcCBhbmQgdXNlIGEgbnVtZXJpYyBlbnRpdHkuXG4gICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldCArPSBuZXh0O1xuICAgICAgICAgICAgbGFzdElkeCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNwID0gKDAsIGVzY2FwZV9qc18xLmdldENvZGVQb2ludCkoc3RyLCBpKTtcbiAgICAgICAgICAgIHJldCArPSBcIiYjeFwiLmNvbmNhdChjcC50b1N0cmluZygxNiksIFwiO1wiKTtcbiAgICAgICAgICAgIC8vIEluY3JlYXNlIGJ5IDEgaWYgd2UgaGF2ZSBhIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICBsYXN0SWR4ID0gcmVnRXhwLmxhc3RJbmRleCArPSBOdW1iZXIoY3AgIT09IGNoYXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQgKyBzdHIuc3Vic3RyKGxhc3RJZHgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lc2NhcGVUZXh0ID0gZXhwb3J0cy5lc2NhcGVBdHRyaWJ1dGUgPSBleHBvcnRzLmVzY2FwZVVURjggPSBleHBvcnRzLmVzY2FwZSA9IGV4cG9ydHMuZW5jb2RlWE1MID0gZXhwb3J0cy5nZXRDb2RlUG9pbnQgPSBleHBvcnRzLnhtbFJlcGxhY2VyID0gdm9pZCAwO1xuZXhwb3J0cy54bWxSZXBsYWNlciA9IC9bXCImJzw+JFxceDgwLVxcdUZGRkZdL2c7XG52YXIgeG1sQ29kZU1hcCA9IG5ldyBNYXAoW1xuICAgIFszNCwgXCImcXVvdDtcIl0sXG4gICAgWzM4LCBcIiZhbXA7XCJdLFxuICAgIFszOSwgXCImYXBvcztcIl0sXG4gICAgWzYwLCBcIiZsdDtcIl0sXG4gICAgWzYyLCBcIiZndDtcIl0sXG5dKTtcbi8vIEZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9kZSA8IDQsIHdlIHdyYXAgYGNvZGVQb2ludEF0YFxuZXhwb3J0cy5nZXRDb2RlUG9pbnQgPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG5TdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ICE9IG51bGxcbiAgICA/IGZ1bmN0aW9uIChzdHIsIGluZGV4KSB7IHJldHVybiBzdHIuY29kZVBvaW50QXQoaW5kZXgpOyB9XG4gICAgOiAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICBmdW5jdGlvbiAoYywgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAoYy5jaGFyQ29kZUF0KGluZGV4KSAmIDB4ZmMwMCkgPT09IDB4ZDgwMFxuICAgICAgICAgICAgICAgID8gKGMuY2hhckNvZGVBdChpbmRleCkgLSAweGQ4MDApICogMHg0MDAgK1xuICAgICAgICAgICAgICAgICAgICBjLmNoYXJDb2RlQXQoaW5kZXggKyAxKSAtXG4gICAgICAgICAgICAgICAgICAgIDB4ZGMwMCArXG4gICAgICAgICAgICAgICAgICAgIDB4MTAwMDBcbiAgICAgICAgICAgICAgICA6IGMuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIH07XG4vKipcbiAqIEVuY29kZXMgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIFhNTFxuICogZG9jdW1lbnRzIHVzaW5nIFhNTCBlbnRpdGllcy5cbiAqXG4gKiBJZiBhIGNoYXJhY3RlciBoYXMgbm8gZXF1aXZhbGVudCBlbnRpdHksIGFcbiAqIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApIHdpbGwgYmUgdXNlZC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlWE1MKHN0cikge1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHZhciBsYXN0SWR4ID0gMDtcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IGV4cG9ydHMueG1sUmVwbGFjZXIuZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgaSA9IG1hdGNoLmluZGV4O1xuICAgICAgICB2YXIgY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgbmV4dCA9IHhtbENvZGVNYXAuZ2V0KGNoYXIpO1xuICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXQgKz0gc3RyLnN1YnN0cmluZyhsYXN0SWR4LCBpKSArIG5leHQ7XG4gICAgICAgICAgICBsYXN0SWR4ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgKz0gXCJcIi5jb25jYXQoc3RyLnN1YnN0cmluZyhsYXN0SWR4LCBpKSwgXCImI3hcIikuY29uY2F0KCgwLCBleHBvcnRzLmdldENvZGVQb2ludCkoc3RyLCBpKS50b1N0cmluZygxNiksIFwiO1wiKTtcbiAgICAgICAgICAgIC8vIEluY3JlYXNlIGJ5IDEgaWYgd2UgaGF2ZSBhIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICBsYXN0SWR4ID0gZXhwb3J0cy54bWxSZXBsYWNlci5sYXN0SW5kZXggKz0gTnVtYmVyKChjaGFyICYgMHhmYzAwKSA9PT0gMHhkODAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0ICsgc3RyLnN1YnN0cihsYXN0SWR4KTtcbn1cbmV4cG9ydHMuZW5jb2RlWE1MID0gZW5jb2RlWE1MO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBYTUxcbiAqIGRvY3VtZW50cyB1c2luZyBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKS5cbiAqXG4gKiBIYXZlIGEgbG9vayBhdCBgZXNjYXBlVVRGOGAgaWYgeW91IHdhbnQgYSBtb3JlIGNvbmNpc2Ugb3V0cHV0IGF0IHRoZSBleHBlbnNlXG4gKiBvZiByZWR1Y2VkIHRyYW5zcG9ydGFiaWxpdHkuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZXhwb3J0cy5lc2NhcGUgPSBlbmNvZGVYTUw7XG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVzY2FwZXMgYWxsIGNoYXJhY3RlcnMgbWF0Y2hlZCBieSB0aGUgZ2l2ZW4gcmVndWxhclxuICogZXhwcmVzc2lvbiB1c2luZyB0aGUgZ2l2ZW4gbWFwIG9mIGNoYXJhY3RlcnMgdG8gZXNjYXBlIHRvIHRoZWlyIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSByZWdleCBSZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggY2hhcmFjdGVycyB0byBlc2NhcGUuXG4gKiBAcGFyYW0gbWFwIE1hcCBvZiBjaGFyYWN0ZXJzIHRvIGVzY2FwZSB0byB0aGVpciBlbnRpdGllcy5cbiAqXG4gKiBAcmV0dXJucyBGdW5jdGlvbiB0aGF0IGVzY2FwZXMgYWxsIGNoYXJhY3RlcnMgbWF0Y2hlZCBieSB0aGUgZ2l2ZW4gcmVndWxhclxuICogZXhwcmVzc2lvbiB1c2luZyB0aGUgZ2l2ZW4gbWFwIG9mIGNoYXJhY3RlcnMgdG8gZXNjYXBlIHRvIHRoZWlyIGVudGl0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRFc2NhcGVyKHJlZ2V4LCBtYXApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZXNjYXBlKGRhdGEpIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICB2YXIgbGFzdElkeCA9IDA7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhkYXRhKSkpIHtcbiAgICAgICAgICAgIGlmIChsYXN0SWR4ICE9PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBkYXRhLnN1YnN0cmluZyhsYXN0SWR4LCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoYXQgdGhpcyBjaGFyYWN0ZXIgd2lsbCBiZSBpbiB0aGUgbWFwLlxuICAgICAgICAgICAgcmVzdWx0ICs9IG1hcC5nZXQobWF0Y2hbMF0uY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICAvLyBFdmVyeSBtYXRjaCB3aWxsIGJlIG9mIGxlbmd0aCAxXG4gICAgICAgICAgICBsYXN0SWR4ID0gbWF0Y2guaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBkYXRhLnN1YnN0cmluZyhsYXN0SWR4KTtcbiAgICB9O1xufVxuLyoqXG4gKiBFbmNvZGVzIGFsbCBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBYTUwgZG9jdW1lbnRzIHVzaW5nIFhNTCBlbnRpdGllcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIG91dHB1dCB3aWxsIGJlIGNoYXJhY3Rlci1zZXQgZGVwZW5kZW50LlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBlc2NhcGUuXG4gKi9cbmV4cG9ydHMuZXNjYXBlVVRGOCA9IGdldEVzY2FwZXIoL1smPD4nXCJdL2csIHhtbENvZGVNYXApO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSB0byBiZSBlc2NhcGVkIGluIEhUTUwgYXR0cmlidXRlcyxcbiAqIGZvbGxvd2luZyB7QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI2VzY2FwaW5nU3RyaW5nfS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZXNjYXBlLlxuICovXG5leHBvcnRzLmVzY2FwZUF0dHJpYnV0ZSA9IGdldEVzY2FwZXIoL1tcIiZcXHUwMEEwXS9nLCBuZXcgTWFwKFtcbiAgICBbMzQsIFwiJnF1b3Q7XCJdLFxuICAgIFszOCwgXCImYW1wO1wiXSxcbiAgICBbMTYwLCBcIiZuYnNwO1wiXSxcbl0pKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgY2hhcmFjdGVycyB0aGF0IGhhdmUgdG8gYmUgZXNjYXBlZCBpbiBIVE1MIHRleHQsXG4gKiBmb2xsb3dpbmcge0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNlc2NhcGluZ1N0cmluZ30uXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZXhwb3J0cy5lc2NhcGVUZXh0ID0gZ2V0RXNjYXBlcigvWyY8PlxcdTAwQTBdL2csIG5ldyBNYXAoW1xuICAgIFszOCwgXCImYW1wO1wiXSxcbiAgICBbNjAsIFwiJmx0O1wiXSxcbiAgICBbNjIsIFwiJmd0O1wiXSxcbiAgICBbMTYwLCBcIiZuYnNwO1wiXSxcbl0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzY2FwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIEdlbmVyYXRlZCB1c2luZyBzY3JpcHRzL3dyaXRlLWRlY29kZS1tYXAudHNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBVaW50MTZBcnJheShcbi8vIHByZXR0aWVyLWlnbm9yZVxuXCJcXHUxZDQxPFxceGQ1XFx1MDEzMVxcdTAyOGFcXHUwNDlkXFx1MDU3YlxcdTA1ZDBcXHUwNjc1XFx1MDZkZVxcdTA3YTJcXHUwN2Q2XFx1MDgwZlxcdTBhNGFcXHUwYTkxXFx1MGRhMVxcdTBlNmRcXHUwZjA5XFx1MGYyNlxcdTEwY2FcXHUxMjI4XFx1MTJlMVxcdTE0MTVcXHUxNDlkXFx1MTRjM1xcdTE0ZGZcXHUxNTI1XFwwXFwwXFwwXFwwXFwwXFwwXFx1MTU2YlxcdTE2Y2RcXHUxOThkXFx1MWMxMlxcdTFkZGRcXHUxZjdlXFx1MjA2MFxcdTIxYjBcXHUyMjhkXFx1MjNjMFxcdTIzZmJcXHUyNDQyXFx1MjgyNFxcdTI5MTJcXHUyZDA4XFx1MmU0OFxcdTJmY2VcXHUzMDE2XFx1MzJiYVxcdTM2MzlcXHUzN2FjXFx1MzhmZVxcdTNhMjhcXHUzYTcxXFx1M2FlMFxcdTNiMmVcXHUwODAwRU1hYmNmZ2xtbm9wcnN0dVxcXFxiZm1zXFx4N2ZcXHg4NFxceDhiXFx4OTBcXHg5NVxceDk4XFx4YTZcXHhiM1xceGI5XFx4YzhcXHhjZmxpZ1xcdTgwM2JcXHhjNlxcdTQwYzZQXFx1ODAzYiZcXHU0MDI2Y3V0ZVxcdTgwM2JcXHhjMVxcdTQwYzFyZXZlO1xcdTQxMDJcXHUwMTAwaXl4fXJjXFx1ODAzYlxceGMyXFx1NDBjMjtcXHU0NDEwcjtcXHVjMDAwXFx1ZDgzNVxcdWRkMDRyYXZlXFx1ODAzYlxceGMwXFx1NDBjMHBoYTtcXHU0MzkxYWNyO1xcdTQxMDBkO1xcdTZhNTNcXHUwMTAwZ3BcXHg5ZFxceGExb247XFx1NDEwNGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDM4cGx5RnVuY3Rpb247XFx1NjA2MWluZ1xcdTgwM2JcXHhjNVxcdTQwYzVcXHUwMTAwY3NcXHhiZVxceGMzcjtcXHVjMDAwXFx1ZDgzNVxcdWRjOWNpZ247XFx1NjI1NGlsZGVcXHU4MDNiXFx4YzNcXHU0MGMzbWxcXHU4MDNiXFx4YzRcXHU0MGM0XFx1MDQwMGFjZWZvcnN1XFx4ZTVcXHhmYlxceGZlXFx1MDExN1xcdTAxMWNcXHUwMTIyXFx1MDEyN1xcdTAxMmFcXHUwMTAwY3JcXHhlYVxceGYya3NsYXNoO1xcdTYyMTZcXHUwMTc2XFx4ZjZcXHhmODtcXHU2YWU3ZWQ7XFx1NjMwNnk7XFx1NDQxMVxcdTAxODBjcnRcXHUwMTA1XFx1MDEwYlxcdTAxMTRhdXNlO1xcdTYyMzVub3VsbGlzO1xcdTYxMmNhO1xcdTQzOTJyO1xcdWMwMDBcXHVkODM1XFx1ZGQwNXBmO1xcdWMwMDBcXHVkODM1XFx1ZGQzOWV2ZTtcXHU0MmQ4Y1xceGYyXFx1MDExM21wZXE7XFx1NjI0ZVxcdTA3MDBIT2FjZGVmaGlsb3JzdVxcdTAxNGRcXHUwMTUxXFx1MDE1NlxcdTAxODBcXHUwMTllXFx1MDFhMlxcdTAxYjVcXHUwMWI3XFx1MDFiYVxcdTAxZGNcXHUwMjE1XFx1MDI3M1xcdTAyNzhcXHUwMjdlY3k7XFx1NDQyN1BZXFx1ODAzYlxceGE5XFx1NDBhOVxcdTAxODBjcHlcXHUwMTVkXFx1MDE2MlxcdTAxN2F1dGU7XFx1NDEwNlxcdTAxMDA7aVxcdTAxNjdcXHUwMTY4XFx1NjJkMnRhbERpZmZlcmVudGlhbEQ7XFx1NjE0NWxleXM7XFx1NjEyZFxcdTAyMDBhZWlvXFx1MDE4OVxcdTAxOGVcXHUwMTk0XFx1MDE5OHJvbjtcXHU0MTBjZGlsXFx1ODAzYlxceGM3XFx1NDBjN3JjO1xcdTQxMDhuaW50O1xcdTYyMzBvdDtcXHU0MTBhXFx1MDEwMGRuXFx1MDFhN1xcdTAxYWRpbGxhO1xcdTQwYjh0ZXJEb3Q7XFx1NDBiN1xceGYyXFx1MDE3Zmk7XFx1NDNhN3JjbGVcXHUwMjAwRE1QVFxcdTAxYzdcXHUwMWNiXFx1MDFkMVxcdTAxZDZvdDtcXHU2Mjk5aW51cztcXHU2Mjk2bHVzO1xcdTYyOTVpbWVzO1xcdTYyOTdvXFx1MDEwMGNzXFx1MDFlMlxcdTAxZjhrd2lzZUNvbnRvdXJJbnRlZ3JhbDtcXHU2MjMyZUN1cmx5XFx1MDEwMERRXFx1MDIwM1xcdTAyMGZvdWJsZVF1b3RlO1xcdTYwMWR1b3RlO1xcdTYwMTlcXHUwMjAwbG5wdVxcdTAyMWVcXHUwMjI4XFx1MDI0N1xcdTAyNTVvblxcdTAxMDA7ZVxcdTAyMjVcXHUwMjI2XFx1NjIzNztcXHU2YTc0XFx1MDE4MGdpdFxcdTAyMmZcXHUwMjM2XFx1MDIzYXJ1ZW50O1xcdTYyNjFudDtcXHU2MjJmb3VySW50ZWdyYWw7XFx1NjIyZVxcdTAxMDBmclxcdTAyNGNcXHUwMjRlO1xcdTYxMDJvZHVjdDtcXHU2MjEwbnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDtcXHU2MjMzb3NzO1xcdTZhMmZjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjOWVwXFx1MDEwMDtDXFx1MDI4NFxcdTAyODVcXHU2MmQzYXA7XFx1NjI0ZFxcdTA1ODBESlNaYWNlZmlvc1xcdTAyYTBcXHUwMmFjXFx1MDJiMFxcdTAyYjRcXHUwMmI4XFx1MDJjYlxcdTAyZDdcXHUwMmUxXFx1MDJlNlxcdTAzMzNcXHUwNDhkXFx1MDEwMDtvXFx1MDE3OVxcdTAyYTV0cmFoZDtcXHU2OTExY3k7XFx1NDQwMmN5O1xcdTQ0MDVjeTtcXHU0NDBmXFx1MDE4MGdyc1xcdTAyYmZcXHUwMmM0XFx1MDJjN2dlcjtcXHU2MDIxcjtcXHU2MWExaHY7XFx1NmFlNFxcdTAxMDBheVxcdTAyZDBcXHUwMmQ1cm9uO1xcdTQxMGU7XFx1NDQxNGxcXHUwMTAwO3RcXHUwMmRkXFx1MDJkZVxcdTYyMDdhO1xcdTQzOTRyO1xcdWMwMDBcXHVkODM1XFx1ZGQwN1xcdTAxMDBhZlxcdTAyZWJcXHUwMzI3XFx1MDEwMGNtXFx1MDJmMFxcdTAzMjJyaXRpY2FsXFx1MDIwMEFER1RcXHUwMzAwXFx1MDMwNlxcdTAzMTZcXHUwMzFjY3V0ZTtcXHU0MGI0b1xcdTAxNzRcXHUwMzBiXFx1MDMwZDtcXHU0MmQ5YmxlQWN1dGU7XFx1NDJkZHJhdmU7XFx1NDA2MGlsZGU7XFx1NDJkY29uZDtcXHU2MmM0ZmVyZW50aWFsRDtcXHU2MTQ2XFx1MDQ3MFxcdTAzM2RcXDBcXDBcXDBcXHUwMzQyXFx1MDM1NFxcMFxcdTA0MDVmO1xcdWMwMDBcXHVkODM1XFx1ZGQzYlxcdTAxODA7REVcXHUwMzQ4XFx1MDM0OVxcdTAzNGRcXHU0MGE4b3Q7XFx1NjBkY3F1YWw7XFx1NjI1MGJsZVxcdTAzMDBDRExSVVZcXHUwMzYzXFx1MDM3MlxcdTAzODJcXHUwM2NmXFx1MDNlMlxcdTAzZjhvbnRvdXJJbnRlZ3JhXFx4ZWNcXHUwMjM5b1xcdTAyNzRcXHUwMzc5XFwwXFwwXFx1MDM3YlxceGJiXFx1MDM0OW5BcnJvdztcXHU2MWQzXFx1MDEwMGVvXFx1MDM4N1xcdTAzYTRmdFxcdTAxODBBUlRcXHUwMzkwXFx1MDM5NlxcdTAzYTFycm93O1xcdTYxZDBpZ2h0QXJyb3c7XFx1NjFkNGVcXHhlNVxcdTAyY2FuZ1xcdTAxMDBMUlxcdTAzYWJcXHUwM2M0ZWZ0XFx1MDEwMEFSXFx1MDNiM1xcdTAzYjlycm93O1xcdTY3ZjhpZ2h0QXJyb3c7XFx1NjdmYWlnaHRBcnJvdztcXHU2N2Y5aWdodFxcdTAxMDBBVFxcdTAzZDhcXHUwM2RlcnJvdztcXHU2MWQyZWU7XFx1NjJhOHBcXHUwMjQxXFx1MDNlOVxcMFxcMFxcdTAzZWZycm93O1xcdTYxZDFvd25BcnJvdztcXHU2MWQ1ZXJ0aWNhbEJhcjtcXHU2MjI1blxcdTAzMDBBQkxSVGFcXHUwNDEyXFx1MDQyYVxcdTA0MzBcXHUwNDVlXFx1MDQ3ZlxcdTAzN2Nycm93XFx1MDE4MDtCVVxcdTA0MWRcXHUwNDFlXFx1MDQyMlxcdTYxOTNhcjtcXHU2OTEzcEFycm93O1xcdTYxZjVyZXZlO1xcdTQzMTFlZnRcXHUwMmQyXFx1MDQzYVxcMFxcdTA0NDZcXDBcXHUwNDUwaWdodFZlY3RvcjtcXHU2OTUwZWVWZWN0b3I7XFx1Njk1ZWVjdG9yXFx1MDEwMDtCXFx1MDQ1OVxcdTA0NWFcXHU2MWJkYXI7XFx1Njk1NmlnaHRcXHUwMWQ0XFx1MDQ2N1xcMFxcdTA0NzFlZVZlY3RvcjtcXHU2OTVmZWN0b3JcXHUwMTAwO0JcXHUwNDdhXFx1MDQ3YlxcdTYxYzFhcjtcXHU2OTU3ZWVcXHUwMTAwO0FcXHUwNDg2XFx1MDQ4N1xcdTYyYTRycm93O1xcdTYxYTdcXHUwMTAwY3RcXHUwNDkyXFx1MDQ5N3I7XFx1YzAwMFxcdWQ4MzVcXHVkYzlmcm9rO1xcdTQxMTBcXHUwODAwTlRhY2RmZ2xtb3Bxc3R1eFxcdTA0YmRcXHUwNGMwXFx1MDRjNFxcdTA0Y2JcXHUwNGRlXFx1MDRlMlxcdTA0ZTdcXHUwNGVlXFx1MDRmNVxcdTA1MjFcXHUwNTJmXFx1MDUzNlxcdTA1NTJcXHUwNTVkXFx1MDU2MFxcdTA1NjVHO1xcdTQxNGFIXFx1ODAzYlxceGQwXFx1NDBkMGN1dGVcXHU4MDNiXFx4YzlcXHU0MGM5XFx1MDE4MGFpeVxcdTA0ZDJcXHUwNGQ3XFx1MDRkY3JvbjtcXHU0MTFhcmNcXHU4MDNiXFx4Y2FcXHU0MGNhO1xcdTQ0MmRvdDtcXHU0MTE2cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMDhyYXZlXFx1ODAzYlxceGM4XFx1NDBjOGVtZW50O1xcdTYyMDhcXHUwMTAwYXBcXHUwNGZhXFx1MDRmZWNyO1xcdTQxMTJ0eVxcdTAyNTNcXHUwNTA2XFwwXFwwXFx1MDUxMm1hbGxTcXVhcmU7XFx1NjVmYmVyeVNtYWxsU3F1YXJlO1xcdTY1YWJcXHUwMTAwZ3BcXHUwNTI2XFx1MDUyYW9uO1xcdTQxMThmO1xcdWMwMDBcXHVkODM1XFx1ZGQzY3NpbG9uO1xcdTQzOTV1XFx1MDEwMGFpXFx1MDUzY1xcdTA1NDlsXFx1MDEwMDtUXFx1MDU0MlxcdTA1NDNcXHU2YTc1aWxkZTtcXHU2MjQybGlicml1bTtcXHU2MWNjXFx1MDEwMGNpXFx1MDU1N1xcdTA1NWFyO1xcdTYxMzBtO1xcdTZhNzNhO1xcdTQzOTdtbFxcdTgwM2JcXHhjYlxcdTQwY2JcXHUwMTAwaXBcXHUwNTZhXFx1MDU2ZnN0cztcXHU2MjAzb25lbnRpYWxFO1xcdTYxNDdcXHUwMjgwY2Zpb3NcXHUwNTg1XFx1MDU4OFxcdTA1OGRcXHUwNWIyXFx1MDVjY3k7XFx1NDQyNHI7XFx1YzAwMFxcdWQ4MzVcXHVkZDA5bGxlZFxcdTAyNTNcXHUwNTk3XFwwXFwwXFx1MDVhM21hbGxTcXVhcmU7XFx1NjVmY2VyeVNtYWxsU3F1YXJlO1xcdTY1YWFcXHUwMzcwXFx1MDViYVxcMFxcdTA1YmZcXDBcXDBcXHUwNWM0ZjtcXHVjMDAwXFx1ZDgzNVxcdWRkM2RBbGw7XFx1NjIwMHJpZXJ0cmY7XFx1NjEzMWNcXHhmMlxcdTA1Y2JcXHUwNjAwSlRhYmNkZmdvcnN0XFx1MDVlOFxcdTA1ZWNcXHUwNWVmXFx1MDVmYVxcdTA2MDBcXHUwNjEyXFx1MDYxNlxcdTA2MWJcXHUwNjFkXFx1MDYyM1xcdTA2NmNcXHUwNjcyY3k7XFx1NDQwM1xcdTgwM2I+XFx1NDAzZW1tYVxcdTAxMDA7ZFxcdTA1ZjdcXHUwNWY4XFx1NDM5MztcXHU0M2RjcmV2ZTtcXHU0MTFlXFx1MDE4MGVpeVxcdTA2MDdcXHUwNjBjXFx1MDYxMGRpbDtcXHU0MTIycmM7XFx1NDExYztcXHU0NDEzb3Q7XFx1NDEyMHI7XFx1YzAwMFxcdWQ4MzVcXHVkZDBhO1xcdTYyZDlwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkM2VlYXRlclxcdTAzMDBFRkdMU1RcXHUwNjM1XFx1MDY0NFxcdTA2NGVcXHUwNjU2XFx1MDY1YlxcdTA2NjZxdWFsXFx1MDEwMDtMXFx1MDYzZVxcdTA2M2ZcXHU2MjY1ZXNzO1xcdTYyZGJ1bGxFcXVhbDtcXHU2MjY3cmVhdGVyO1xcdTZhYTJlc3M7XFx1NjI3N2xhbnRFcXVhbDtcXHU2YTdlaWxkZTtcXHU2MjczY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2EyO1xcdTYyNmJcXHUwNDAwQWFjZmlvc3VcXHUwNjg1XFx1MDY4YlxcdTA2OTZcXHUwNjliXFx1MDY5ZVxcdTA2YWFcXHUwNmJlXFx1MDZjYVJEY3k7XFx1NDQyYVxcdTAxMDBjdFxcdTA2OTBcXHUwNjk0ZWs7XFx1NDJjNztcXHU0MDVlaXJjO1xcdTQxMjRyO1xcdTYxMGNsYmVydFNwYWNlO1xcdTYxMGJcXHUwMWYwXFx1MDZhZlxcMFxcdTA2YjJmO1xcdTYxMGRpem9udGFsTGluZTtcXHU2NTAwXFx1MDEwMGN0XFx1MDZjM1xcdTA2YzVcXHhmMlxcdTA2YTlyb2s7XFx1NDEyNm1wXFx1MDE0NFxcdTA2ZDBcXHUwNmQ4b3duSHVtXFx4ZjBcXHUwMTJmcXVhbDtcXHU2MjRmXFx1MDcwMEVKT2FjZGZnbW5vc3R1XFx1MDZmYVxcdTA2ZmVcXHUwNzAzXFx1MDcwN1xcdTA3MGVcXHUwNzFhXFx1MDcxZVxcdTA3MjFcXHUwNzI4XFx1MDc0NFxcdTA3NzhcXHUwNzhiXFx1MDc4ZlxcdTA3OTVjeTtcXHU0NDE1bGlnO1xcdTQxMzJjeTtcXHU0NDAxY3V0ZVxcdTgwM2JcXHhjZFxcdTQwY2RcXHUwMTAwaXlcXHUwNzEzXFx1MDcxOHJjXFx1ODAzYlxceGNlXFx1NDBjZTtcXHU0NDE4b3Q7XFx1NDEzMHI7XFx1NjExMXJhdmVcXHU4MDNiXFx4Y2NcXHU0MGNjXFx1MDE4MDthcFxcdTA3MjBcXHUwNzJmXFx1MDczZlxcdTAxMDBjZ1xcdTA3MzRcXHUwNzM3cjtcXHU0MTJhaW5hcnlJO1xcdTYxNDhsaWVcXHhmM1xcdTAzZGRcXHUwMWY0XFx1MDc0OVxcMFxcdTA3NjJcXHUwMTAwO2VcXHUwNzRkXFx1MDc0ZVxcdTYyMmNcXHUwMTAwZ3JcXHUwNzUzXFx1MDc1OHJhbDtcXHU2MjJic2VjdGlvbjtcXHU2MmMyaXNpYmxlXFx1MDEwMENUXFx1MDc2Y1xcdTA3NzJvbW1hO1xcdTYwNjNpbWVzO1xcdTYwNjJcXHUwMTgwZ3B0XFx1MDc3ZlxcdTA3ODNcXHUwNzg4b247XFx1NDEyZWY7XFx1YzAwMFxcdWQ4MzVcXHVkZDQwYTtcXHU0Mzk5Y3I7XFx1NjExMGlsZGU7XFx1NDEyOFxcdTAxZWJcXHUwNzlhXFwwXFx1MDc5ZWN5O1xcdTQ0MDZsXFx1ODAzYlxceGNmXFx1NDBjZlxcdTAyODBjZm9zdVxcdTA3YWNcXHUwN2I3XFx1MDdiY1xcdTA3YzJcXHUwN2QwXFx1MDEwMGl5XFx1MDdiMVxcdTA3YjVyYztcXHU0MTM0O1xcdTQ0MTlyO1xcdWMwMDBcXHVkODM1XFx1ZGQwZHBmO1xcdWMwMDBcXHVkODM1XFx1ZGQ0MVxcdTAxZTNcXHUwN2M3XFwwXFx1MDdjY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2E1cmN5O1xcdTQ0MDhrY3k7XFx1NDQwNFxcdTAzODBISmFjZm9zXFx1MDdlNFxcdTA3ZThcXHUwN2VjXFx1MDdmMVxcdTA3ZmRcXHUwODAyXFx1MDgwOGN5O1xcdTQ0MjVjeTtcXHU0NDBjcHBhO1xcdTQzOWFcXHUwMTAwZXlcXHUwN2Y2XFx1MDdmYmRpbDtcXHU0MTM2O1xcdTQ0MWFyO1xcdWMwMDBcXHVkODM1XFx1ZGQwZXBmO1xcdWMwMDBcXHVkODM1XFx1ZGQ0MmNyO1xcdWMwMDBcXHVkODM1XFx1ZGNhNlxcdTA1ODBKVGFjZWZsbW9zdFxcdTA4MjVcXHUwODI5XFx1MDgyY1xcdTA4NTBcXHUwODYzXFx1MDliM1xcdTA5YjhcXHUwOWM3XFx1MDljZFxcdTBhMzdcXHUwYTQ3Y3k7XFx1NDQwOVxcdTgwM2I8XFx1NDAzY1xcdTAyODBjbW5wclxcdTA4MzdcXHUwODNjXFx1MDg0MVxcdTA4NDRcXHUwODRkdXRlO1xcdTQxMzliZGE7XFx1NDM5Ymc7XFx1NjdlYWxhY2V0cmY7XFx1NjExMnI7XFx1NjE5ZVxcdTAxODBhZXlcXHUwODU3XFx1MDg1Y1xcdTA4NjFyb247XFx1NDEzZGRpbDtcXHU0MTNiO1xcdTQ0MWJcXHUwMTAwZnNcXHUwODY4XFx1MDk3MHRcXHUwNTAwQUNERlJUVVZhclxcdTA4N2VcXHUwOGE5XFx1MDhiMVxcdTA4ZTBcXHUwOGU2XFx1MDhmY1xcdTA5MmZcXHUwOTViXFx1MDM5MFxcdTA5NmFcXHUwMTAwbnJcXHUwODgzXFx1MDg4ZmdsZUJyYWNrZXQ7XFx1NjdlOHJvd1xcdTAxODA7QlJcXHUwODk5XFx1MDg5YVxcdTA4OWVcXHU2MTkwYXI7XFx1NjFlNGlnaHRBcnJvdztcXHU2MWM2ZWlsaW5nO1xcdTYzMDhvXFx1MDFmNVxcdTA4YjdcXDBcXHUwOGMzYmxlQnJhY2tldDtcXHU2N2U2blxcdTAxZDRcXHUwOGM4XFwwXFx1MDhkMmVlVmVjdG9yO1xcdTY5NjFlY3RvclxcdTAxMDA7QlxcdTA4ZGJcXHUwOGRjXFx1NjFjM2FyO1xcdTY5NTlsb29yO1xcdTYzMGFpZ2h0XFx1MDEwMEFWXFx1MDhlZlxcdTA4ZjVycm93O1xcdTYxOTRlY3RvcjtcXHU2OTRlXFx1MDEwMGVyXFx1MDkwMVxcdTA5MTdlXFx1MDE4MDtBVlxcdTA5MDlcXHUwOTBhXFx1MDkxMFxcdTYyYTNycm93O1xcdTYxYTRlY3RvcjtcXHU2OTVhaWFuZ2xlXFx1MDE4MDtCRVxcdTA5MjRcXHUwOTI1XFx1MDkyOVxcdTYyYjJhcjtcXHU2OWNmcXVhbDtcXHU2MmI0cFxcdTAxODBEVFZcXHUwOTM3XFx1MDk0MlxcdTA5NGNvd25WZWN0b3I7XFx1Njk1MWVlVmVjdG9yO1xcdTY5NjBlY3RvclxcdTAxMDA7QlxcdTA5NTZcXHUwOTU3XFx1NjFiZmFyO1xcdTY5NThlY3RvclxcdTAxMDA7QlxcdTA5NjVcXHUwOTY2XFx1NjFiY2FyO1xcdTY5NTJpZ2h0XFx4ZTFcXHUwMzljc1xcdTAzMDBFRkdMU1RcXHUwOTdlXFx1MDk4YlxcdTA5OTVcXHUwOTlkXFx1MDlhMlxcdTA5YWRxdWFsR3JlYXRlcjtcXHU2MmRhdWxsRXF1YWw7XFx1NjI2NnJlYXRlcjtcXHU2Mjc2ZXNzO1xcdTZhYTFsYW50RXF1YWw7XFx1NmE3ZGlsZGU7XFx1NjI3MnI7XFx1YzAwMFxcdWQ4MzVcXHVkZDBmXFx1MDEwMDtlXFx1MDliZFxcdTA5YmVcXHU2MmQ4ZnRhcnJvdztcXHU2MWRhaWRvdDtcXHU0MTNmXFx1MDE4MG5wd1xcdTA5ZDRcXHUwYTE2XFx1MGExYmdcXHUwMjAwTFJsclxcdTA5ZGVcXHUwOWY3XFx1MGEwMlxcdTBhMTBlZnRcXHUwMTAwQVJcXHUwOWU2XFx1MDllY3Jyb3c7XFx1NjdmNWlnaHRBcnJvdztcXHU2N2Y3aWdodEFycm93O1xcdTY3ZjZlZnRcXHUwMTAwYXJcXHUwM2IzXFx1MGEwYWlnaHRcXHhlMVxcdTAzYmZpZ2h0XFx4ZTFcXHUwM2NhZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNDNlclxcdTAxMDBMUlxcdTBhMjJcXHUwYTJjZWZ0QXJyb3c7XFx1NjE5OWlnaHRBcnJvdztcXHU2MTk4XFx1MDE4MGNodFxcdTBhM2VcXHUwYTQwXFx1MGE0MlxceGYyXFx1MDg0YztcXHU2MWIwcm9rO1xcdTQxNDE7XFx1NjI2YVxcdTA0MDBhY2VmaW9zdVxcdTBhNWFcXHUwYTVkXFx1MGE2MFxcdTBhNzdcXHUwYTdjXFx1MGE4NVxcdTBhOGJcXHUwYThlcDtcXHU2OTA1eTtcXHU0NDFjXFx1MDEwMGRsXFx1MGE2NVxcdTBhNmZpdW1TcGFjZTtcXHU2MDVmbGludHJmO1xcdTYxMzNyO1xcdWMwMDBcXHVkODM1XFx1ZGQxMG51c1BsdXM7XFx1NjIxM3BmO1xcdWMwMDBcXHVkODM1XFx1ZGQ0NGNcXHhmMlxcdTBhNzY7XFx1NDM5Y1xcdTA0ODBKYWNlZm9zdHVcXHUwYWEzXFx1MGFhN1xcdTBhYWRcXHUwYWMwXFx1MGIxNFxcdTBiMTlcXHUwZDkxXFx1MGQ5N1xcdTBkOWVjeTtcXHU0NDBhY3V0ZTtcXHU0MTQzXFx1MDE4MGFleVxcdTBhYjRcXHUwYWI5XFx1MGFiZXJvbjtcXHU0MTQ3ZGlsO1xcdTQxNDU7XFx1NDQxZFxcdTAxODBnc3dcXHUwYWM3XFx1MGFmMFxcdTBiMGVhdGl2ZVxcdTAxODBNVFZcXHUwYWQzXFx1MGFkZlxcdTBhZThlZGl1bVNwYWNlO1xcdTYwMGJoaVxcdTAxMDBjblxcdTBhZTZcXHUwYWQ4XFx4ZWJcXHUwYWQ5ZXJ5VGhpXFx4ZWVcXHUwYWQ5dGVkXFx1MDEwMEdMXFx1MGFmOFxcdTBiMDZyZWF0ZXJHcmVhdGVcXHhmMlxcdTA2NzNlc3NMZXNcXHhmM1xcdTBhNDhMaW5lO1xcdTQwMGFyO1xcdWMwMDBcXHVkODM1XFx1ZGQxMVxcdTAyMDBCbnB0XFx1MGIyMlxcdTBiMjhcXHUwYjM3XFx1MGIzYXJlYWs7XFx1NjA2MEJyZWFraW5nU3BhY2U7XFx1NDBhMGY7XFx1NjExNVxcdTA2ODA7Q0RFR0hMTlBSU1RWXFx1MGI1NVxcdTBiNTZcXHUwYjZhXFx1MGI3Y1xcdTBiYTFcXHUwYmViXFx1MGMwNFxcdTBjNWVcXHUwYzg0XFx1MGNhNlxcdTBjZDhcXHUwZDYxXFx1MGQ4NVxcdTZhZWNcXHUwMTAwb3VcXHUwYjViXFx1MGI2NG5ncnVlbnQ7XFx1NjI2MnBDYXA7XFx1NjI2ZG91YmxlVmVydGljYWxCYXI7XFx1NjIyNlxcdTAxODBscXhcXHUwYjgzXFx1MGI4YVxcdTBiOWJlbWVudDtcXHU2MjA5dWFsXFx1MDEwMDtUXFx1MGI5MlxcdTBiOTNcXHU2MjYwaWxkZTtcXHVjMDAwXFx1MjI0MlxcdTAzMzhpc3RzO1xcdTYyMDRyZWF0ZXJcXHUwMzgwO0VGR0xTVFxcdTBiYjZcXHUwYmI3XFx1MGJiZFxcdTBiYzlcXHUwYmQzXFx1MGJkOFxcdTBiZTVcXHU2MjZmcXVhbDtcXHU2MjcxdWxsRXF1YWw7XFx1YzAwMFxcdTIyNjdcXHUwMzM4cmVhdGVyO1xcdWMwMDBcXHUyMjZiXFx1MDMzOGVzcztcXHU2Mjc5bGFudEVxdWFsO1xcdWMwMDBcXHUyYTdlXFx1MDMzOGlsZGU7XFx1NjI3NXVtcFxcdTAxNDRcXHUwYmYyXFx1MGJmZG93bkh1bXA7XFx1YzAwMFxcdTIyNGVcXHUwMzM4cXVhbDtcXHVjMDAwXFx1MjI0ZlxcdTAzMzhlXFx1MDEwMGZzXFx1MGMwYVxcdTBjMjd0VHJpYW5nbGVcXHUwMTgwO0JFXFx1MGMxYVxcdTBjMWJcXHUwYzIxXFx1NjJlYWFyO1xcdWMwMDBcXHUyOWNmXFx1MDMzOHF1YWw7XFx1NjJlY3NcXHUwMzAwO0VHTFNUXFx1MGMzNVxcdTBjMzZcXHUwYzNjXFx1MGM0NFxcdTBjNGJcXHUwYzU4XFx1NjI2ZXF1YWw7XFx1NjI3MHJlYXRlcjtcXHU2Mjc4ZXNzO1xcdWMwMDBcXHUyMjZhXFx1MDMzOGxhbnRFcXVhbDtcXHVjMDAwXFx1MmE3ZFxcdTAzMzhpbGRlO1xcdTYyNzRlc3RlZFxcdTAxMDBHTFxcdTBjNjhcXHUwYzc5cmVhdGVyR3JlYXRlcjtcXHVjMDAwXFx1MmFhMlxcdTAzMzhlc3NMZXNzO1xcdWMwMDBcXHUyYWExXFx1MDMzOHJlY2VkZXNcXHUwMTgwO0VTXFx1MGM5MlxcdTBjOTNcXHUwYzliXFx1NjI4MHF1YWw7XFx1YzAwMFxcdTJhYWZcXHUwMzM4bGFudEVxdWFsO1xcdTYyZTBcXHUwMTAwZWlcXHUwY2FiXFx1MGNiOXZlcnNlRWxlbWVudDtcXHU2MjBjZ2h0VHJpYW5nbGVcXHUwMTgwO0JFXFx1MGNjYlxcdTBjY2NcXHUwY2QyXFx1NjJlYmFyO1xcdWMwMDBcXHUyOWQwXFx1MDMzOHF1YWw7XFx1NjJlZFxcdTAxMDBxdVxcdTBjZGRcXHUwZDBjdWFyZVN1XFx1MDEwMGJwXFx1MGNlOFxcdTBjZjlzZXRcXHUwMTAwO0VcXHUwY2YwXFx1MGNmM1xcdWMwMDBcXHUyMjhmXFx1MDMzOHF1YWw7XFx1NjJlMmVyc2V0XFx1MDEwMDtFXFx1MGQwM1xcdTBkMDZcXHVjMDAwXFx1MjI5MFxcdTAzMzhxdWFsO1xcdTYyZTNcXHUwMTgwYmNwXFx1MGQxM1xcdTBkMjRcXHUwZDRlc2V0XFx1MDEwMDtFXFx1MGQxYlxcdTBkMWVcXHVjMDAwXFx1MjI4MlxcdTIwZDJxdWFsO1xcdTYyODhjZWVkc1xcdTAyMDA7RVNUXFx1MGQzMlxcdTBkMzNcXHUwZDNiXFx1MGQ0NlxcdTYyODFxdWFsO1xcdWMwMDBcXHUyYWIwXFx1MDMzOGxhbnRFcXVhbDtcXHU2MmUxaWxkZTtcXHVjMDAwXFx1MjI3ZlxcdTAzMzhlcnNldFxcdTAxMDA7RVxcdTBkNThcXHUwZDViXFx1YzAwMFxcdTIyODNcXHUyMGQycXVhbDtcXHU2Mjg5aWxkZVxcdTAyMDA7RUZUXFx1MGQ2ZVxcdTBkNmZcXHUwZDc1XFx1MGQ3ZlxcdTYyNDFxdWFsO1xcdTYyNDR1bGxFcXVhbDtcXHU2MjQ3aWxkZTtcXHU2MjQ5ZXJ0aWNhbEJhcjtcXHU2MjI0Y3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2E5aWxkZVxcdTgwM2JcXHhkMVxcdTQwZDE7XFx1NDM5ZFxcdTA3MDBFYWNkZmdtb3Byc3R1dlxcdTBkYmRcXHUwZGMyXFx1MGRjOVxcdTBkZDVcXHUwZGRiXFx1MGRlMFxcdTBkZTdcXHUwZGZjXFx1MGUwMlxcdTBlMjBcXHUwZTIyXFx1MGUzMlxcdTBlM2ZcXHUwZTQ0bGlnO1xcdTQxNTJjdXRlXFx1ODAzYlxceGQzXFx1NDBkM1xcdTAxMDBpeVxcdTBkY2VcXHUwZGQzcmNcXHU4MDNiXFx4ZDRcXHU0MGQ0O1xcdTQ0MWVibGFjO1xcdTQxNTByO1xcdWMwMDBcXHVkODM1XFx1ZGQxMnJhdmVcXHU4MDNiXFx4ZDJcXHU0MGQyXFx1MDE4MGFlaVxcdTBkZWVcXHUwZGYyXFx1MGRmNmNyO1xcdTQxNGNnYTtcXHU0M2E5Y3JvbjtcXHU0MzlmcGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDQ2ZW5DdXJseVxcdTAxMDBEUVxcdTBlMGVcXHUwZTFhb3VibGVRdW90ZTtcXHU2MDFjdW90ZTtcXHU2MDE4O1xcdTZhNTRcXHUwMTAwY2xcXHUwZTI3XFx1MGUyY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2FhYXNoXFx1ODAzYlxceGQ4XFx1NDBkOGlcXHUwMTZjXFx1MGUzN1xcdTBlM2NkZVxcdTgwM2JcXHhkNVxcdTQwZDVlcztcXHU2YTM3bWxcXHU4MDNiXFx4ZDZcXHU0MGQ2ZXJcXHUwMTAwQlBcXHUwZTRiXFx1MGU2MFxcdTAxMDBhclxcdTBlNTBcXHUwZTUzcjtcXHU2MDNlYWNcXHUwMTAwZWtcXHUwZTVhXFx1MGU1YztcXHU2M2RlZXQ7XFx1NjNiNGFyZW50aGVzaXM7XFx1NjNkY1xcdTA0ODBhY2ZoaWxvcnNcXHUwZTdmXFx1MGU4N1xcdTBlOGFcXHUwZThmXFx1MGU5MlxcdTBlOTRcXHUwZTlkXFx1MGViMFxcdTBlZmNydGlhbEQ7XFx1NjIwMnk7XFx1NDQxZnI7XFx1YzAwMFxcdWQ4MzVcXHVkZDEzaTtcXHU0M2E2O1xcdTQzYTB1c01pbnVzO1xcdTQwYjFcXHUwMTAwaXBcXHUwZWEyXFx1MGVhZG5jYXJlcGxhblxceGU1XFx1MDY5ZGY7XFx1NjExOVxcdTAyMDA7ZWlvXFx1MGViOVxcdTBlYmFcXHUwZWUwXFx1MGVlNFxcdTZhYmJjZWRlc1xcdTAyMDA7RVNUXFx1MGVjOFxcdTBlYzlcXHUwZWNmXFx1MGVkYVxcdTYyN2FxdWFsO1xcdTZhYWZsYW50RXF1YWw7XFx1NjI3Y2lsZGU7XFx1NjI3ZW1lO1xcdTYwMzNcXHUwMTAwZHBcXHUwZWU5XFx1MGVlZXVjdDtcXHU2MjBmb3J0aW9uXFx1MDEwMDthXFx1MDIyNVxcdTBlZjlsO1xcdTYyMWRcXHUwMTAwY2lcXHUwZjAxXFx1MGYwNnI7XFx1YzAwMFxcdWQ4MzVcXHVkY2FiO1xcdTQzYThcXHUwMjAwVWZvc1xcdTBmMTFcXHUwZjE2XFx1MGYxYlxcdTBmMWZPVFxcdTgwM2JcXFwiXFx1NDAyMnI7XFx1YzAwMFxcdWQ4MzVcXHVkZDE0cGY7XFx1NjExYWNyO1xcdWMwMDBcXHVkODM1XFx1ZGNhY1xcdTA2MDBCRWFjZWZoaW9yc3VcXHUwZjNlXFx1MGY0M1xcdTBmNDdcXHUwZjYwXFx1MGY3M1xcdTBmYTdcXHUwZmFhXFx1MGZhZFxcdTEwOTZcXHUxMGE5XFx1MTBiNFxcdTEwYmVhcnI7XFx1NjkxMEdcXHU4MDNiXFx4YWVcXHU0MGFlXFx1MDE4MGNuclxcdTBmNGVcXHUwZjUzXFx1MGY1NnV0ZTtcXHU0MTU0ZztcXHU2N2ViclxcdTAxMDA7dFxcdTBmNWNcXHUwZjVkXFx1NjFhMGw7XFx1NjkxNlxcdTAxODBhZXlcXHUwZjY3XFx1MGY2Y1xcdTBmNzFyb247XFx1NDE1OGRpbDtcXHU0MTU2O1xcdTQ0MjBcXHUwMTAwO3ZcXHUwZjc4XFx1MGY3OVxcdTYxMWNlcnNlXFx1MDEwMEVVXFx1MGY4MlxcdTBmOTlcXHUwMTAwbHFcXHUwZjg3XFx1MGY4ZWVtZW50O1xcdTYyMGJ1aWxpYnJpdW07XFx1NjFjYnBFcXVpbGlicml1bTtcXHU2OTZmclxceGJiXFx1MGY3OW87XFx1NDNhMWdodFxcdTA0MDBBQ0RGVFVWYVxcdTBmYzFcXHUwZmViXFx1MGZmM1xcdTEwMjJcXHUxMDI4XFx1MTA1YlxcdTEwODdcXHUwM2Q4XFx1MDEwMG5yXFx1MGZjNlxcdTBmZDJnbGVCcmFja2V0O1xcdTY3ZTlyb3dcXHUwMTgwO0JMXFx1MGZkY1xcdTBmZGRcXHUwZmUxXFx1NjE5MmFyO1xcdTYxZTVlZnRBcnJvdztcXHU2MWM0ZWlsaW5nO1xcdTYzMDlvXFx1MDFmNVxcdTBmZjlcXDBcXHUxMDA1YmxlQnJhY2tldDtcXHU2N2U3blxcdTAxZDRcXHUxMDBhXFwwXFx1MTAxNGVlVmVjdG9yO1xcdTY5NWRlY3RvclxcdTAxMDA7QlxcdTEwMWRcXHUxMDFlXFx1NjFjMmFyO1xcdTY5NTVsb29yO1xcdTYzMGJcXHUwMTAwZXJcXHUxMDJkXFx1MTA0M2VcXHUwMTgwO0FWXFx1MTAzNVxcdTEwMzZcXHUxMDNjXFx1NjJhMnJyb3c7XFx1NjFhNmVjdG9yO1xcdTY5NWJpYW5nbGVcXHUwMTgwO0JFXFx1MTA1MFxcdTEwNTFcXHUxMDU1XFx1NjJiM2FyO1xcdTY5ZDBxdWFsO1xcdTYyYjVwXFx1MDE4MERUVlxcdTEwNjNcXHUxMDZlXFx1MTA3OG93blZlY3RvcjtcXHU2OTRmZWVWZWN0b3I7XFx1Njk1Y2VjdG9yXFx1MDEwMDtCXFx1MTA4MlxcdTEwODNcXHU2MWJlYXI7XFx1Njk1NGVjdG9yXFx1MDEwMDtCXFx1MTA5MVxcdTEwOTJcXHU2MWMwYXI7XFx1Njk1M1xcdTAxMDBwdVxcdTEwOWJcXHUxMDllZjtcXHU2MTFkbmRJbXBsaWVzO1xcdTY5NzBpZ2h0YXJyb3c7XFx1NjFkYlxcdTAxMDBjaFxcdTEwYjlcXHUxMGJjcjtcXHU2MTFiO1xcdTYxYjFsZURlbGF5ZWQ7XFx1NjlmNFxcdTA2ODBIT2FjZmhpbW9xc3R1XFx1MTBlNFxcdTEwZjFcXHUxMGY3XFx1MTBmZFxcdTExMTlcXHUxMTFlXFx1MTE1MVxcdTExNTZcXHUxMTYxXFx1MTE2N1xcdTExYjVcXHUxMWJiXFx1MTFiZlxcdTAxMDBDY1xcdTEwZTlcXHUxMGVlSGN5O1xcdTQ0Mjl5O1xcdTQ0MjhGVGN5O1xcdTQ0MmNjdXRlO1xcdTQxNWFcXHUwMjgwO2FlaXlcXHUxMTA4XFx1MTEwOVxcdTExMGVcXHUxMTEzXFx1MTExN1xcdTZhYmNyb247XFx1NDE2MGRpbDtcXHU0MTVlcmM7XFx1NDE1YztcXHU0NDIxcjtcXHVjMDAwXFx1ZDgzNVxcdWRkMTZvcnRcXHUwMjAwRExSVVxcdTExMmFcXHUxMTM0XFx1MTEzZVxcdTExNDlvd25BcnJvd1xceGJiXFx1MDQxZWVmdEFycm93XFx4YmJcXHUwODlhaWdodEFycm93XFx4YmJcXHUwZmRkcEFycm93O1xcdTYxOTFnbWE7XFx1NDNhM2FsbENpcmNsZTtcXHU2MjE4cGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDRhXFx1MDI3MlxcdTExNmRcXDBcXDBcXHUxMTcwdDtcXHU2MjFhYXJlXFx1MDIwMDtJU1VcXHUxMTdiXFx1MTE3Y1xcdTExODlcXHUxMWFmXFx1NjVhMW50ZXJzZWN0aW9uO1xcdTYyOTN1XFx1MDEwMGJwXFx1MTE4ZlxcdTExOWVzZXRcXHUwMTAwO0VcXHUxMTk3XFx1MTE5OFxcdTYyOGZxdWFsO1xcdTYyOTFlcnNldFxcdTAxMDA7RVxcdTExYThcXHUxMWE5XFx1NjI5MHF1YWw7XFx1NjI5Mm5pb247XFx1NjI5NGNyO1xcdWMwMDBcXHVkODM1XFx1ZGNhZWFyO1xcdTYyYzZcXHUwMjAwYmNtcFxcdTExYzhcXHUxMWRiXFx1MTIwOVxcdTEyMGJcXHUwMTAwO3NcXHUxMWNkXFx1MTFjZVxcdTYyZDBldFxcdTAxMDA7RVxcdTExY2RcXHUxMWQ1cXVhbDtcXHU2Mjg2XFx1MDEwMGNoXFx1MTFlMFxcdTEyMDVlZWRzXFx1MDIwMDtFU1RcXHUxMWVkXFx1MTFlZVxcdTExZjRcXHUxMWZmXFx1NjI3YnF1YWw7XFx1NmFiMGxhbnRFcXVhbDtcXHU2MjdkaWxkZTtcXHU2MjdmVGhcXHhlMVxcdTBmOGM7XFx1NjIxMVxcdTAxODA7ZXNcXHUxMjEyXFx1MTIxM1xcdTEyMjNcXHU2MmQxcnNldFxcdTAxMDA7RVxcdTEyMWNcXHUxMjFkXFx1NjI4M3F1YWw7XFx1NjI4N2V0XFx4YmJcXHUxMjEzXFx1MDU4MEhSU2FjZmhpb3JzXFx1MTIzZVxcdTEyNDRcXHUxMjQ5XFx1MTI1NVxcdTEyNWVcXHUxMjcxXFx1MTI3NlxcdTEyOWZcXHUxMmMyXFx1MTJjOFxcdTEyZDFPUk5cXHU4MDNiXFx4ZGVcXHU0MGRlQURFO1xcdTYxMjJcXHUwMTAwSGNcXHUxMjRlXFx1MTI1MmN5O1xcdTQ0MGJ5O1xcdTQ0MjZcXHUwMTAwYnVcXHUxMjVhXFx1MTI1YztcXHU0MDA5O1xcdTQzYTRcXHUwMTgwYWV5XFx1MTI2NVxcdTEyNmFcXHUxMjZmcm9uO1xcdTQxNjRkaWw7XFx1NDE2MjtcXHU0NDIycjtcXHVjMDAwXFx1ZDgzNVxcdWRkMTdcXHUwMTAwZWlcXHUxMjdiXFx1MTI4OVxcdTAxZjJcXHUxMjgwXFwwXFx1MTI4N2Vmb3JlO1xcdTYyMzRhO1xcdTQzOThcXHUwMTAwY25cXHUxMjhlXFx1MTI5OGtTcGFjZTtcXHVjMDAwXFx1MjA1ZlxcdTIwMGFTcGFjZTtcXHU2MDA5bGRlXFx1MDIwMDtFRlRcXHUxMmFiXFx1MTJhY1xcdTEyYjJcXHUxMmJjXFx1NjIzY3F1YWw7XFx1NjI0M3VsbEVxdWFsO1xcdTYyNDVpbGRlO1xcdTYyNDhwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNGJpcGxlRG90O1xcdTYwZGJcXHUwMTAwY3RcXHUxMmQ2XFx1MTJkYnI7XFx1YzAwMFxcdWQ4MzVcXHVkY2Fmcm9rO1xcdTQxNjZcXHUwYWUxXFx1MTJmN1xcdTEzMGVcXHUxMzFhXFx1MTMyNlxcMFxcdTEzMmNcXHUxMzMxXFwwXFwwXFwwXFwwXFwwXFx1MTMzOFxcdTEzM2RcXHUxMzc3XFx1MTM4NVxcMFxcdTEzZmZcXHUxNDA0XFx1MTQwYVxcdTE0MTBcXHUwMTAwY3JcXHUxMmZiXFx1MTMwMXV0ZVxcdTgwM2JcXHhkYVxcdTQwZGFyXFx1MDEwMDtvXFx1MTMwN1xcdTEzMDhcXHU2MTlmY2lyO1xcdTY5NDlyXFx1MDFlM1xcdTEzMTNcXDBcXHUxMzE2eTtcXHU0NDBldmU7XFx1NDE2Y1xcdTAxMDBpeVxcdTEzMWVcXHUxMzIzcmNcXHU4MDNiXFx4ZGJcXHU0MGRiO1xcdTQ0MjNibGFjO1xcdTQxNzByO1xcdWMwMDBcXHVkODM1XFx1ZGQxOHJhdmVcXHU4MDNiXFx4ZDlcXHU0MGQ5YWNyO1xcdTQxNmFcXHUwMTAwZGlcXHUxMzQxXFx1MTM2OWVyXFx1MDEwMEJQXFx1MTM0OFxcdTEzNWRcXHUwMTAwYXJcXHUxMzRkXFx1MTM1MHI7XFx1NDA1ZmFjXFx1MDEwMGVrXFx1MTM1N1xcdTEzNTk7XFx1NjNkZmV0O1xcdTYzYjVhcmVudGhlc2lzO1xcdTYzZGRvblxcdTAxMDA7UFxcdTEzNzBcXHUxMzcxXFx1NjJjM2x1cztcXHU2MjhlXFx1MDEwMGdwXFx1MTM3YlxcdTEzN2ZvbjtcXHU0MTcyZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNGNcXHUwNDAwQURFVGFkcHNcXHUxMzk1XFx1MTNhZVxcdTEzYjhcXHUxM2M0XFx1MDNlOFxcdTEzZDJcXHUxM2Q3XFx1MTNmM3Jyb3dcXHUwMTgwO0JEXFx1MTE1MFxcdTEzYTBcXHUxM2E0YXI7XFx1NjkxMm93bkFycm93O1xcdTYxYzVvd25BcnJvdztcXHU2MTk1cXVpbGlicml1bTtcXHU2OTZlZWVcXHUwMTAwO0FcXHUxM2NiXFx1MTNjY1xcdTYyYTVycm93O1xcdTYxYTVvd25cXHhlMVxcdTAzZjNlclxcdTAxMDBMUlxcdTEzZGVcXHUxM2U4ZWZ0QXJyb3c7XFx1NjE5NmlnaHRBcnJvdztcXHU2MTk3aVxcdTAxMDA7bFxcdTEzZjlcXHUxM2ZhXFx1NDNkMm9uO1xcdTQzYTVpbmc7XFx1NDE2ZWNyO1xcdWMwMDBcXHVkODM1XFx1ZGNiMGlsZGU7XFx1NDE2OG1sXFx1ODAzYlxceGRjXFx1NDBkY1xcdTA0ODBEYmNkZWZvc3ZcXHUxNDI3XFx1MTQyY1xcdTE0MzBcXHUxNDMzXFx1MTQzZVxcdTE0ODVcXHUxNDhhXFx1MTQ5MFxcdTE0OTZhc2g7XFx1NjJhYmFyO1xcdTZhZWJ5O1xcdTQ0MTJhc2hcXHUwMTAwO2xcXHUxNDNiXFx1MTQzY1xcdTYyYTk7XFx1NmFlNlxcdTAxMDBlclxcdTE0NDNcXHUxNDQ1O1xcdTYyYzFcXHUwMTgwYnR5XFx1MTQ0Y1xcdTE0NTBcXHUxNDdhYXI7XFx1NjAxNlxcdTAxMDA7aVxcdTE0NGZcXHUxNDU1Y2FsXFx1MDIwMEJMU1RcXHUxNDYxXFx1MTQ2NVxcdTE0NmFcXHUxNDc0YXI7XFx1NjIyM2luZTtcXHU0MDdjZXBhcmF0b3I7XFx1Njc1OGlsZGU7XFx1NjI0MFRoaW5TcGFjZTtcXHU2MDBhcjtcXHVjMDAwXFx1ZDgzNVxcdWRkMTlwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNGRjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYjFkYXNoO1xcdTYyYWFcXHUwMjgwY2Vmb3NcXHUxNGE3XFx1MTRhY1xcdTE0YjFcXHUxNGI2XFx1MTRiY2lyYztcXHU0MTc0ZGdlO1xcdTYyYzByO1xcdWMwMDBcXHVkODM1XFx1ZGQxYXBmO1xcdWMwMDBcXHVkODM1XFx1ZGQ0ZWNyO1xcdWMwMDBcXHVkODM1XFx1ZGNiMlxcdTAyMDBmaW9zXFx1MTRjYlxcdTE0ZDBcXHUxNGQyXFx1MTRkOHI7XFx1YzAwMFxcdWQ4MzVcXHVkZDFiO1xcdTQzOWVwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNGZjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYjNcXHUwNDgwQUlVYWNmb3N1XFx1MTRmMVxcdTE0ZjVcXHUxNGY5XFx1MTRmZFxcdTE1MDRcXHUxNTBmXFx1MTUxNFxcdTE1MWFcXHUxNTIwY3k7XFx1NDQyZmN5O1xcdTQ0MDdjeTtcXHU0NDJlY3V0ZVxcdTgwM2JcXHhkZFxcdTQwZGRcXHUwMTAwaXlcXHUxNTA5XFx1MTUwZHJjO1xcdTQxNzY7XFx1NDQyYnI7XFx1YzAwMFxcdWQ4MzVcXHVkZDFjcGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDUwY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2I0bWw7XFx1NDE3OFxcdTA0MDBIYWNkZWZvc1xcdTE1MzVcXHUxNTM5XFx1MTUzZlxcdTE1NGJcXHUxNTRmXFx1MTU1ZFxcdTE1NjBcXHUxNTY0Y3k7XFx1NDQxNmN1dGU7XFx1NDE3OVxcdTAxMDBheVxcdTE1NDRcXHUxNTQ5cm9uO1xcdTQxN2Q7XFx1NDQxN290O1xcdTQxN2JcXHUwMWYyXFx1MTU1NFxcMFxcdTE1NWJvV2lkdFxceGU4XFx1MGFkOWE7XFx1NDM5NnI7XFx1NjEyOHBmO1xcdTYxMjRjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYjVcXHUwYmUxXFx1MTU4M1xcdTE1OGFcXHUxNTkwXFwwXFx1MTViMFxcdTE1YjZcXHUxNWJmXFwwXFwwXFwwXFwwXFx1MTVjNlxcdTE1ZGJcXHUxNWViXFx1MTY1ZlxcdTE2NmRcXDBcXHUxNjk1XFx1MTY5YlxcdTE2YjJcXHUxNmI5XFwwXFx1MTZiZWN1dGVcXHU4MDNiXFx4ZTFcXHU0MGUxcmV2ZTtcXHU0MTAzXFx1MDMwMDtFZGl1eVxcdTE1OWNcXHUxNTlkXFx1MTVhMVxcdTE1YTNcXHUxNWE4XFx1MTVhZFxcdTYyM2U7XFx1YzAwMFxcdTIyM2VcXHUwMzMzO1xcdTYyM2ZyY1xcdTgwM2JcXHhlMlxcdTQwZTJ0ZVxcdTgwYmJcXHhiNFxcdTAzMDY7XFx1NDQzMGxpZ1xcdTgwM2JcXHhlNlxcdTQwZTZcXHUwMTAwO3JcXHhiMlxcdTE1YmE7XFx1YzAwMFxcdWQ4MzVcXHVkZDFlcmF2ZVxcdTgwM2JcXHhlMFxcdTQwZTBcXHUwMTAwZXBcXHUxNWNhXFx1MTVkNlxcdTAxMDBmcFxcdTE1Y2ZcXHUxNWQ0c3ltO1xcdTYxMzVcXHhlOFxcdTE1ZDNoYTtcXHU0M2IxXFx1MDEwMGFwXFx1MTVkZmNcXHUwMTAwY2xcXHUxNWU0XFx1MTVlN3I7XFx1NDEwMWc7XFx1NmEzZlxcdTAyNjRcXHUxNWYwXFwwXFwwXFx1MTYwYVxcdTAyODA7YWRzdlxcdTE1ZmFcXHUxNWZiXFx1MTVmZlxcdTE2MDFcXHUxNjA3XFx1NjIyN25kO1xcdTZhNTU7XFx1NmE1Y2xvcGU7XFx1NmE1ODtcXHU2YTVhXFx1MDM4MDtlbG1yc3pcXHUxNjE4XFx1MTYxOVxcdTE2MWJcXHUxNjFlXFx1MTYzZlxcdTE2NGZcXHUxNjU5XFx1NjIyMDtcXHU2OWE0ZVxceGJiXFx1MTYxOXNkXFx1MDEwMDthXFx1MTYyNVxcdTE2MjZcXHU2MjIxXFx1MDQ2MVxcdTE2MzBcXHUxNjMyXFx1MTYzNFxcdTE2MzZcXHUxNjM4XFx1MTYzYVxcdTE2M2NcXHUxNjNlO1xcdTY5YTg7XFx1NjlhOTtcXHU2OWFhO1xcdTY5YWI7XFx1NjlhYztcXHU2OWFkO1xcdTY5YWU7XFx1NjlhZnRcXHUwMTAwO3ZcXHUxNjQ1XFx1MTY0NlxcdTYyMWZiXFx1MDEwMDtkXFx1MTY0Y1xcdTE2NGRcXHU2MmJlO1xcdTY5OWRcXHUwMTAwcHRcXHUxNjU0XFx1MTY1N2g7XFx1NjIyMlxceGJiXFx4YjlhcnI7XFx1NjM3Y1xcdTAxMDBncFxcdTE2NjNcXHUxNjY3b247XFx1NDEwNWY7XFx1YzAwMFxcdWQ4MzVcXHVkZDUyXFx1MDM4MDtFYWVpb3BcXHUxMmMxXFx1MTY3YlxcdTE2N2RcXHUxNjgyXFx1MTY4NFxcdTE2ODdcXHUxNjhhO1xcdTZhNzBjaXI7XFx1NmE2ZjtcXHU2MjRhZDtcXHU2MjRicztcXHU0MDI3cm94XFx1MDEwMDtlXFx1MTJjMVxcdTE2OTJcXHhmMVxcdTE2ODNpbmdcXHU4MDNiXFx4ZTVcXHU0MGU1XFx1MDE4MGN0eVxcdTE2YTFcXHUxNmE2XFx1MTZhOHI7XFx1YzAwMFxcdWQ4MzVcXHVkY2I2O1xcdTQwMmFtcFxcdTAxMDA7ZVxcdTEyYzFcXHUxNmFmXFx4ZjFcXHUwMjg4aWxkZVxcdTgwM2JcXHhlM1xcdTQwZTNtbFxcdTgwM2JcXHhlNFxcdTQwZTRcXHUwMTAwY2lcXHUxNmMyXFx1MTZjOG9uaW5cXHhmNFxcdTAyNzJudDtcXHU2YTExXFx1MDgwME5hYmNkZWZpa2xub3Byc3VcXHUxNmVkXFx1MTZmMVxcdTE3MzBcXHUxNzNjXFx1MTc0M1xcdTE3NDhcXHUxNzc4XFx1MTc3ZFxcdTE3ZTBcXHUxN2U2XFx1MTgzOVxcdTE4NTBcXHUxNzBkXFx1MTkzZFxcdTE5NDhcXHUxOTcwb3Q7XFx1NmFlZFxcdTAxMDBjclxcdTE2ZjZcXHUxNzFla1xcdTAyMDBjZXBzXFx1MTcwMFxcdTE3MDVcXHUxNzBkXFx1MTcxM29uZztcXHU2MjRjcHNpbG9uO1xcdTQzZjZyaW1lO1xcdTYwMzVpbVxcdTAxMDA7ZVxcdTE3MWFcXHUxNzFiXFx1NjIzZHE7XFx1NjJjZFxcdTAxNzZcXHUxNzIyXFx1MTcyNmVlO1xcdTYyYmRlZFxcdTAxMDA7Z1xcdTE3MmNcXHUxNzJkXFx1NjMwNWVcXHhiYlxcdTE3MmRya1xcdTAxMDA7dFxcdTEzNWNcXHUxNzM3YnJrO1xcdTYzYjZcXHUwMTAwb3lcXHUxNzAxXFx1MTc0MTtcXHU0NDMxcXVvO1xcdTYwMWVcXHUwMjgwY21wcnRcXHUxNzUzXFx1MTc1YlxcdTE3NjFcXHUxNzY0XFx1MTc2OGF1c1xcdTAxMDA7ZVxcdTAxMGFcXHUwMTA5cHR5djtcXHU2OWIwc1xceGU5XFx1MTcwY25vXFx4ZjVcXHUwMTEzXFx1MDE4MGFod1xcdTE3NmZcXHUxNzcxXFx1MTc3MztcXHU0M2IyO1xcdTYxMzZlZW47XFx1NjI2Y3I7XFx1YzAwMFxcdWQ4MzVcXHVkZDFmZ1xcdTAzODBjb3N0dXZ3XFx1MTc4ZFxcdTE3OWRcXHUxN2IzXFx1MTdjMVxcdTE3ZDVcXHUxN2RiXFx1MTdkZVxcdTAxODBhaXVcXHUxNzk0XFx1MTc5NlxcdTE3OWFcXHhmMFxcdTA3NjByYztcXHU2NWVmcFxceGJiXFx1MTM3MVxcdTAxODBkcHRcXHUxN2E0XFx1MTdhOFxcdTE3YWRvdDtcXHU2YTAwbHVzO1xcdTZhMDFpbWVzO1xcdTZhMDJcXHUwMjcxXFx1MTdiOVxcMFxcMFxcdTE3YmVjdXA7XFx1NmEwNmFyO1xcdTY2MDVyaWFuZ2xlXFx1MDEwMGR1XFx1MTdjZFxcdTE3ZDJvd247XFx1NjViZHA7XFx1NjViM3BsdXM7XFx1NmEwNGVcXHhlNVxcdTE0NDRcXHhlNVxcdTE0YWRhcm93O1xcdTY5MGRcXHUwMTgwYWtvXFx1MTdlZFxcdTE4MjZcXHUxODM1XFx1MDEwMGNuXFx1MTdmMlxcdTE4MjNrXFx1MDE4MGxzdFxcdTE3ZmFcXHUwNWFiXFx1MTgwMm96ZW5nZTtcXHU2OWVicmlhbmdsZVxcdTAyMDA7ZGxyXFx1MTgxMlxcdTE4MTNcXHUxODE4XFx1MTgxZFxcdTY1YjRvd247XFx1NjViZWVmdDtcXHU2NWMyaWdodDtcXHU2NWI4aztcXHU2NDIzXFx1MDFiMVxcdTE4MmJcXDBcXHUxODMzXFx1MDFiMlxcdTE4MmZcXDBcXHUxODMxO1xcdTY1OTI7XFx1NjU5MTQ7XFx1NjU5M2NrO1xcdTY1ODhcXHUwMTAwZW9cXHUxODNlXFx1MTg0ZFxcdTAxMDA7cVxcdTE4NDNcXHUxODQ2XFx1YzAwMD1cXHUyMGU1dWl2O1xcdWMwMDBcXHUyMjYxXFx1MjBlNXQ7XFx1NjMxMFxcdTAyMDBwdHd4XFx1MTg1OVxcdTE4NWVcXHUxODY3XFx1MTg2Y2Y7XFx1YzAwMFxcdWQ4MzVcXHVkZDUzXFx1MDEwMDt0XFx1MTNjYlxcdTE4NjNvbVxceGJiXFx1MTNjY3RpZTtcXHU2MmM4XFx1MDYwMERIVVZiZGhtcHR1dlxcdTE4ODVcXHUxODk2XFx1MThhYVxcdTE4YmJcXHUxOGQ3XFx1MThkYlxcdTE4ZWNcXHUxOGZmXFx1MTkwNVxcdTE5MGFcXHUxOTEwXFx1MTkyMVxcdTAyMDBMUmxyXFx1MTg4ZVxcdTE4OTBcXHUxODkyXFx1MTg5NDtcXHU2NTU3O1xcdTY1NTQ7XFx1NjU1NjtcXHU2NTUzXFx1MDI4MDtEVWR1XFx1MThhMVxcdTE4YTJcXHUxOGE0XFx1MThhNlxcdTE4YThcXHU2NTUwO1xcdTY1NjY7XFx1NjU2OTtcXHU2NTY0O1xcdTY1NjdcXHUwMjAwTFJsclxcdTE4YjNcXHUxOGI1XFx1MThiN1xcdTE4Yjk7XFx1NjU1ZDtcXHU2NTVhO1xcdTY1NWM7XFx1NjU1OVxcdTAzODA7SExSaGxyXFx1MThjYVxcdTE4Y2JcXHUxOGNkXFx1MThjZlxcdTE4ZDFcXHUxOGQzXFx1MThkNVxcdTY1NTE7XFx1NjU2YztcXHU2NTYzO1xcdTY1NjA7XFx1NjU2YjtcXHU2NTYyO1xcdTY1NWZveDtcXHU2OWM5XFx1MDIwMExSbHJcXHUxOGU0XFx1MThlNlxcdTE4ZThcXHUxOGVhO1xcdTY1NTU7XFx1NjU1MjtcXHU2NTEwO1xcdTY1MGNcXHUwMjgwO0RVZHVcXHUwNmJkXFx1MThmN1xcdTE4ZjlcXHUxOGZiXFx1MThmZDtcXHU2NTY1O1xcdTY1Njg7XFx1NjUyYztcXHU2NTM0aW51cztcXHU2MjlmbHVzO1xcdTYyOWVpbWVzO1xcdTYyYTBcXHUwMjAwTFJsclxcdTE5MTlcXHUxOTFiXFx1MTkxZFxcdTE5MWY7XFx1NjU1YjtcXHU2NTU4O1xcdTY1MTg7XFx1NjUxNFxcdTAzODA7SExSaGxyXFx1MTkzMFxcdTE5MzFcXHUxOTMzXFx1MTkzNVxcdTE5MzdcXHUxOTM5XFx1MTkzYlxcdTY1MDI7XFx1NjU2YTtcXHU2NTYxO1xcdTY1NWU7XFx1NjUzYztcXHU2NTI0O1xcdTY1MWNcXHUwMTAwZXZcXHUwMTIzXFx1MTk0MmJhclxcdTgwM2JcXHhhNlxcdTQwYTZcXHUwMjAwY2Vpb1xcdTE5NTFcXHUxOTU2XFx1MTk1YVxcdTE5NjByO1xcdWMwMDBcXHVkODM1XFx1ZGNiN21pO1xcdTYwNGZtXFx1MDEwMDtlXFx1MTcxYVxcdTE3MWNsXFx1MDE4MDtiaFxcdTE5NjhcXHUxOTY5XFx1MTk2YlxcdTQwNWM7XFx1NjljNXN1YjtcXHU2N2M4XFx1MDE2Y1xcdTE5NzRcXHUxOTdlbFxcdTAxMDA7ZVxcdTE5NzlcXHUxOTdhXFx1NjAyMnRcXHhiYlxcdTE5N2FwXFx1MDE4MDtFZVxcdTAxMmZcXHUxOTg1XFx1MTk4NztcXHU2YWFlXFx1MDEwMDtxXFx1MDZkY1xcdTA2ZGJcXHUwY2UxXFx1MTlhN1xcMFxcdTE5ZThcXHUxYTExXFx1MWExNVxcdTFhMzJcXDBcXHUxYTM3XFx1MWE1MFxcMFxcMFxcdTFhYjRcXDBcXDBcXHUxYWMxXFwwXFwwXFx1MWIyMVxcdTFiMmVcXHUxYjRkXFx1MWI1MlxcMFxcdTFiZmRcXDBcXHUxYzBjXFx1MDE4MGNwclxcdTE5YWRcXHUxOWIyXFx1MTlkZHV0ZTtcXHU0MTA3XFx1MDMwMDthYmNkc1xcdTE5YmZcXHUxOWMwXFx1MTljNFxcdTE5Y2FcXHUxOWQ1XFx1MTlkOVxcdTYyMjluZDtcXHU2YTQ0cmN1cDtcXHU2YTQ5XFx1MDEwMGF1XFx1MTljZlxcdTE5ZDJwO1xcdTZhNGJwO1xcdTZhNDdvdDtcXHU2YTQwO1xcdWMwMDBcXHUyMjI5XFx1ZmUwMFxcdTAxMDBlb1xcdTE5ZTJcXHUxOWU1dDtcXHU2MDQxXFx4ZWVcXHUwNjkzXFx1MDIwMGFlaXVcXHUxOWYwXFx1MTlmYlxcdTFhMDFcXHUxYTA1XFx1MDFmMFxcdTE5ZjVcXDBcXHUxOWY4cztcXHU2YTRkb247XFx1NDEwZGRpbFxcdTgwM2JcXHhlN1xcdTQwZTdyYztcXHU0MTA5cHNcXHUwMTAwO3NcXHUxYTBjXFx1MWEwZFxcdTZhNGNtO1xcdTZhNTBvdDtcXHU0MTBiXFx1MDE4MGRtblxcdTFhMWJcXHUxYTIwXFx1MWEyNmlsXFx1ODBiYlxceGI4XFx1MDFhZHB0eXY7XFx1NjliMnRcXHU4MTAwXFx4YTI7ZVxcdTFhMmRcXHUxYTJlXFx1NDBhMnJcXHhlNFxcdTAxYjJyO1xcdWMwMDBcXHVkODM1XFx1ZGQyMFxcdTAxODBjZWlcXHUxYTNkXFx1MWE0MFxcdTFhNGR5O1xcdTQ0NDdja1xcdTAxMDA7bVxcdTFhNDdcXHUxYTQ4XFx1NjcxM2Fya1xceGJiXFx1MWE0ODtcXHU0M2M3clxcdTAzODA7RWNlZm1zXFx1MWE1ZlxcdTFhNjBcXHUxYTYyXFx1MWE2YlxcdTFhYTRcXHUxYWFhXFx1MWFhZVxcdTY1Y2I7XFx1NjljM1xcdTAxODA7ZWxcXHUxYTY5XFx1MWE2YVxcdTFhNmRcXHU0MmM2cTtcXHU2MjU3ZVxcdTAyNjFcXHUxYTc0XFwwXFwwXFx1MWE4OHJyb3dcXHUwMTAwbHJcXHUxYTdjXFx1MWE4MWVmdDtcXHU2MWJhaWdodDtcXHU2MWJiXFx1MDI4MFJTYWNkXFx1MWE5MlxcdTFhOTRcXHUxYTk2XFx1MWE5YVxcdTFhOWZcXHhiYlxcdTBmNDc7XFx1NjRjOHN0O1xcdTYyOWJpcmM7XFx1NjI5YWFzaDtcXHU2MjlkbmludDtcXHU2YTEwaWQ7XFx1NmFlZmNpcjtcXHU2OWMydWJzXFx1MDEwMDt1XFx1MWFiYlxcdTFhYmNcXHU2NjYzaXRcXHhiYlxcdTFhYmNcXHUwMmVjXFx1MWFjN1xcdTFhZDRcXHUxYWZhXFwwXFx1MWIwYW9uXFx1MDEwMDtlXFx1MWFjZFxcdTFhY2VcXHU0MDNhXFx1MDEwMDtxXFx4YzdcXHhjNlxcdTAyNmRcXHUxYWQ5XFwwXFwwXFx1MWFlMmFcXHUwMTAwO3RcXHUxYWRlXFx1MWFkZlxcdTQwMmM7XFx1NDA0MFxcdTAxODA7ZmxcXHUxYWU4XFx1MWFlOVxcdTFhZWJcXHU2MjAxXFx4ZWVcXHUxMTYwZVxcdTAxMDBteFxcdTFhZjFcXHUxYWY2ZW50XFx4YmJcXHUxYWU5ZVxceGYzXFx1MDI0ZFxcdTAxZTdcXHUxYWZlXFwwXFx1MWIwN1xcdTAxMDA7ZFxcdTEyYmJcXHUxYjAyb3Q7XFx1NmE2ZG5cXHhmNFxcdTAyNDZcXHUwMTgwZnJ5XFx1MWIxMFxcdTFiMTRcXHUxYjE3O1xcdWMwMDBcXHVkODM1XFx1ZGQ1NG9cXHhlNFxcdTAyNTRcXHU4MTAwXFx4YTk7c1xcdTAxNTVcXHUxYjFkcjtcXHU2MTE3XFx1MDEwMGFvXFx1MWIyNVxcdTFiMjlycjtcXHU2MWI1c3M7XFx1NjcxN1xcdTAxMDBjdVxcdTFiMzJcXHUxYjM3cjtcXHVjMDAwXFx1ZDgzNVxcdWRjYjhcXHUwMTAwYnBcXHUxYjNjXFx1MWI0NFxcdTAxMDA7ZVxcdTFiNDFcXHUxYjQyXFx1NmFjZjtcXHU2YWQxXFx1MDEwMDtlXFx1MWI0OVxcdTFiNGFcXHU2YWQwO1xcdTZhZDJkb3Q7XFx1NjJlZlxcdTAzODBkZWxwcnZ3XFx1MWI2MFxcdTFiNmNcXHUxYjc3XFx1MWI4MlxcdTFiYWNcXHUxYmQ0XFx1MWJmOWFyclxcdTAxMDBsclxcdTFiNjhcXHUxYjZhO1xcdTY5Mzg7XFx1NjkzNVxcdTAyNzBcXHUxYjcyXFwwXFwwXFx1MWI3NXI7XFx1NjJkZWM7XFx1NjJkZmFyclxcdTAxMDA7cFxcdTFiN2ZcXHUxYjgwXFx1NjFiNjtcXHU2OTNkXFx1MDMwMDtiY2Rvc1xcdTFiOGZcXHUxYjkwXFx1MWI5NlxcdTFiYTFcXHUxYmE1XFx1MWJhOFxcdTYyMmFyY2FwO1xcdTZhNDhcXHUwMTAwYXVcXHUxYjliXFx1MWI5ZXA7XFx1NmE0NnA7XFx1NmE0YW90O1xcdTYyOGRyO1xcdTZhNDU7XFx1YzAwMFxcdTIyMmFcXHVmZTAwXFx1MDIwMGFscnZcXHUxYmI1XFx1MWJiZlxcdTFiZGVcXHUxYmUzcnJcXHUwMTAwO21cXHUxYmJjXFx1MWJiZFxcdTYxYjc7XFx1NjkzY3lcXHUwMTgwZXZ3XFx1MWJjN1xcdTFiZDRcXHUxYmQ4cVxcdTAyNzBcXHUxYmNlXFwwXFwwXFx1MWJkMnJlXFx4ZTNcXHUxYjczdVxceGUzXFx1MWI3NWVlO1xcdTYyY2VlZGdlO1xcdTYyY2ZlblxcdTgwM2JcXHhhNFxcdTQwYTRlYXJyb3dcXHUwMTAwbHJcXHUxYmVlXFx1MWJmM2VmdFxceGJiXFx1MWI4MGlnaHRcXHhiYlxcdTFiYmRlXFx4ZTRcXHUxYmRkXFx1MDEwMGNpXFx1MWMwMVxcdTFjMDdvbmluXFx4ZjRcXHUwMWY3bnQ7XFx1NjIzMWxjdHk7XFx1NjMyZFxcdTA5ODBBSGFiY2RlZmhpamxvcnN0dXd6XFx1MWMzOFxcdTFjM2JcXHUxYzNmXFx1MWM1ZFxcdTFjNjlcXHUxYzc1XFx1MWM4YVxcdTFjOWVcXHUxY2FjXFx1MWNiN1xcdTFjZmJcXHUxY2ZmXFx1MWQwZFxcdTFkN2JcXHUxZDkxXFx1MWRhYlxcdTFkYmJcXHUxZGM2XFx1MWRjZHJcXHhmMlxcdTAzODFhcjtcXHU2OTY1XFx1MDIwMGdscnNcXHUxYzQ4XFx1MWM0ZFxcdTFjNTJcXHUxYzU0Z2VyO1xcdTYwMjBldGg7XFx1NjEzOFxceGYyXFx1MTEzM2hcXHUwMTAwO3ZcXHUxYzVhXFx1MWM1YlxcdTYwMTBcXHhiYlxcdTA5MGFcXHUwMTZiXFx1MWM2MVxcdTFjNjdhcm93O1xcdTY5MGZhXFx4ZTNcXHUwMzE1XFx1MDEwMGF5XFx1MWM2ZVxcdTFjNzNyb247XFx1NDEwZjtcXHU0NDM0XFx1MDE4MDthb1xcdTAzMzJcXHUxYzdjXFx1MWM4NFxcdTAxMDBnclxcdTAyYmZcXHUxYzgxcjtcXHU2MWNhdHNlcTtcXHU2YTc3XFx1MDE4MGdsbVxcdTFjOTFcXHUxYzk0XFx1MWM5OFxcdTgwM2JcXHhiMFxcdTQwYjB0YTtcXHU0M2I0cHR5djtcXHU2OWIxXFx1MDEwMGlyXFx1MWNhM1xcdTFjYThzaHQ7XFx1Njk3ZjtcXHVjMDAwXFx1ZDgzNVxcdWRkMjFhclxcdTAxMDBsclxcdTFjYjNcXHUxY2I1XFx4YmJcXHUwOGRjXFx4YmJcXHUxMDFlXFx1MDI4MGFlZ3N2XFx1MWNjMlxcdTAzNzhcXHUxY2Q2XFx1MWNkY1xcdTFjZTBtXFx1MDE4MDtvc1xcdTAzMjZcXHUxY2NhXFx1MWNkNG5kXFx1MDEwMDtzXFx1MDMyNlxcdTFjZDF1aXQ7XFx1NjY2NmFtbWE7XFx1NDNkZGluO1xcdTYyZjJcXHUwMTgwO2lvXFx1MWNlN1xcdTFjZThcXHUxY2Y4XFx1NDBmN2RlXFx1ODEwMFxceGY3O29cXHUxY2U3XFx1MWNmMG50aW1lcztcXHU2MmM3blxceGY4XFx1MWNmN2N5O1xcdTQ0NTJjXFx1MDI2ZlxcdTFkMDZcXDBcXDBcXHUxZDBhcm47XFx1NjMxZW9wO1xcdTYzMGRcXHUwMjgwbHB0dXdcXHUxZDE4XFx1MWQxZFxcdTFkMjJcXHUxZDQ5XFx1MWQ1NWxhcjtcXHU0MDI0ZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNTVcXHUwMjgwO2VtcHNcXHUwMzBiXFx1MWQyZFxcdTFkMzdcXHUxZDNkXFx1MWQ0MnFcXHUwMTAwO2RcXHUwMzUyXFx1MWQzM290O1xcdTYyNTFpbnVzO1xcdTYyMzhsdXM7XFx1NjIxNHF1YXJlO1xcdTYyYTFibGViYXJ3ZWRnXFx4ZTVcXHhmYW5cXHUwMTgwYWRoXFx1MTEyZVxcdTFkNWRcXHUxZDY3b3duYXJyb3dcXHhmM1xcdTFjODNhcnBvb25cXHUwMTAwbHJcXHUxZDcyXFx1MWQ3NmVmXFx4ZjRcXHUxY2I0aWdoXFx4ZjRcXHUxY2I2XFx1MDE2MlxcdTFkN2ZcXHUxZDg1a2Fyb1xceGY3XFx1MGY0MlxcdTAyNmZcXHUxZDhhXFwwXFwwXFx1MWQ4ZXJuO1xcdTYzMWZvcDtcXHU2MzBjXFx1MDE4MGNvdFxcdTFkOThcXHUxZGEzXFx1MWRhNlxcdTAxMDByeVxcdTFkOWRcXHUxZGExO1xcdWMwMDBcXHVkODM1XFx1ZGNiOTtcXHU0NDU1bDtcXHU2OWY2cm9rO1xcdTQxMTFcXHUwMTAwZHJcXHUxZGIwXFx1MWRiNG90O1xcdTYyZjFpXFx1MDEwMDtmXFx1MWRiYVxcdTE4MTZcXHU2NWJmXFx1MDEwMGFoXFx1MWRjMFxcdTFkYzNyXFx4ZjJcXHUwNDI5YVxceGYyXFx1MGZhNmFuZ2xlO1xcdTY5YTZcXHUwMTAwY2lcXHUxZGQyXFx1MWRkNXk7XFx1NDQ1ZmdyYXJyO1xcdTY3ZmZcXHUwOTAwRGFjZGVmZ2xtbm9wcXJzdHV4XFx1MWUwMVxcdTFlMDlcXHUxZTE5XFx1MWUzOFxcdTA1NzhcXHUxZTNjXFx1MWU0OVxcdTFlNjFcXHUxZTdlXFx1MWVhNVxcdTFlYWZcXHUxZWJkXFx1MWVlMVxcdTFmMmFcXHUxZjM3XFx1MWY0NFxcdTFmNGVcXHUxZjVhXFx1MDEwMERvXFx1MWUwNlxcdTFkMzRvXFx4ZjRcXHUxYzg5XFx1MDEwMGNzXFx1MWUwZVxcdTFlMTR1dGVcXHU4MDNiXFx4ZTlcXHU0MGU5dGVyO1xcdTZhNmVcXHUwMjAwYWlveVxcdTFlMjJcXHUxZTI3XFx1MWUzMVxcdTFlMzZyb247XFx1NDExYnJcXHUwMTAwO2NcXHUxZTJkXFx1MWUyZVxcdTYyNTZcXHU4MDNiXFx4ZWFcXHU0MGVhbG9uO1xcdTYyNTU7XFx1NDQ0ZG90O1xcdTQxMTdcXHUwMTAwRHJcXHUxZTQxXFx1MWU0NW90O1xcdTYyNTI7XFx1YzAwMFxcdWQ4MzVcXHVkZDIyXFx1MDE4MDtyc1xcdTFlNTBcXHUxZTUxXFx1MWU1N1xcdTZhOWFhdmVcXHU4MDNiXFx4ZThcXHU0MGU4XFx1MDEwMDtkXFx1MWU1Y1xcdTFlNWRcXHU2YTk2b3Q7XFx1NmE5OFxcdTAyMDA7aWxzXFx1MWU2YVxcdTFlNmJcXHUxZTcyXFx1MWU3NFxcdTZhOTludGVycztcXHU2M2U3O1xcdTYxMTNcXHUwMTAwO2RcXHUxZTc5XFx1MWU3YVxcdTZhOTVvdDtcXHU2YTk3XFx1MDE4MGFwc1xcdTFlODVcXHUxZTg5XFx1MWU5N2NyO1xcdTQxMTN0eVxcdTAxODA7c3ZcXHUxZTkyXFx1MWU5M1xcdTFlOTVcXHU2MjA1ZXRcXHhiYlxcdTFlOTNwXFx1MDEwMDE7XFx1MWU5ZFxcdTFlYTRcXHUwMTMzXFx1MWVhMVxcdTFlYTM7XFx1NjAwNDtcXHU2MDA1XFx1NjAwM1xcdTAxMDBnc1xcdTFlYWFcXHUxZWFjO1xcdTQxNGJwO1xcdTYwMDJcXHUwMTAwZ3BcXHUxZWI0XFx1MWViOG9uO1xcdTQxMTlmO1xcdWMwMDBcXHVkODM1XFx1ZGQ1NlxcdTAxODBhbHNcXHUxZWM0XFx1MWVjZVxcdTFlZDJyXFx1MDEwMDtzXFx1MWVjYVxcdTFlY2JcXHU2MmQ1bDtcXHU2OWUzdXM7XFx1NmE3MWlcXHUwMTgwO2x2XFx1MWVkYVxcdTFlZGJcXHUxZWRmXFx1NDNiNW9uXFx4YmJcXHUxZWRiO1xcdTQzZjVcXHUwMjAwY3N1dlxcdTFlZWFcXHUxZWYzXFx1MWYwYlxcdTFmMjNcXHUwMTAwaW9cXHUxZWVmXFx1MWUzMXJjXFx4YmJcXHUxZTJlXFx1MDI2OVxcdTFlZjlcXDBcXDBcXHUxZWZiXFx4ZWRcXHUwNTQ4YW50XFx1MDEwMGdsXFx1MWYwMlxcdTFmMDZ0clxceGJiXFx1MWU1ZGVzc1xceGJiXFx1MWU3YVxcdTAxODBhZWlcXHUxZjEyXFx1MWYxNlxcdTFmMWFscztcXHU0MDNkc3Q7XFx1NjI1ZnZcXHUwMTAwO0RcXHUwMjM1XFx1MWYyMEQ7XFx1NmE3OHBhcnNsO1xcdTY5ZTVcXHUwMTAwRGFcXHUxZjJmXFx1MWYzM290O1xcdTYyNTNycjtcXHU2OTcxXFx1MDE4MGNkaVxcdTFmM2VcXHUxZjQxXFx1MWVmOHI7XFx1NjEyZm9cXHhmNFxcdTAzNTJcXHUwMTAwYWhcXHUxZjQ5XFx1MWY0YjtcXHU0M2I3XFx1ODAzYlxceGYwXFx1NDBmMFxcdTAxMDBtclxcdTFmNTNcXHUxZjU3bFxcdTgwM2JcXHhlYlxcdTQwZWJvO1xcdTYwYWNcXHUwMTgwY2lwXFx1MWY2MVxcdTFmNjRcXHUxZjY3bDtcXHU0MDIxc1xceGY0XFx1MDU2ZVxcdTAxMDBlb1xcdTFmNmNcXHUxZjc0Y3RhdGlvXFx4ZWVcXHUwNTU5bmVudGlhbFxceGU1XFx1MDU3OVxcdTA5ZTFcXHUxZjkyXFwwXFx1MWY5ZVxcMFxcdTFmYTFcXHUxZmE3XFwwXFwwXFx1MWZjNlxcdTFmY2NcXDBcXHUxZmQzXFwwXFx1MWZlNlxcdTFmZWFcXHUyMDAwXFwwXFx1MjAwOFxcdTIwNWFsbGluZ2RvdHNlXFx4ZjFcXHUxZTQ0eTtcXHU0NDQ0bWFsZTtcXHU2NjQwXFx1MDE4MGlsclxcdTFmYWRcXHUxZmIzXFx1MWZjMWxpZztcXHU4MDAwXFx1ZmIwM1xcdTAyNjlcXHUxZmI5XFwwXFwwXFx1MWZiZGc7XFx1ODAwMFxcdWZiMDBpZztcXHU4MDAwXFx1ZmIwNDtcXHVjMDAwXFx1ZDgzNVxcdWRkMjNsaWc7XFx1ODAwMFxcdWZiMDFsaWc7XFx1YzAwMGZqXFx1MDE4MGFsdFxcdTFmZDlcXHUxZmRjXFx1MWZlMXQ7XFx1NjY2ZGlnO1xcdTgwMDBcXHVmYjAybnM7XFx1NjViMW9mO1xcdTQxOTJcXHUwMWYwXFx1MWZlZVxcMFxcdTFmZjNmO1xcdWMwMDBcXHVkODM1XFx1ZGQ1N1xcdTAxMDBha1xcdTA1YmZcXHUxZmY3XFx1MDEwMDt2XFx1MWZmY1xcdTFmZmRcXHU2MmQ0O1xcdTZhZDlhcnRpbnQ7XFx1NmEwZFxcdTAxMDBhb1xcdTIwMGNcXHUyMDU1XFx1MDEwMGNzXFx1MjAxMVxcdTIwNTJcXHUwM2IxXFx1MjAxYVxcdTIwMzBcXHUyMDM4XFx1MjA0NVxcdTIwNDhcXDBcXHUyMDUwXFx1MDNiMlxcdTIwMjJcXHUyMDI1XFx1MjAyN1xcdTIwMmFcXHUyMDJjXFwwXFx1MjAyZVxcdTgwM2JcXHhiZFxcdTQwYmQ7XFx1NjE1M1xcdTgwM2JcXHhiY1xcdTQwYmM7XFx1NjE1NTtcXHU2MTU5O1xcdTYxNWJcXHUwMWIzXFx1MjAzNFxcMFxcdTIwMzY7XFx1NjE1NDtcXHU2MTU2XFx1MDJiNFxcdTIwM2VcXHUyMDQxXFwwXFwwXFx1MjA0M1xcdTgwM2JcXHhiZVxcdTQwYmU7XFx1NjE1NztcXHU2MTVjNTtcXHU2MTU4XFx1MDFiNlxcdTIwNGNcXDBcXHUyMDRlO1xcdTYxNWE7XFx1NjE1ZDg7XFx1NjE1ZWw7XFx1NjA0NHduO1xcdTYzMjJjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYmJcXHUwODgwRWFiY2RlZmdpamxub3JzdHZcXHUyMDgyXFx1MjA4OVxcdTIwOWZcXHUyMGE1XFx1MjBiMFxcdTIwYjRcXHUyMGYwXFx1MjBmNVxcdTIwZmFcXHUyMGZmXFx1MjEwM1xcdTIxMTJcXHUyMTM4XFx1MDMxN1xcdTIxM2VcXHUyMTUyXFx1MjE5ZVxcdTAxMDA7bFxcdTA2NGRcXHUyMDg3O1xcdTZhOGNcXHUwMTgwY21wXFx1MjA5MFxcdTIwOTVcXHUyMDlkdXRlO1xcdTQxZjVtYVxcdTAxMDA7ZFxcdTIwOWNcXHUxY2RhXFx1NDNiMztcXHU2YTg2cmV2ZTtcXHU0MTFmXFx1MDEwMGl5XFx1MjBhYVxcdTIwYWVyYztcXHU0MTFkO1xcdTQ0MzNvdDtcXHU0MTIxXFx1MDIwMDtscXNcXHUwNjNlXFx1MDY0MlxcdTIwYmRcXHUyMGM5XFx1MDE4MDtxc1xcdTA2M2VcXHUwNjRjXFx1MjBjNGxhblxceGY0XFx1MDY2NVxcdTAyMDA7Y2RsXFx1MDY2NVxcdTIwZDJcXHUyMGQ1XFx1MjBlNWM7XFx1NmFhOW90XFx1MDEwMDtvXFx1MjBkY1xcdTIwZGRcXHU2YTgwXFx1MDEwMDtsXFx1MjBlMlxcdTIwZTNcXHU2YTgyO1xcdTZhODRcXHUwMTAwO2VcXHUyMGVhXFx1MjBlZFxcdWMwMDBcXHUyMmRiXFx1ZmUwMHM7XFx1NmE5NHI7XFx1YzAwMFxcdWQ4MzVcXHVkZDI0XFx1MDEwMDtnXFx1MDY3M1xcdTA2MWJtZWw7XFx1NjEzN2N5O1xcdTQ0NTNcXHUwMjAwO0VhalxcdTA2NWFcXHUyMTBjXFx1MjEwZVxcdTIxMTA7XFx1NmE5MjtcXHU2YWE1O1xcdTZhYTRcXHUwMjAwRWFlc1xcdTIxMWJcXHUyMTFkXFx1MjEyOVxcdTIxMzQ7XFx1NjI2OXBcXHUwMTAwO3BcXHUyMTIzXFx1MjEyNFxcdTZhOGFyb3hcXHhiYlxcdTIxMjRcXHUwMTAwO3FcXHUyMTJlXFx1MjEyZlxcdTZhODhcXHUwMTAwO3FcXHUyMTJlXFx1MjExYmltO1xcdTYyZTdwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNThcXHUwMTAwY2lcXHUyMTQzXFx1MjE0NnI7XFx1NjEwYW1cXHUwMTgwO2VsXFx1MDY2YlxcdTIxNGVcXHUyMTUwO1xcdTZhOGU7XFx1NmE5MFxcdTgzMDA+O2NkbHFyXFx1MDVlZVxcdTIxNjBcXHUyMTZhXFx1MjE2ZVxcdTIxNzNcXHUyMTc5XFx1MDEwMGNpXFx1MjE2NVxcdTIxNjc7XFx1NmFhN3I7XFx1NmE3YW90O1xcdTYyZDdQYXI7XFx1Njk5NXVlc3Q7XFx1NmE3Y1xcdTAyODBhZGVsc1xcdTIxODRcXHUyMTZhXFx1MjE5MFxcdTA2NTZcXHUyMTliXFx1MDFmMFxcdTIxODlcXDBcXHUyMThlcHJvXFx4ZjhcXHUyMDllcjtcXHU2OTc4cVxcdTAxMDBscVxcdTA2M2ZcXHUyMTk2bGVzXFx4ZjNcXHUyMDg4aVxceGVkXFx1MDY2YlxcdTAxMDBlblxcdTIxYTNcXHUyMWFkcnRuZXFxO1xcdWMwMDBcXHUyMjY5XFx1ZmUwMFxceGM1XFx1MjFhYVxcdTA1MDBBYWJjZWZrb3N5XFx1MjFjNFxcdTIxYzdcXHUyMWYxXFx1MjFmNVxcdTIxZmFcXHUyMjE4XFx1MjIxZFxcdTIyMmZcXHUyMjY4XFx1MjI3ZHJcXHhmMlxcdTAzYTBcXHUwMjAwaWxtclxcdTIxZDBcXHUyMWQ0XFx1MjFkN1xcdTIxZGJyc1xceGYwXFx1MTQ4NGZcXHhiYlxcdTIwMjRpbFxceGY0XFx1MDZhOVxcdTAxMDBkclxcdTIxZTBcXHUyMWU0Y3k7XFx1NDQ0YVxcdTAxODA7Y3dcXHUwOGY0XFx1MjFlYlxcdTIxZWZpcjtcXHU2OTQ4O1xcdTYxYWRhcjtcXHU2MTBmaXJjO1xcdTQxMjVcXHUwMTgwYWxyXFx1MjIwMVxcdTIyMGVcXHUyMjEzcnRzXFx1MDEwMDt1XFx1MjIwOVxcdTIyMGFcXHU2NjY1aXRcXHhiYlxcdTIyMGFsaXA7XFx1NjAyNmNvbjtcXHU2MmI5cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMjVzXFx1MDEwMGV3XFx1MjIyM1xcdTIyMjlhcm93O1xcdTY5MjVhcm93O1xcdTY5MjZcXHUwMjgwYW1vcHJcXHUyMjNhXFx1MjIzZVxcdTIyNDNcXHUyMjVlXFx1MjI2M3JyO1xcdTYxZmZ0aHQ7XFx1NjIzYmtcXHUwMTAwbHJcXHUyMjQ5XFx1MjI1M2VmdGFycm93O1xcdTYxYTlpZ2h0YXJyb3c7XFx1NjFhYWY7XFx1YzAwMFxcdWQ4MzVcXHVkZDU5YmFyO1xcdTYwMTVcXHUwMTgwY2x0XFx1MjI2ZlxcdTIyNzRcXHUyMjc4cjtcXHVjMDAwXFx1ZDgzNVxcdWRjYmRhc1xceGU4XFx1MjFmNHJvaztcXHU0MTI3XFx1MDEwMGJwXFx1MjI4MlxcdTIyODd1bGw7XFx1NjA0M2hlblxceGJiXFx1MWM1YlxcdTBhZTFcXHUyMmEzXFwwXFx1MjJhYVxcMFxcdTIyYjhcXHUyMmM1XFx1MjJjZVxcMFxcdTIyZDVcXHUyMmYzXFwwXFwwXFx1MjJmOFxcdTIzMjJcXHUyMzY3XFx1MjM2MlxcdTIzN2ZcXDBcXHUyMzg2XFx1MjNhYVxcdTIzYjRjdXRlXFx1ODAzYlxceGVkXFx1NDBlZFxcdTAxODA7aXlcXHUwNzcxXFx1MjJiMFxcdTIyYjVyY1xcdTgwM2JcXHhlZVxcdTQwZWU7XFx1NDQzOFxcdTAxMDBjeFxcdTIyYmNcXHUyMmJmeTtcXHU0NDM1Y2xcXHU4MDNiXFx4YTFcXHU0MGExXFx1MDEwMGZyXFx1MDM5ZlxcdTIyYzk7XFx1YzAwMFxcdWQ4MzVcXHVkZDI2cmF2ZVxcdTgwM2JcXHhlY1xcdTQwZWNcXHUwMjAwO2lub1xcdTA3M2VcXHUyMmRkXFx1MjJlOVxcdTIyZWVcXHUwMTAwaW5cXHUyMmUyXFx1MjJlNm50O1xcdTZhMGN0O1xcdTYyMmRmaW47XFx1NjlkY3RhO1xcdTYxMjlsaWc7XFx1NDEzM1xcdTAxODBhb3BcXHUyMmZlXFx1MjMxYVxcdTIzMWRcXHUwMTgwY2d0XFx1MjMwNVxcdTIzMDhcXHUyMzE3cjtcXHU0MTJiXFx1MDE4MGVscFxcdTA3MWZcXHUyMzBmXFx1MjMxM2luXFx4ZTVcXHUwNzhlYXJcXHhmNFxcdTA3MjBoO1xcdTQxMzFmO1xcdTYyYjdlZDtcXHU0MWI1XFx1MDI4MDtjZm90XFx1MDRmNFxcdTIzMmNcXHUyMzMxXFx1MjMzZFxcdTIzNDFhcmU7XFx1NjEwNWluXFx1MDEwMDt0XFx1MjMzOFxcdTIzMzlcXHU2MjFlaWU7XFx1NjlkZGRvXFx4ZjRcXHUyMzE5XFx1MDI4MDtjZWxwXFx1MDc1N1xcdTIzNGNcXHUyMzUwXFx1MjM1YlxcdTIzNjFhbDtcXHU2MmJhXFx1MDEwMGdyXFx1MjM1NVxcdTIzNTllclxceGYzXFx1MTU2M1xceGUzXFx1MjM0ZGFyaGs7XFx1NmExN3JvZDtcXHU2YTNjXFx1MDIwMGNncHRcXHUyMzZmXFx1MjM3MlxcdTIzNzZcXHUyMzdieTtcXHU0NDUxb247XFx1NDEyZmY7XFx1YzAwMFxcdWQ4MzVcXHVkZDVhYTtcXHU0M2I5dWVzdFxcdTgwM2JcXHhiZlxcdTQwYmZcXHUwMTAwY2lcXHUyMzhhXFx1MjM4ZnI7XFx1YzAwMFxcdWQ4MzVcXHVkY2JlblxcdTAyODA7RWRzdlxcdTA0ZjRcXHUyMzliXFx1MjM5ZFxcdTIzYTFcXHUwNGYzO1xcdTYyZjlvdDtcXHU2MmY1XFx1MDEwMDt2XFx1MjNhNlxcdTIzYTdcXHU2MmY0O1xcdTYyZjNcXHUwMTAwO2lcXHUwNzc3XFx1MjNhZWxkZTtcXHU0MTI5XFx1MDFlYlxcdTIzYjhcXDBcXHUyM2JjY3k7XFx1NDQ1NmxcXHU4MDNiXFx4ZWZcXHU0MGVmXFx1MDMwMGNmbW9zdVxcdTIzY2NcXHUyM2Q3XFx1MjNkY1xcdTIzZTFcXHUyM2U3XFx1MjNmNVxcdTAxMDBpeVxcdTIzZDFcXHUyM2Q1cmM7XFx1NDEzNTtcXHU0NDM5cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMjdhdGg7XFx1NDIzN3BmO1xcdWMwMDBcXHVkODM1XFx1ZGQ1YlxcdTAxZTNcXHUyM2VjXFwwXFx1MjNmMXI7XFx1YzAwMFxcdWQ4MzVcXHVkY2JmcmN5O1xcdTQ0NThrY3k7XFx1NDQ1NFxcdTA0MDBhY2ZnaGpvc1xcdTI0MGJcXHUyNDE2XFx1MjQyMlxcdTI0MjdcXHUyNDJkXFx1MjQzMVxcdTI0MzVcXHUyNDNicHBhXFx1MDEwMDt2XFx1MjQxM1xcdTI0MTRcXHU0M2JhO1xcdTQzZjBcXHUwMTAwZXlcXHUyNDFiXFx1MjQyMGRpbDtcXHU0MTM3O1xcdTQ0M2FyO1xcdWMwMDBcXHVkODM1XFx1ZGQyOHJlZW47XFx1NDEzOGN5O1xcdTQ0NDVjeTtcXHU0NDVjcGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDVjY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2MwXFx1MGI4MEFCRUhhYmNkZWZnaGpsbW5vcHJzdHV2XFx1MjQ3MFxcdTI0ODFcXHUyNDg2XFx1MjQ4ZFxcdTI0OTFcXHUyNTBlXFx1MjUzZFxcdTI1NWFcXHUyNTgwXFx1MjY0ZVxcdTI2NWVcXHUyNjY1XFx1MjY3OVxcdTI2N2RcXHUyNjlhXFx1MjZiMlxcdTI2ZDhcXHUyNzVkXFx1Mjc2OFxcdTI3OGJcXHUyN2MwXFx1MjgwMVxcdTI4MTJcXHUwMTgwYXJ0XFx1MjQ3N1xcdTI0N2FcXHUyNDdjclxceGYyXFx1MDljNlxceGYyXFx1MDM5NWFpbDtcXHU2OTFiYXJyO1xcdTY5MGVcXHUwMTAwO2dcXHUwOTk0XFx1MjQ4YjtcXHU2YThiYXI7XFx1Njk2MlxcdTA5NjNcXHUyNGE1XFwwXFx1MjRhYVxcMFxcdTI0YjFcXDBcXDBcXDBcXDBcXDBcXHUyNGI1XFx1MjRiYVxcMFxcdTI0YzZcXHUyNGM4XFx1MjRjZFxcMFxcdTI0Zjl1dGU7XFx1NDEzYW1wdHl2O1xcdTY5YjRyYVxceGVlXFx1MDg0Y2JkYTtcXHU0M2JiZ1xcdTAxODA7ZGxcXHUwODhlXFx1MjRjMVxcdTI0YzM7XFx1Njk5MVxceGU1XFx1MDg4ZTtcXHU2YTg1dW9cXHU4MDNiXFx4YWJcXHU0MGFiclxcdTA0MDA7YmZobHBzdFxcdTA4OTlcXHUyNGRlXFx1MjRlNlxcdTI0ZTlcXHUyNGViXFx1MjRlZVxcdTI0ZjFcXHUyNGY1XFx1MDEwMDtmXFx1MDg5ZFxcdTI0ZTNzO1xcdTY5MWZzO1xcdTY5MWRcXHhlYlxcdTIyNTJwO1xcdTYxYWJsO1xcdTY5MzlpbTtcXHU2OTczbDtcXHU2MWEyXFx1MDE4MDthZVxcdTI0ZmZcXHUyNTAwXFx1MjUwNFxcdTZhYWJpbDtcXHU2OTE5XFx1MDEwMDtzXFx1MjUwOVxcdTI1MGFcXHU2YWFkO1xcdWMwMDBcXHUyYWFkXFx1ZmUwMFxcdTAxODBhYnJcXHUyNTE1XFx1MjUxOVxcdTI1MWRycjtcXHU2OTBjcms7XFx1Njc3MlxcdTAxMDBha1xcdTI1MjJcXHUyNTJjY1xcdTAxMDBla1xcdTI1MjhcXHUyNTJhO1xcdTQwN2I7XFx1NDA1YlxcdTAxMDBlc1xcdTI1MzFcXHUyNTMzO1xcdTY5OGJsXFx1MDEwMGR1XFx1MjUzOVxcdTI1M2I7XFx1Njk4ZjtcXHU2OThkXFx1MDIwMGFldXlcXHUyNTQ2XFx1MjU0YlxcdTI1NTZcXHUyNTU4cm9uO1xcdTQxM2VcXHUwMTAwZGlcXHUyNTUwXFx1MjU1NGlsO1xcdTQxM2NcXHhlY1xcdTA4YjBcXHhlMlxcdTI1Mjk7XFx1NDQzYlxcdTAyMDBjcXJzXFx1MjU2M1xcdTI1NjZcXHUyNTZkXFx1MjU3ZGE7XFx1NjkzNnVvXFx1MDEwMDtyXFx1MGUxOVxcdTE3NDZcXHUwMTAwZHVcXHUyNTcyXFx1MjU3N2hhcjtcXHU2OTY3c2hhcjtcXHU2OTRiaDtcXHU2MWIyXFx1MDI4MDtmZ3FzXFx1MjU4YlxcdTI1OGNcXHUwOTg5XFx1MjVmM1xcdTI1ZmZcXHU2MjY0dFxcdTAyODBhaGxydFxcdTI1OThcXHUyNWE0XFx1MjViN1xcdTI1YzJcXHUyNWU4cnJvd1xcdTAxMDA7dFxcdTA4OTlcXHUyNWExYVxceGU5XFx1MjRmNmFycG9vblxcdTAxMDBkdVxcdTI1YWZcXHUyNWI0b3duXFx4YmJcXHUwNDVhcFxceGJiXFx1MDk2NmVmdGFycm93cztcXHU2MWM3aWdodFxcdTAxODBhaHNcXHUyNWNkXFx1MjVkNlxcdTI1ZGVycm93XFx1MDEwMDtzXFx1MDhmNFxcdTA4YTdhcnBvb25cXHhmM1xcdTBmOThxdWlnYXJyb1xceGY3XFx1MjFmMGhyZWV0aW1lcztcXHU2MmNiXFx1MDE4MDtxc1xcdTI1OGJcXHUwOTkzXFx1MjVmYWxhblxceGY0XFx1MDlhY1xcdTAyODA7Y2Rnc1xcdTA5YWNcXHUyNjBhXFx1MjYwZFxcdTI2MWRcXHUyNjI4YztcXHU2YWE4b3RcXHUwMTAwO29cXHUyNjE0XFx1MjYxNVxcdTZhN2ZcXHUwMTAwO3JcXHUyNjFhXFx1MjYxYlxcdTZhODE7XFx1NmE4M1xcdTAxMDA7ZVxcdTI2MjJcXHUyNjI1XFx1YzAwMFxcdTIyZGFcXHVmZTAwcztcXHU2YTkzXFx1MDI4MGFkZWdzXFx1MjYzM1xcdTI2MzlcXHUyNjNkXFx1MjY0OVxcdTI2NGJwcHJvXFx4ZjhcXHUyNGM2b3Q7XFx1NjJkNnFcXHUwMTAwZ3FcXHUyNjQzXFx1MjY0NVxceGY0XFx1MDk4OWd0XFx4ZjJcXHUyNDhjXFx4ZjRcXHUwOTliaVxceGVkXFx1MDliMlxcdTAxODBpbHJcXHUyNjU1XFx1MDhlMVxcdTI2NWFzaHQ7XFx1Njk3YztcXHVjMDAwXFx1ZDgzNVxcdWRkMjlcXHUwMTAwO0VcXHUwOTljXFx1MjY2MztcXHU2YTkxXFx1MDE2MVxcdTI2NjlcXHUyNjc2clxcdTAxMDBkdVxcdTI1YjJcXHUyNjZlXFx1MDEwMDtsXFx1MDk2NVxcdTI2NzM7XFx1Njk2YWxrO1xcdTY1ODRjeTtcXHU0NDU5XFx1MDI4MDthY2h0XFx1MGE0OFxcdTI2ODhcXHUyNjhiXFx1MjY5MVxcdTI2OTZyXFx4ZjJcXHUyNWMxb3JuZVxceGYyXFx1MWQwOGFyZDtcXHU2OTZicmk7XFx1NjVmYVxcdTAxMDBpb1xcdTI2OWZcXHUyNmE0ZG90O1xcdTQxNDB1c3RcXHUwMTAwO2FcXHUyNmFjXFx1MjZhZFxcdTYzYjBjaGVcXHhiYlxcdTI2YWRcXHUwMjAwRWFlc1xcdTI2YmJcXHUyNmJkXFx1MjZjOVxcdTI2ZDQ7XFx1NjI2OHBcXHUwMTAwO3BcXHUyNmMzXFx1MjZjNFxcdTZhODlyb3hcXHhiYlxcdTI2YzRcXHUwMTAwO3FcXHUyNmNlXFx1MjZjZlxcdTZhODdcXHUwMTAwO3FcXHUyNmNlXFx1MjZiYmltO1xcdTYyZTZcXHUwNDAwYWJub3B0d3pcXHUyNmU5XFx1MjZmNFxcdTI2ZjdcXHUyNzFhXFx1MjcyZlxcdTI3NDFcXHUyNzQ3XFx1Mjc1MFxcdTAxMDBuclxcdTI2ZWVcXHUyNmYxZztcXHU2N2VjcjtcXHU2MWZkclxceGViXFx1MDhjMWdcXHUwMTgwbG1yXFx1MjZmZlxcdTI3MGRcXHUyNzE0ZWZ0XFx1MDEwMGFyXFx1MDllNlxcdTI3MDdpZ2h0XFx4ZTFcXHUwOWYyYXBzdG87XFx1NjdmY2lnaHRcXHhlMVxcdTA5ZmRwYXJyb3dcXHUwMTAwbHJcXHUyNzI1XFx1MjcyOWVmXFx4ZjRcXHUyNGVkaWdodDtcXHU2MWFjXFx1MDE4MGFmbFxcdTI3MzZcXHUyNzM5XFx1MjczZHI7XFx1Njk4NTtcXHVjMDAwXFx1ZDgzNVxcdWRkNWR1cztcXHU2YTJkaW1lcztcXHU2YTM0XFx1MDE2MVxcdTI3NGJcXHUyNzRmc3Q7XFx1NjIxN1xceGUxXFx1MTM0ZVxcdTAxODA7ZWZcXHUyNzU3XFx1Mjc1OFxcdTE4MDBcXHU2NWNhbmdlXFx4YmJcXHUyNzU4YXJcXHUwMTAwO2xcXHUyNzY0XFx1Mjc2NVxcdTQwMjh0O1xcdTY5OTNcXHUwMjgwYWNobXRcXHUyNzczXFx1Mjc3NlxcdTI3N2NcXHUyNzg1XFx1Mjc4N3JcXHhmMlxcdTA4YThvcm5lXFx4ZjJcXHUxZDhjYXJcXHUwMTAwO2RcXHUwZjk4XFx1Mjc4MztcXHU2OTZkO1xcdTYwMGVyaTtcXHU2MmJmXFx1MDMwMGFjaGlxdFxcdTI3OThcXHUyNzlkXFx1MGE0MFxcdTI3YTJcXHUyN2FlXFx1MjdiYnF1bztcXHU2MDM5cjtcXHVjMDAwXFx1ZDgzNVxcdWRjYzFtXFx1MDE4MDtlZ1xcdTA5YjJcXHUyN2FhXFx1MjdhYztcXHU2YThkO1xcdTZhOGZcXHUwMTAwYnVcXHUyNTJhXFx1MjdiM29cXHUwMTAwO3JcXHUwZTFmXFx1MjdiOTtcXHU2MDFhcm9rO1xcdTQxNDJcXHU4NDAwPDtjZGhpbHFyXFx1MDgyYlxcdTI3ZDJcXHUyNjM5XFx1MjdkY1xcdTI3ZTBcXHUyN2U1XFx1MjdlYVxcdTI3ZjBcXHUwMTAwY2lcXHUyN2Q3XFx1MjdkOTtcXHU2YWE2cjtcXHU2YTc5cmVcXHhlNVxcdTI1ZjJtZXM7XFx1NjJjOWFycjtcXHU2OTc2dWVzdDtcXHU2YTdiXFx1MDEwMFBpXFx1MjdmNVxcdTI3ZjlhcjtcXHU2OTk2XFx1MDE4MDtlZlxcdTI4MDBcXHUwOTJkXFx1MTgxYlxcdTY1YzNyXFx1MDEwMGR1XFx1MjgwN1xcdTI4MGRzaGFyO1xcdTY5NGFoYXI7XFx1Njk2NlxcdTAxMDBlblxcdTI4MTdcXHUyODIxcnRuZXFxO1xcdWMwMDBcXHUyMjY4XFx1ZmUwMFxceGM1XFx1MjgxZVxcdTA3MDBEYWNkZWZoaWxub3BzdVxcdTI4NDBcXHUyODQ1XFx1Mjg4MlxcdTI4OGVcXHUyODkzXFx1MjhhMFxcdTI4YTVcXHUyOGE4XFx1MjhkYVxcdTI4ZTJcXHUyOGU0XFx1MGE4M1xcdTI4ZjNcXHUyOTAyRG90O1xcdTYyM2FcXHUwMjAwY2xwclxcdTI4NGVcXHUyODUyXFx1Mjg2M1xcdTI4N2RyXFx1ODAzYlxceGFmXFx1NDBhZlxcdTAxMDBldFxcdTI4NTdcXHUyODU5O1xcdTY2NDJcXHUwMTAwO2VcXHUyODVlXFx1Mjg1ZlxcdTY3MjBzZVxceGJiXFx1Mjg1ZlxcdTAxMDA7c1xcdTEwM2JcXHUyODY4dG9cXHUwMjAwO2RsdVxcdTEwM2JcXHUyODczXFx1Mjg3N1xcdTI4N2Jvd1xceGVlXFx1MDQ4Y2VmXFx4ZjRcXHUwOTBmXFx4ZjBcXHUxM2Qxa2VyO1xcdTY1YWVcXHUwMTAwb3lcXHUyODg3XFx1Mjg4Y21tYTtcXHU2YTI5O1xcdTQ0M2Nhc2g7XFx1NjAxNGFzdXJlZGFuZ2xlXFx4YmJcXHUxNjI2cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMmFvO1xcdTYxMjdcXHUwMTgwY2RuXFx1MjhhZlxcdTI4YjRcXHUyOGM5cm9cXHU4MDNiXFx4YjVcXHU0MGI1XFx1MDIwMDthY2RcXHUxNDY0XFx1MjhiZFxcdTI4YzBcXHUyOGM0c1xceGY0XFx1MTZhN2lyO1xcdTZhZjBvdFxcdTgwYmJcXHhiN1xcdTAxYjV1c1xcdTAxODA7YmRcXHUyOGQyXFx1MTkwM1xcdTI4ZDNcXHU2MjEyXFx1MDEwMDt1XFx1MWQzY1xcdTI4ZDg7XFx1NmEyYVxcdTAxNjNcXHUyOGRlXFx1MjhlMXA7XFx1NmFkYlxceGYyXFx1MjIxMlxceGYwXFx1MGE4MVxcdTAxMDBkcFxcdTI4ZTlcXHUyOGVlZWxzO1xcdTYyYTdmO1xcdWMwMDBcXHVkODM1XFx1ZGQ1ZVxcdTAxMDBjdFxcdTI4ZjhcXHUyOGZkcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYzJwb3NcXHhiYlxcdTE1OWRcXHUwMTgwO2xtXFx1MjkwOVxcdTI5MGFcXHUyOTBkXFx1NDNiY3RpbWFwO1xcdTYyYjhcXHUwYzAwR0xSVmFiY2RlZmdoaWpsbW9wcnN0dXZ3XFx1Mjk0MlxcdTI5NTNcXHUyOTdlXFx1Mjk4OVxcdTI5OThcXHUyOWRhXFx1MjllOVxcdTJhMTVcXHUyYTFhXFx1MmE1OFxcdTJhNWRcXHUyYTgzXFx1MmE5NVxcdTJhYTRcXHUyYWE4XFx1MmIwNFxcdTJiMDdcXHUyYjQ0XFx1MmI3ZlxcdTJiYWVcXHUyYzM0XFx1MmM2N1xcdTJjN2NcXHUyY2U5XFx1MDEwMGd0XFx1Mjk0N1xcdTI5NGI7XFx1YzAwMFxcdTIyZDlcXHUwMzM4XFx1MDEwMDt2XFx1Mjk1MFxcdTBiY2ZcXHVjMDAwXFx1MjI2YlxcdTIwZDJcXHUwMTgwZWx0XFx1Mjk1YVxcdTI5NzJcXHUyOTc2ZnRcXHUwMTAwYXJcXHUyOTYxXFx1Mjk2N3Jyb3c7XFx1NjFjZGlnaHRhcnJvdztcXHU2MWNlO1xcdWMwMDBcXHUyMmQ4XFx1MDMzOFxcdTAxMDA7dlxcdTI5N2JcXHUwYzQ3XFx1YzAwMFxcdTIyNmFcXHUyMGQyaWdodGFycm93O1xcdTYxY2ZcXHUwMTAwRGRcXHUyOThlXFx1Mjk5M2FzaDtcXHU2MmFmYXNoO1xcdTYyYWVcXHUwMjgwYmNucHRcXHUyOWEzXFx1MjlhN1xcdTI5YWNcXHUyOWIxXFx1MjljY2xhXFx4YmJcXHUwMmRldXRlO1xcdTQxNDRnO1xcdWMwMDBcXHUyMjIwXFx1MjBkMlxcdTAyODA7RWlvcFxcdTBkODRcXHUyOWJjXFx1MjljMFxcdTI5YzVcXHUyOWM4O1xcdWMwMDBcXHUyYTcwXFx1MDMzOGQ7XFx1YzAwMFxcdTIyNGJcXHUwMzM4cztcXHU0MTQ5cm9cXHhmOFxcdTBkODR1clxcdTAxMDA7YVxcdTI5ZDNcXHUyOWQ0XFx1NjY2ZWxcXHUwMTAwO3NcXHUyOWQzXFx1MGIzOFxcdTAxZjNcXHUyOWRmXFwwXFx1MjllM3BcXHU4MGJiXFx4YTBcXHUwYjM3bXBcXHUwMTAwO2VcXHUwYmY5XFx1MGMwMFxcdTAyODBhZW91eVxcdTI5ZjRcXHUyOWZlXFx1MmEwM1xcdTJhMTBcXHUyYTEzXFx1MDFmMFxcdTI5ZjlcXDBcXHUyOWZiO1xcdTZhNDNvbjtcXHU0MTQ4ZGlsO1xcdTQxNDZuZ1xcdTAxMDA7ZFxcdTBkN2VcXHUyYTBhb3Q7XFx1YzAwMFxcdTJhNmRcXHUwMzM4cDtcXHU2YTQyO1xcdTQ0M2Rhc2g7XFx1NjAxM1xcdTAzODA7QWFkcXN4XFx1MGI5MlxcdTJhMjlcXHUyYTJkXFx1MmEzYlxcdTJhNDFcXHUyYTQ1XFx1MmE1MHJyO1xcdTYxZDdyXFx1MDEwMGhyXFx1MmEzM1xcdTJhMzZrO1xcdTY5MjRcXHUwMTAwO29cXHUxM2YyXFx1MTNmMG90O1xcdWMwMDBcXHUyMjUwXFx1MDMzOHVpXFx4ZjZcXHUwYjYzXFx1MDEwMGVpXFx1MmE0YVxcdTJhNGVhcjtcXHU2OTI4XFx4ZWRcXHUwYjk4aXN0XFx1MDEwMDtzXFx1MGJhMFxcdTBiOWZyO1xcdWMwMDBcXHVkODM1XFx1ZGQyYlxcdTAyMDBFZXN0XFx1MGJjNVxcdTJhNjZcXHUyYTc5XFx1MmE3Y1xcdTAxODA7cXNcXHUwYmJjXFx1MmE2ZFxcdTBiZTFcXHUwMTgwO3FzXFx1MGJiY1xcdTBiYzVcXHUyYTc0bGFuXFx4ZjRcXHUwYmUyaVxceGVkXFx1MGJlYVxcdTAxMDA7clxcdTBiYjZcXHUyYTgxXFx4YmJcXHUwYmI3XFx1MDE4MEFhcFxcdTJhOGFcXHUyYThkXFx1MmE5MXJcXHhmMlxcdTI5NzFycjtcXHU2MWFlYXI7XFx1NmFmMlxcdTAxODA7c3ZcXHUwZjhkXFx1MmE5Y1xcdTBmOGNcXHUwMTAwO2RcXHUyYWExXFx1MmFhMlxcdTYyZmM7XFx1NjJmYWN5O1xcdTQ0NWFcXHUwMzgwQUVhZGVzdFxcdTJhYjdcXHUyYWJhXFx1MmFiZVxcdTJhYzJcXHUyYWM1XFx1MmFmNlxcdTJhZjlyXFx4ZjJcXHUyOTY2O1xcdWMwMDBcXHUyMjY2XFx1MDMzOHJyO1xcdTYxOWFyO1xcdTYwMjVcXHUwMjAwO2Zxc1xcdTBjM2JcXHUyYWNlXFx1MmFlM1xcdTJhZWZ0XFx1MDEwMGFyXFx1MmFkNFxcdTJhZDlycm9cXHhmN1xcdTJhYzFpZ2h0YXJyb1xceGY3XFx1MmE5MFxcdTAxODA7cXNcXHUwYzNiXFx1MmFiYVxcdTJhZWFsYW5cXHhmNFxcdTBjNTVcXHUwMTAwO3NcXHUwYzU1XFx1MmFmNFxceGJiXFx1MGMzNmlcXHhlZFxcdTBjNWRcXHUwMTAwO3JcXHUwYzM1XFx1MmFmZWlcXHUwMTAwO2VcXHUwYzFhXFx1MGMyNWlcXHhlNFxcdTBkOTBcXHUwMTAwcHRcXHUyYjBjXFx1MmIxMWY7XFx1YzAwMFxcdWQ4MzVcXHVkZDVmXFx1ODE4MFxceGFjO2luXFx1MmIxOVxcdTJiMWFcXHUyYjM2XFx1NDBhY25cXHUwMjAwO0VkdlxcdTBiODlcXHUyYjI0XFx1MmIyOFxcdTJiMmU7XFx1YzAwMFxcdTIyZjlcXHUwMzM4b3Q7XFx1YzAwMFxcdTIyZjVcXHUwMzM4XFx1MDFlMVxcdTBiODlcXHUyYjMzXFx1MmIzNTtcXHU2MmY3O1xcdTYyZjZpXFx1MDEwMDt2XFx1MGNiOFxcdTJiM2NcXHUwMWUxXFx1MGNiOFxcdTJiNDFcXHUyYjQzO1xcdTYyZmU7XFx1NjJmZFxcdTAxODBhb3JcXHUyYjRiXFx1MmI2M1xcdTJiNjlyXFx1MDIwMDthc3RcXHUwYjdiXFx1MmI1NVxcdTJiNWFcXHUyYjVmbGxlXFx4ZWNcXHUwYjdibDtcXHVjMDAwXFx1MmFmZFxcdTIwZTU7XFx1YzAwMFxcdTIyMDJcXHUwMzM4bGludDtcXHU2YTE0XFx1MDE4MDtjZVxcdTBjOTJcXHUyYjcwXFx1MmI3M3VcXHhlNVxcdTBjYTVcXHUwMTAwO2NcXHUwYzk4XFx1MmI3OFxcdTAxMDA7ZVxcdTBjOTJcXHUyYjdkXFx4ZjFcXHUwYzk4XFx1MDIwMEFhaXRcXHUyYjg4XFx1MmI4YlxcdTJiOWRcXHUyYmE3clxceGYyXFx1Mjk4OHJyXFx1MDE4MDtjd1xcdTJiOTRcXHUyYjk1XFx1MmI5OVxcdTYxOWI7XFx1YzAwMFxcdTI5MzNcXHUwMzM4O1xcdWMwMDBcXHUyMTlkXFx1MDMzOGdodGFycm93XFx4YmJcXHUyYjk1cmlcXHUwMTAwO2VcXHUwY2NiXFx1MGNkNlxcdTAzODBjaGltcHF1XFx1MmJiZFxcdTJiY2RcXHUyYmQ5XFx1MmIwNFxcdTBiNzhcXHUyYmU0XFx1MmJlZlxcdTAyMDA7Y2VyXFx1MGQzMlxcdTJiYzZcXHUwZDM3XFx1MmJjOXVcXHhlNVxcdTBkNDU7XFx1YzAwMFxcdWQ4MzVcXHVkY2Mzb3J0XFx1MDI2ZFxcdTJiMDVcXDBcXDBcXHUyYmQ2YXJcXHhlMVxcdTJiNTZtXFx1MDEwMDtlXFx1MGQ2ZVxcdTJiZGZcXHUwMTAwO3FcXHUwZDc0XFx1MGQ3M3N1XFx1MDEwMGJwXFx1MmJlYlxcdTJiZWRcXHhlNVxcdTBjZjhcXHhlNVxcdTBkMGJcXHUwMTgwYmNwXFx1MmJmNlxcdTJjMTFcXHUyYzE5XFx1MDIwMDtFZXNcXHUyYmZmXFx1MmMwMFxcdTBkMjJcXHUyYzA0XFx1NjI4NDtcXHVjMDAwXFx1MmFjNVxcdTAzMzhldFxcdTAxMDA7ZVxcdTBkMWJcXHUyYzBicVxcdTAxMDA7cVxcdTBkMjNcXHUyYzAwY1xcdTAxMDA7ZVxcdTBkMzJcXHUyYzE3XFx4ZjFcXHUwZDM4XFx1MDIwMDtFZXNcXHUyYzIyXFx1MmMyM1xcdTBkNWZcXHUyYzI3XFx1NjI4NTtcXHVjMDAwXFx1MmFjNlxcdTAzMzhldFxcdTAxMDA7ZVxcdTBkNThcXHUyYzJlcVxcdTAxMDA7cVxcdTBkNjBcXHUyYzIzXFx1MDIwMGdpbHJcXHUyYzNkXFx1MmMzZlxcdTJjNDVcXHUyYzQ3XFx4ZWNcXHUwYmQ3bGRlXFx1ODAzYlxceGYxXFx1NDBmMVxceGU3XFx1MGM0M2lhbmdsZVxcdTAxMDBsclxcdTJjNTJcXHUyYzVjZWZ0XFx1MDEwMDtlXFx1MGMxYVxcdTJjNWFcXHhmMVxcdTBjMjZpZ2h0XFx1MDEwMDtlXFx1MGNjYlxcdTJjNjVcXHhmMVxcdTBjZDdcXHUwMTAwO21cXHUyYzZjXFx1MmM2ZFxcdTQzYmRcXHUwMTgwO2VzXFx1MmM3NFxcdTJjNzVcXHUyYzc5XFx1NDAyM3JvO1xcdTYxMTZwO1xcdTYwMDdcXHUwNDgwREhhZGdpbHJzXFx1MmM4ZlxcdTJjOTRcXHUyYzk5XFx1MmM5ZVxcdTJjYTNcXHUyY2IwXFx1MmNiNlxcdTJjZDNcXHUyY2UzYXNoO1xcdTYyYWRhcnI7XFx1NjkwNHA7XFx1YzAwMFxcdTIyNGRcXHUyMGQyYXNoO1xcdTYyYWNcXHUwMTAwZXRcXHUyY2E4XFx1MmNhYztcXHVjMDAwXFx1MjI2NVxcdTIwZDI7XFx1YzAwMD5cXHUyMGQybmZpbjtcXHU2OWRlXFx1MDE4MEFldFxcdTJjYmRcXHUyY2MxXFx1MmNjNXJyO1xcdTY5MDI7XFx1YzAwMFxcdTIyNjRcXHUyMGQyXFx1MDEwMDtyXFx1MmNjYVxcdTJjY2RcXHVjMDAwPFxcdTIwZDJpZTtcXHVjMDAwXFx1MjJiNFxcdTIwZDJcXHUwMTAwQXRcXHUyY2Q4XFx1MmNkY3JyO1xcdTY5MDNyaWU7XFx1YzAwMFxcdTIyYjVcXHUyMGQyaW07XFx1YzAwMFxcdTIyM2NcXHUyMGQyXFx1MDE4MEFhblxcdTJjZjBcXHUyY2Y0XFx1MmQwMnJyO1xcdTYxZDZyXFx1MDEwMGhyXFx1MmNmYVxcdTJjZmRrO1xcdTY5MjNcXHUwMTAwO29cXHUxM2U3XFx1MTNlNWVhcjtcXHU2OTI3XFx1MTI1M1xcdTFhOTVcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXHUyZDJkXFwwXFx1MmQzOFxcdTJkNDhcXHUyZDYwXFx1MmQ2NVxcdTJkNzJcXHUyZDg0XFx1MWIwN1xcMFxcMFxcdTJkOGRcXHUyZGFiXFwwXFx1MmRjOFxcdTJkY2VcXDBcXHUyZGRjXFx1MmUxOVxcdTJlMmJcXHUyZTNlXFx1MmU0M1xcdTAxMDBjc1xcdTJkMzFcXHUxYTk3dXRlXFx1ODAzYlxceGYzXFx1NDBmM1xcdTAxMDBpeVxcdTJkM2NcXHUyZDQ1clxcdTAxMDA7Y1xcdTFhOWVcXHUyZDQyXFx1ODAzYlxceGY0XFx1NDBmNDtcXHU0NDNlXFx1MDI4MGFiaW9zXFx1MWFhMFxcdTJkNTJcXHUyZDU3XFx1MDFjOFxcdTJkNWFsYWM7XFx1NDE1MXY7XFx1NmEzOG9sZDtcXHU2OWJjbGlnO1xcdTQxNTNcXHUwMTAwY3JcXHUyZDY5XFx1MmQ2ZGlyO1xcdTY5YmY7XFx1YzAwMFxcdWQ4MzVcXHVkZDJjXFx1MDM2ZlxcdTJkNzlcXDBcXDBcXHUyZDdjXFwwXFx1MmQ4Mm47XFx1NDJkYmF2ZVxcdTgwM2JcXHhmMlxcdTQwZjI7XFx1NjljMVxcdTAxMDBibVxcdTJkODhcXHUwZGY0YXI7XFx1NjliNVxcdTAyMDBhY2l0XFx1MmQ5NVxcdTJkOThcXHUyZGE1XFx1MmRhOHJcXHhmMlxcdTFhODBcXHUwMTAwaXJcXHUyZDlkXFx1MmRhMHI7XFx1NjliZW9zcztcXHU2OWJiblxceGU1XFx1MGU1MjtcXHU2OWMwXFx1MDE4MGFlaVxcdTJkYjFcXHUyZGI1XFx1MmRiOWNyO1xcdTQxNGRnYTtcXHU0M2M5XFx1MDE4MGNkblxcdTJkYzBcXHUyZGM1XFx1MDFjZHJvbjtcXHU0M2JmO1xcdTY5YjZwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNjBcXHUwMTgwYWVsXFx1MmRkNFxcdTJkZDdcXHUwMWQycjtcXHU2OWI3cnA7XFx1NjliOVxcdTAzODA7YWRpb3N2XFx1MmRlYVxcdTJkZWJcXHUyZGVlXFx1MmUwOFxcdTJlMGRcXHUyZTEwXFx1MmUxNlxcdTYyMjhyXFx4ZjJcXHUxYTg2XFx1MDIwMDtlZm1cXHUyZGY3XFx1MmRmOFxcdTJlMDJcXHUyZTA1XFx1NmE1ZHJcXHUwMTAwO29cXHUyZGZlXFx1MmRmZlxcdTYxMzRmXFx4YmJcXHUyZGZmXFx1ODAzYlxceGFhXFx1NDBhYVxcdTgwM2JcXHhiYVxcdTQwYmFnb2Y7XFx1NjJiNnI7XFx1NmE1NmxvcGU7XFx1NmE1NztcXHU2YTViXFx1MDE4MGNsb1xcdTJlMWZcXHUyZTIxXFx1MmUyN1xceGYyXFx1MmUwMWFzaFxcdTgwM2JcXHhmOFxcdTQwZjhsO1xcdTYyOThpXFx1MDE2Y1xcdTJlMmZcXHUyZTM0ZGVcXHU4MDNiXFx4ZjVcXHU0MGY1ZXNcXHUwMTAwO2FcXHUwMWRiXFx1MmUzYXM7XFx1NmEzNm1sXFx1ODAzYlxceGY2XFx1NDBmNmJhcjtcXHU2MzNkXFx1MGFlMVxcdTJlNWVcXDBcXHUyZTdkXFwwXFx1MmU4MFxcdTJlOWRcXDBcXHUyZWEyXFx1MmViOVxcMFxcMFxcdTJlY2JcXHUwZTljXFwwXFx1MmYxM1xcMFxcMFxcdTJmMmJcXHUyZmJjXFwwXFx1MmZjOHJcXHUwMjAwO2FzdFxcdTA0MDNcXHUyZTY3XFx1MmU3MlxcdTBlODVcXHU4MTAwXFx4YjY7bFxcdTJlNmRcXHUyZTZlXFx1NDBiNmxlXFx4ZWNcXHUwNDAzXFx1MDI2OVxcdTJlNzhcXDBcXDBcXHUyZTdibTtcXHU2YWYzO1xcdTZhZmR5O1xcdTQ0M2ZyXFx1MDI4MGNpbXB0XFx1MmU4YlxcdTJlOGZcXHUyZTkzXFx1MTg2NVxcdTJlOTdudDtcXHU0MDI1b2Q7XFx1NDAyZWlsO1xcdTYwMzBlbms7XFx1NjAzMXI7XFx1YzAwMFxcdWQ4MzVcXHVkZDJkXFx1MDE4MGltb1xcdTJlYThcXHUyZWIwXFx1MmViNFxcdTAxMDA7dlxcdTJlYWRcXHUyZWFlXFx1NDNjNjtcXHU0M2Q1bWFcXHhmNFxcdTBhNzZuZTtcXHU2NjBlXFx1MDE4MDt0dlxcdTJlYmZcXHUyZWMwXFx1MmVjOFxcdTQzYzBjaGZvcmtcXHhiYlxcdTFmZmQ7XFx1NDNkNlxcdTAxMDBhdVxcdTJlY2ZcXHUyZWRmblxcdTAxMDBja1xcdTJlZDVcXHUyZWRka1xcdTAxMDA7aFxcdTIxZjRcXHUyZWRiO1xcdTYxMGVcXHhmNlxcdTIxZjRzXFx1MDQ4MDthYmNkZW1zdFxcdTJlZjNcXHUyZWY0XFx1MTkwOFxcdTJlZjlcXHUyZWZkXFx1MmYwNFxcdTJmMDZcXHUyZjBhXFx1MmYwZVxcdTQwMmJjaXI7XFx1NmEyM2lyO1xcdTZhMjJcXHUwMTAwb3VcXHUxZDQwXFx1MmYwMjtcXHU2YTI1O1xcdTZhNzJuXFx1ODBiYlxceGIxXFx1MGU5ZGltO1xcdTZhMjZ3bztcXHU2YTI3XFx1MDE4MGlwdVxcdTJmMTlcXHUyZjIwXFx1MmYyNW50aW50O1xcdTZhMTVmO1xcdWMwMDBcXHVkODM1XFx1ZGQ2MW5kXFx1ODAzYlxceGEzXFx1NDBhM1xcdTA1MDA7RWFjZWlub3N1XFx1MGVjOFxcdTJmM2ZcXHUyZjQxXFx1MmY0NFxcdTJmNDdcXHUyZjgxXFx1MmY4OVxcdTJmOTJcXHUyZjdlXFx1MmZiNjtcXHU2YWIzcDtcXHU2YWI3dVxceGU1XFx1MGVkOVxcdTAxMDA7Y1xcdTBlY2VcXHUyZjRjXFx1MDMwMDthY2Vuc1xcdTBlYzhcXHUyZjU5XFx1MmY1ZlxcdTJmNjZcXHUyZjY4XFx1MmY3ZXBwcm9cXHhmOFxcdTJmNDN1cmx5ZVxceGYxXFx1MGVkOVxceGYxXFx1MGVjZVxcdTAxODBhZXNcXHUyZjZmXFx1MmY3NlxcdTJmN2FwcHJveDtcXHU2YWI5cXE7XFx1NmFiNWltO1xcdTYyZThpXFx4ZWRcXHUwZWRmbWVcXHUwMTAwO3NcXHUyZjg4XFx1MGVhZVxcdTYwMzJcXHUwMTgwRWFzXFx1MmY3OFxcdTJmOTBcXHUyZjdhXFx4ZjBcXHUyZjc1XFx1MDE4MGRmcFxcdTBlZWNcXHUyZjk5XFx1MmZhZlxcdTAxODBhbHNcXHUyZmEwXFx1MmZhNVxcdTJmYWFsYXI7XFx1NjMyZWluZTtcXHU2MzEydXJmO1xcdTYzMTNcXHUwMTAwO3RcXHUwZWZiXFx1MmZiNFxceGVmXFx1MGVmYnJlbDtcXHU2MmIwXFx1MDEwMGNpXFx1MmZjMFxcdTJmYzVyO1xcdWMwMDBcXHVkODM1XFx1ZGNjNTtcXHU0M2M4bmNzcDtcXHU2MDA4XFx1MDMwMGZpb3BzdVxcdTJmZGFcXHUyMmUyXFx1MmZkZlxcdTJmZTVcXHUyZmViXFx1MmZmMXI7XFx1YzAwMFxcdWQ4MzVcXHVkZDJlcGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDYycmltZTtcXHU2MDU3Y3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2M2XFx1MDE4MGFlb1xcdTJmZjhcXHUzMDA5XFx1MzAxM3RcXHUwMTAwZWlcXHUyZmZlXFx1MzAwNXJuaW9uXFx4ZjNcXHUwNmIwbnQ7XFx1NmExNnN0XFx1MDEwMDtlXFx1MzAxMFxcdTMwMTFcXHU0MDNmXFx4ZjFcXHUxZjE5XFx4ZjRcXHUwZjE0XFx1MGE4MEFCSGFiY2RlZmhpbG1ub3Byc3R1eFxcdTMwNDBcXHUzMDUxXFx1MzA1NVxcdTMwNTlcXHUzMGUwXFx1MzEwZVxcdTMxMmJcXHUzMTQ3XFx1MzE2MlxcdTMxNzJcXHUzMThlXFx1MzIwNlxcdTMyMTVcXHUzMjI0XFx1MzIyOVxcdTMyNThcXHUzMjZlXFx1MzI3MlxcdTMyOTBcXHUzMmIwXFx1MzJiN1xcdTAxODBhcnRcXHUzMDQ3XFx1MzA0YVxcdTMwNGNyXFx4ZjJcXHUxMGIzXFx4ZjJcXHUwM2RkYWlsO1xcdTY5MWNhclxceGYyXFx1MWM2NWFyO1xcdTY5NjRcXHUwMzgwY2RlbnFydFxcdTMwNjhcXHUzMDc1XFx1MzA3OFxcdTMwN2ZcXHUzMDhmXFx1MzA5NFxcdTMwY2NcXHUwMTAwZXVcXHUzMDZkXFx1MzA3MTtcXHVjMDAwXFx1MjIzZFxcdTAzMzF0ZTtcXHU0MTU1aVxceGUzXFx1MTE2ZW1wdHl2O1xcdTY5YjNnXFx1MDIwMDtkZWxcXHUwZmQxXFx1MzA4OVxcdTMwOGJcXHUzMDhkO1xcdTY5OTI7XFx1NjlhNVxceGU1XFx1MGZkMXVvXFx1ODAzYlxceGJiXFx1NDBiYnJcXHUwNTgwO2FiY2ZobHBzdHdcXHUwZmRjXFx1MzBhY1xcdTMwYWZcXHUzMGI3XFx1MzBiOVxcdTMwYmNcXHUzMGJlXFx1MzBjMFxcdTMwYzNcXHUzMGM3XFx1MzBjYXA7XFx1Njk3NVxcdTAxMDA7ZlxcdTBmZTBcXHUzMGI0cztcXHU2OTIwO1xcdTY5MzNzO1xcdTY5MWVcXHhlYlxcdTIyNWRcXHhmMFxcdTI3MmVsO1xcdTY5NDVpbTtcXHU2OTc0bDtcXHU2MWEzO1xcdTYxOWRcXHUwMTAwYWlcXHUzMGQxXFx1MzBkNWlsO1xcdTY5MWFvXFx1MDEwMDtuXFx1MzBkYlxcdTMwZGNcXHU2MjM2YWxcXHhmM1xcdTBmMWVcXHUwMTgwYWJyXFx1MzBlN1xcdTMwZWFcXHUzMGVlclxceGYyXFx1MTdlNXJrO1xcdTY3NzNcXHUwMTAwYWtcXHUzMGYzXFx1MzBmZGNcXHUwMTAwZWtcXHUzMGY5XFx1MzBmYjtcXHU0MDdkO1xcdTQwNWRcXHUwMTAwZXNcXHUzMTAyXFx1MzEwNDtcXHU2OThjbFxcdTAxMDBkdVxcdTMxMGFcXHUzMTBjO1xcdTY5OGU7XFx1Njk5MFxcdTAyMDBhZXV5XFx1MzExN1xcdTMxMWNcXHUzMTI3XFx1MzEyOXJvbjtcXHU0MTU5XFx1MDEwMGRpXFx1MzEyMVxcdTMxMjVpbDtcXHU0MTU3XFx4ZWNcXHUwZmYyXFx4ZTJcXHUzMGZhO1xcdTQ0NDBcXHUwMjAwY2xxc1xcdTMxMzRcXHUzMTM3XFx1MzEzZFxcdTMxNDRhO1xcdTY5MzdkaGFyO1xcdTY5Njl1b1xcdTAxMDA7clxcdTAyMGVcXHUwMjBkaDtcXHU2MWIzXFx1MDE4MGFjZ1xcdTMxNGVcXHUzMTVmXFx1MGY0NGxcXHUwMjAwO2lwc1xcdTBmNzhcXHUzMTU4XFx1MzE1YlxcdTEwOWNuXFx4ZTVcXHUxMGJiYXJcXHhmNFxcdTBmYTl0O1xcdTY1YWRcXHUwMTgwaWxyXFx1MzE2OVxcdTEwMjNcXHUzMTZlc2h0O1xcdTY5N2Q7XFx1YzAwMFxcdWQ4MzVcXHVkZDJmXFx1MDEwMGFvXFx1MzE3N1xcdTMxODZyXFx1MDEwMGR1XFx1MzE3ZFxcdTMxN2ZcXHhiYlxcdTA0N2JcXHUwMTAwO2xcXHUxMDkxXFx1MzE4NDtcXHU2OTZjXFx1MDEwMDt2XFx1MzE4YlxcdTMxOGNcXHU0M2MxO1xcdTQzZjFcXHUwMTgwZ25zXFx1MzE5NVxcdTMxZjlcXHUzMWZjaHRcXHUwMzAwYWhscnN0XFx1MzFhNFxcdTMxYjBcXHUzMWMyXFx1MzFkOFxcdTMxZTRcXHUzMWVlcnJvd1xcdTAxMDA7dFxcdTBmZGNcXHUzMWFkYVxceGU5XFx1MzBjOGFycG9vblxcdTAxMDBkdVxcdTMxYmJcXHUzMWJmb3dcXHhlZVxcdTMxN2VwXFx4YmJcXHUxMDkyZWZ0XFx1MDEwMGFoXFx1MzFjYVxcdTMxZDBycm93XFx4ZjNcXHUwZmVhYXJwb29uXFx4ZjNcXHUwNTUxaWdodGFycm93cztcXHU2MWM5cXVpZ2Fycm9cXHhmN1xcdTMwY2JocmVldGltZXM7XFx1NjJjY2c7XFx1NDJkYWluZ2RvdHNlXFx4ZjFcXHUxZjMyXFx1MDE4MGFobVxcdTMyMGRcXHUzMjEwXFx1MzIxM3JcXHhmMlxcdTBmZWFhXFx4ZjJcXHUwNTUxO1xcdTYwMGZvdXN0XFx1MDEwMDthXFx1MzIxZVxcdTMyMWZcXHU2M2IxY2hlXFx4YmJcXHUzMjFmbWlkO1xcdTZhZWVcXHUwMjAwYWJwdFxcdTMyMzJcXHUzMjNkXFx1MzI0MFxcdTMyNTJcXHUwMTAwbnJcXHUzMjM3XFx1MzIzYWc7XFx1NjdlZHI7XFx1NjFmZXJcXHhlYlxcdTEwMDNcXHUwMTgwYWZsXFx1MzI0N1xcdTMyNGFcXHUzMjRlcjtcXHU2OTg2O1xcdWMwMDBcXHVkODM1XFx1ZGQ2M3VzO1xcdTZhMmVpbWVzO1xcdTZhMzVcXHUwMTAwYXBcXHUzMjVkXFx1MzI2N3JcXHUwMTAwO2dcXHUzMjYzXFx1MzI2NFxcdTQwMjl0O1xcdTY5OTRvbGludDtcXHU2YTEyYXJcXHhmMlxcdTMxZTNcXHUwMjAwYWNocVxcdTMyN2JcXHUzMjgwXFx1MTBiY1xcdTMyODVxdW87XFx1NjAzYXI7XFx1YzAwMFxcdWQ4MzVcXHVkY2M3XFx1MDEwMGJ1XFx1MzBmYlxcdTMyOGFvXFx1MDEwMDtyXFx1MDIxNFxcdTAyMTNcXHUwMTgwaGlyXFx1MzI5N1xcdTMyOWJcXHUzMmEwcmVcXHhlNVxcdTMxZjhtZXM7XFx1NjJjYWlcXHUwMjAwO2VmbFxcdTMyYWFcXHUxMDU5XFx1MTgyMVxcdTMyYWJcXHU2NWI5dHJpO1xcdTY5Y2VsdWhhcjtcXHU2OTY4O1xcdTYxMWVcXHUwZDYxXFx1MzJkNVxcdTMyZGJcXHUzMmRmXFx1MzMyY1xcdTMzMzhcXHUzMzcxXFwwXFx1MzM3YVxcdTMzYTRcXDBcXDBcXHUzM2VjXFx1MzNmMFxcMFxcdTM0MjhcXHUzNDQ4XFx1MzQ1YVxcdTM0YWRcXHUzNGIxXFx1MzRjYVxcdTM0ZjFcXDBcXHUzNjE2XFwwXFwwXFx1MzYzM2N1dGU7XFx1NDE1YnF1XFx4ZWZcXHUyN2JhXFx1MDUwMDtFYWNlaW5wc3lcXHUxMWVkXFx1MzJmM1xcdTMyZjVcXHUzMmZmXFx1MzMwMlxcdTMzMGJcXHUzMzBmXFx1MzMxZlxcdTMzMjZcXHUzMzI5O1xcdTZhYjRcXHUwMWYwXFx1MzJmYVxcMFxcdTMyZmM7XFx1NmFiOG9uO1xcdTQxNjF1XFx4ZTVcXHUxMWZlXFx1MDEwMDtkXFx1MTFmM1xcdTMzMDdpbDtcXHU0MTVmcmM7XFx1NDE1ZFxcdTAxODBFYXNcXHUzMzE2XFx1MzMxOFxcdTMzMWI7XFx1NmFiNnA7XFx1NmFiYWltO1xcdTYyZTlvbGludDtcXHU2YTEzaVxceGVkXFx1MTIwNDtcXHU0NDQxb3RcXHUwMTgwO2JlXFx1MzMzNFxcdTFkNDdcXHUzMzM1XFx1NjJjNTtcXHU2YTY2XFx1MDM4MEFhY21zdHhcXHUzMzQ2XFx1MzM0YVxcdTMzNTdcXHUzMzViXFx1MzM1ZVxcdTMzNjNcXHUzMzZkcnI7XFx1NjFkOHJcXHUwMTAwaHJcXHUzMzUwXFx1MzM1MlxceGViXFx1MjIyOFxcdTAxMDA7b1xcdTBhMzZcXHUwYTM0dFxcdTgwM2JcXHhhN1xcdTQwYTdpO1xcdTQwM2J3YXI7XFx1NjkyOW1cXHUwMTAwaW5cXHUzMzY5XFx4ZjBudVxceGYzXFx4ZjF0O1xcdTY3MzZyXFx1MDEwMDtvXFx1MzM3NlxcdTIwNTVcXHVjMDAwXFx1ZDgzNVxcdWRkMzBcXHUwMjAwYWNveVxcdTMzODJcXHUzMzg2XFx1MzM5MVxcdTMzYTBycDtcXHU2NjZmXFx1MDEwMGh5XFx1MzM4YlxcdTMzOGZjeTtcXHU0NDQ5O1xcdTQ0NDhydFxcdTAyNmRcXHUzMzk5XFwwXFwwXFx1MzM5Y2lcXHhlNFxcdTE0NjRhcmFcXHhlY1xcdTJlNmZcXHU4MDNiXFx4YWRcXHU0MGFkXFx1MDEwMGdtXFx1MzNhOFxcdTMzYjRtYVxcdTAxODA7ZnZcXHUzM2IxXFx1MzNiMlxcdTMzYjJcXHU0M2MzO1xcdTQzYzJcXHUwNDAwO2RlZ2xucHJcXHUxMmFiXFx1MzNjNVxcdTMzYzlcXHUzM2NlXFx1MzNkNlxcdTMzZGVcXHUzM2UxXFx1MzNlNm90O1xcdTZhNmFcXHUwMTAwO3FcXHUxMmIxXFx1MTJiMFxcdTAxMDA7RVxcdTMzZDNcXHUzM2Q0XFx1NmE5ZTtcXHU2YWEwXFx1MDEwMDtFXFx1MzNkYlxcdTMzZGNcXHU2YTlkO1xcdTZhOWZlO1xcdTYyNDZsdXM7XFx1NmEyNGFycjtcXHU2OTcyYXJcXHhmMlxcdTExM2RcXHUwMjAwYWVpdFxcdTMzZjhcXHUzNDA4XFx1MzQwZlxcdTM0MTdcXHUwMTAwbHNcXHUzM2ZkXFx1MzQwNGxzZXRtXFx4ZTlcXHUzMzZhaHA7XFx1NmEzM3BhcnNsO1xcdTY5ZTRcXHUwMTAwZGxcXHUxNDYzXFx1MzQxNGU7XFx1NjMyM1xcdTAxMDA7ZVxcdTM0MWNcXHUzNDFkXFx1NmFhYVxcdTAxMDA7c1xcdTM0MjJcXHUzNDIzXFx1NmFhYztcXHVjMDAwXFx1MmFhY1xcdWZlMDBcXHUwMTgwZmxwXFx1MzQyZVxcdTM0MzNcXHUzNDQydGN5O1xcdTQ0NGNcXHUwMTAwO2JcXHUzNDM4XFx1MzQzOVxcdTQwMmZcXHUwMTAwO2FcXHUzNDNlXFx1MzQzZlxcdTY5YzRyO1xcdTYzM2ZmO1xcdWMwMDBcXHVkODM1XFx1ZGQ2NGFcXHUwMTAwZHJcXHUzNDRkXFx1MDQwMmVzXFx1MDEwMDt1XFx1MzQ1NFxcdTM0NTVcXHU2NjYwaXRcXHhiYlxcdTM0NTVcXHUwMTgwY3N1XFx1MzQ2MFxcdTM0NzlcXHUzNDlmXFx1MDEwMGF1XFx1MzQ2NVxcdTM0NmZwXFx1MDEwMDtzXFx1MTE4OFxcdTM0NmI7XFx1YzAwMFxcdTIyOTNcXHVmZTAwcFxcdTAxMDA7c1xcdTExYjRcXHUzNDc1O1xcdWMwMDBcXHUyMjk0XFx1ZmUwMHVcXHUwMTAwYnBcXHUzNDdmXFx1MzQ4ZlxcdTAxODA7ZXNcXHUxMTk3XFx1MTE5Y1xcdTM0ODZldFxcdTAxMDA7ZVxcdTExOTdcXHUzNDhkXFx4ZjFcXHUxMTlkXFx1MDE4MDtlc1xcdTExYThcXHUxMWFkXFx1MzQ5NmV0XFx1MDEwMDtlXFx1MTFhOFxcdTM0OWRcXHhmMVxcdTExYWVcXHUwMTgwO2FmXFx1MTE3YlxcdTM0YTZcXHUwNWIwclxcdTAxNjVcXHUzNGFiXFx1MDViMVxceGJiXFx1MTE3Y2FyXFx4ZjJcXHUxMTQ4XFx1MDIwMGNlbXRcXHUzNGI5XFx1MzRiZVxcdTM0YzJcXHUzNGM1cjtcXHVjMDAwXFx1ZDgzNVxcdWRjYzh0bVxceGVlXFx4ZjFpXFx4ZWNcXHUzNDE1YXJcXHhlNlxcdTExYmVcXHUwMTAwYXJcXHUzNGNlXFx1MzRkNXJcXHUwMTAwO2ZcXHUzNGQ0XFx1MTdiZlxcdTY2MDZcXHUwMTAwYW5cXHUzNGRhXFx1MzRlZGlnaHRcXHUwMTAwZXBcXHUzNGUzXFx1MzRlYXBzaWxvXFx4ZWVcXHUxZWUwaFxceGU5XFx1MmVhZnNcXHhiYlxcdTI4NTJcXHUwMjgwYmNtbnBcXHUzNGZiXFx1MzU1ZVxcdTEyMDlcXHUzNThiXFx1MzU4ZVxcdTA0ODA7RWRlbW5wcnNcXHUzNTBlXFx1MzUwZlxcdTM1MTFcXHUzNTE1XFx1MzUxZVxcdTM1MjNcXHUzNTJjXFx1MzUzMVxcdTM1MzZcXHU2MjgyO1xcdTZhYzVvdDtcXHU2YWJkXFx1MDEwMDtkXFx1MTFkYVxcdTM1MWFvdDtcXHU2YWMzdWx0O1xcdTZhYzFcXHUwMTAwRWVcXHUzNTI4XFx1MzUyYTtcXHU2YWNiO1xcdTYyOGFsdXM7XFx1NmFiZmFycjtcXHU2OTc5XFx1MDE4MGVpdVxcdTM1M2RcXHUzNTUyXFx1MzU1NXRcXHUwMTgwO2VuXFx1MzUwZVxcdTM1NDVcXHUzNTRicVxcdTAxMDA7cVxcdTExZGFcXHUzNTBmZXFcXHUwMTAwO3FcXHUzNTJiXFx1MzUyOG07XFx1NmFjN1xcdTAxMDBicFxcdTM1NWFcXHUzNTVjO1xcdTZhZDU7XFx1NmFkM2NcXHUwMzAwO2FjZW5zXFx1MTFlZFxcdTM1NmNcXHUzNTcyXFx1MzU3OVxcdTM1N2JcXHUzMzI2cHByb1xceGY4XFx1MzJmYXVybHllXFx4ZjFcXHUxMWZlXFx4ZjFcXHUxMWYzXFx1MDE4MGFlc1xcdTM1ODJcXHUzNTg4XFx1MzMxYnBwcm9cXHhmOFxcdTMzMWFxXFx4ZjFcXHUzMzE3ZztcXHU2NjZhXFx1MDY4MDEyMztFZGVobG1ucHNcXHUzNWE5XFx1MzVhY1xcdTM1YWZcXHUxMjFjXFx1MzViMlxcdTM1YjRcXHUzNWMwXFx1MzVjOVxcdTM1ZDVcXHUzNWRhXFx1MzVkZlxcdTM1ZThcXHUzNWVkXFx1ODAzYlxceGI5XFx1NDBiOVxcdTgwM2JcXHhiMlxcdTQwYjJcXHU4MDNiXFx4YjNcXHU0MGIzO1xcdTZhYzZcXHUwMTAwb3NcXHUzNWI5XFx1MzViY3Q7XFx1NmFiZXViO1xcdTZhZDhcXHUwMTAwO2RcXHUxMjIyXFx1MzVjNW90O1xcdTZhYzRzXFx1MDEwMG91XFx1MzVjZlxcdTM1ZDJsO1xcdTY3YzliO1xcdTZhZDdhcnI7XFx1Njk3YnVsdDtcXHU2YWMyXFx1MDEwMEVlXFx1MzVlNFxcdTM1ZTY7XFx1NmFjYztcXHU2MjhibHVzO1xcdTZhYzBcXHUwMTgwZWl1XFx1MzVmNFxcdTM2MDlcXHUzNjBjdFxcdTAxODA7ZW5cXHUxMjFjXFx1MzVmY1xcdTM2MDJxXFx1MDEwMDtxXFx1MTIyMlxcdTM1YjJlcVxcdTAxMDA7cVxcdTM1ZTdcXHUzNWU0bTtcXHU2YWM4XFx1MDEwMGJwXFx1MzYxMVxcdTM2MTM7XFx1NmFkNDtcXHU2YWQ2XFx1MDE4MEFhblxcdTM2MWNcXHUzNjIwXFx1MzYyZHJyO1xcdTYxZDlyXFx1MDEwMGhyXFx1MzYyNlxcdTM2MjhcXHhlYlxcdTIyMmVcXHUwMTAwO29cXHUwYTJiXFx1MGEyOXdhcjtcXHU2OTJhbGlnXFx1ODAzYlxceGRmXFx1NDBkZlxcdTBiZTFcXHUzNjUxXFx1MzY1ZFxcdTM2NjBcXHUxMmNlXFx1MzY3M1xcdTM2NzlcXDBcXHUzNjdlXFx1MzZjMlxcMFxcMFxcMFxcMFxcMFxcdTM2ZGJcXHUzNzAzXFwwXFx1MzcwOVxcdTM3NmNcXDBcXDBcXDBcXHUzNzg3XFx1MDI3MlxcdTM2NTZcXDBcXDBcXHUzNjViZ2V0O1xcdTYzMTY7XFx1NDNjNHJcXHhlYlxcdTBlNWZcXHUwMTgwYWV5XFx1MzY2NlxcdTM2NmJcXHUzNjcwcm9uO1xcdTQxNjVkaWw7XFx1NDE2MztcXHU0NDQybHJlYztcXHU2MzE1cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMzFcXHUwMjAwZWlrb1xcdTM2ODZcXHUzNjlkXFx1MzZiNVxcdTM2YmNcXHUwMWYyXFx1MzY4YlxcMFxcdTM2OTFlXFx1MDEwMDRmXFx1MTI4NFxcdTEyODFhXFx1MDE4MDtzdlxcdTM2OThcXHUzNjk5XFx1MzY5YlxcdTQzYjh5bTtcXHU0M2QxXFx1MDEwMGNuXFx1MzZhMlxcdTM2YjJrXFx1MDEwMGFzXFx1MzZhOFxcdTM2YWVwcHJvXFx4ZjhcXHUxMmMxaW1cXHhiYlxcdTEyYWNzXFx4ZjBcXHUxMjllXFx1MDEwMGFzXFx1MzZiYVxcdTM2YWVcXHhmMFxcdTEyYzFyblxcdTgwM2JcXHhmZVxcdTQwZmVcXHUwMWVjXFx1MDMxZlxcdTM2YzZcXHUyMmU3ZXNcXHU4MTgwXFx4ZDc7YmRcXHUzNmNmXFx1MzZkMFxcdTM2ZDhcXHU0MGQ3XFx1MDEwMDthXFx1MTkwZlxcdTM2ZDVyO1xcdTZhMzE7XFx1NmEzMFxcdTAxODBlcHNcXHUzNmUxXFx1MzZlM1xcdTM3MDBcXHhlMVxcdTJhNGRcXHUwMjAwO2JjZlxcdTA0ODZcXHUzNmVjXFx1MzZmMFxcdTM2ZjRvdDtcXHU2MzM2aXI7XFx1NmFmMVxcdTAxMDA7b1xcdTM2ZjlcXHUzNmZjXFx1YzAwMFxcdWQ4MzVcXHVkZDY1cms7XFx1NmFkYVxceGUxXFx1MzM2MnJpbWU7XFx1NjAzNFxcdTAxODBhaXBcXHUzNzBmXFx1MzcxMlxcdTM3NjRkXFx4ZTVcXHUxMjQ4XFx1MDM4MGFkZW1wc3RcXHUzNzIxXFx1Mzc0ZFxcdTM3NDBcXHUzNzUxXFx1Mzc1N1xcdTM3NWNcXHUzNzVmbmdsZVxcdTAyODA7ZGxxclxcdTM3MzBcXHUzNzMxXFx1MzczNlxcdTM3NDBcXHUzNzQyXFx1NjViNW93blxceGJiXFx1MWRiYmVmdFxcdTAxMDA7ZVxcdTI4MDBcXHUzNzNlXFx4ZjFcXHUwOTJlO1xcdTYyNWNpZ2h0XFx1MDEwMDtlXFx1MzJhYVxcdTM3NGJcXHhmMVxcdTEwNWFvdDtcXHU2NWVjaW51cztcXHU2YTNhbHVzO1xcdTZhMzliO1xcdTY5Y2RpbWU7XFx1NmEzYmV6aXVtO1xcdTYzZTJcXHUwMTgwY2h0XFx1Mzc3MlxcdTM3N2RcXHUzNzgxXFx1MDEwMHJ5XFx1Mzc3N1xcdTM3N2I7XFx1YzAwMFxcdWQ4MzVcXHVkY2M5O1xcdTQ0NDZjeTtcXHU0NDVicm9rO1xcdTQxNjdcXHUwMTAwaW9cXHUzNzhiXFx1Mzc4ZXhcXHhmNFxcdTE3NzdoZWFkXFx1MDEwMGxyXFx1Mzc5N1xcdTM3YTBlZnRhcnJvXFx4ZjdcXHUwODRmaWdodGFycm93XFx4YmJcXHUwZjVkXFx1MDkwMEFIYWJjZGZnaGxtb3Byc3R1d1xcdTM3ZDBcXHUzN2QzXFx1MzdkN1xcdTM3ZTRcXHUzN2YwXFx1MzdmY1xcdTM4MGVcXHUzODFjXFx1MzgyM1xcdTM4MzRcXHUzODUxXFx1Mzg1ZFxcdTM4NmJcXHUzOGE5XFx1MzhjY1xcdTM4ZDJcXHUzOGVhXFx1MzhmNnJcXHhmMlxcdTAzZWRhcjtcXHU2OTYzXFx1MDEwMGNyXFx1MzdkY1xcdTM3ZTJ1dGVcXHU4MDNiXFx4ZmFcXHU0MGZhXFx4ZjJcXHUxMTUwclxcdTAxZTNcXHUzN2VhXFwwXFx1MzdlZHk7XFx1NDQ1ZXZlO1xcdTQxNmRcXHUwMTAwaXlcXHUzN2Y1XFx1MzdmYXJjXFx1ODAzYlxceGZiXFx1NDBmYjtcXHU0NDQzXFx1MDE4MGFiaFxcdTM4MDNcXHUzODA2XFx1MzgwYnJcXHhmMlxcdTEzYWRsYWM7XFx1NDE3MWFcXHhmMlxcdTEzYzNcXHUwMTAwaXJcXHUzODEzXFx1MzgxOHNodDtcXHU2OTdlO1xcdWMwMDBcXHVkODM1XFx1ZGQzMnJhdmVcXHU4MDNiXFx4ZjlcXHU0MGY5XFx1MDE2MVxcdTM4MjdcXHUzODMxclxcdTAxMDBsclxcdTM4MmNcXHUzODJlXFx4YmJcXHUwOTU3XFx4YmJcXHUxMDgzbGs7XFx1NjU4MFxcdTAxMDBjdFxcdTM4MzlcXHUzODRkXFx1MDI2ZlxcdTM4M2ZcXDBcXDBcXHUzODRhcm5cXHUwMTAwO2VcXHUzODQ1XFx1Mzg0NlxcdTYzMWNyXFx4YmJcXHUzODQ2b3A7XFx1NjMwZnJpO1xcdTY1ZjhcXHUwMTAwYWxcXHUzODU2XFx1Mzg1YWNyO1xcdTQxNmJcXHU4MGJiXFx4YThcXHUwMzQ5XFx1MDEwMGdwXFx1Mzg2MlxcdTM4NjZvbjtcXHU0MTczZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNjZcXHUwMzAwYWRobHN1XFx1MTE0YlxcdTM4NzhcXHUzODdkXFx1MTM3MlxcdTM4OTFcXHUzOGEwb3duXFx4ZTFcXHUxM2IzYXJwb29uXFx1MDEwMGxyXFx1Mzg4OFxcdTM4OGNlZlxceGY0XFx1MzgyZGlnaFxceGY0XFx1MzgyZmlcXHUwMTgwO2hsXFx1Mzg5OVxcdTM4OWFcXHUzODljXFx1NDNjNVxceGJiXFx1MTNmYW9uXFx4YmJcXHUzODlhcGFycm93cztcXHU2MWM4XFx1MDE4MGNpdFxcdTM4YjBcXHUzOGM0XFx1MzhjOFxcdTAyNmZcXHUzOGI2XFwwXFwwXFx1MzhjMXJuXFx1MDEwMDtlXFx1MzhiY1xcdTM4YmRcXHU2MzFkclxceGJiXFx1MzhiZG9wO1xcdTYzMGVuZztcXHU0MTZmcmk7XFx1NjVmOWNyO1xcdWMwMDBcXHVkODM1XFx1ZGNjYVxcdTAxODBkaXJcXHUzOGQ5XFx1MzhkZFxcdTM4ZTJvdDtcXHU2MmYwbGRlO1xcdTQxNjlpXFx1MDEwMDtmXFx1MzczMFxcdTM4ZThcXHhiYlxcdTE4MTNcXHUwMTAwYW1cXHUzOGVmXFx1MzhmMnJcXHhmMlxcdTM4YThsXFx1ODAzYlxceGZjXFx1NDBmY2FuZ2xlO1xcdTY5YTdcXHUwNzgwQUJEYWNkZWZsbm9wcnN6XFx1MzkxY1xcdTM5MWZcXHUzOTI5XFx1MzkyZFxcdTM5YjVcXHUzOWI4XFx1MzliZFxcdTM5ZGZcXHUzOWU0XFx1MzllOFxcdTM5ZjNcXHUzOWY5XFx1MzlmZFxcdTNhMDFcXHUzYTIwclxceGYyXFx1MDNmN2FyXFx1MDEwMDt2XFx1MzkyNlxcdTM5MjdcXHU2YWU4O1xcdTZhZTlhc1xceGU4XFx1MDNlMVxcdTAxMDBuclxcdTM5MzJcXHUzOTM3Z3J0O1xcdTY5OWNcXHUwMzgwZWtucHJzdFxcdTM0ZTNcXHUzOTQ2XFx1Mzk0YlxcdTM5NTJcXHUzOTVkXFx1Mzk2NFxcdTM5OTZhcHBcXHhlMVxcdTI0MTVvdGhpblxceGU3XFx1MWU5NlxcdTAxODBoaXJcXHUzNGViXFx1MmVjOFxcdTM5NTlvcFxceGY0XFx1MmZiNVxcdTAxMDA7aFxcdTEzYjdcXHUzOTYyXFx4ZWZcXHUzMThkXFx1MDEwMGl1XFx1Mzk2OVxcdTM5NmRnbVxceGUxXFx1MzNiM1xcdTAxMDBicFxcdTM5NzJcXHUzOTg0c2V0bmVxXFx1MDEwMDtxXFx1Mzk3ZFxcdTM5ODBcXHVjMDAwXFx1MjI4YVxcdWZlMDA7XFx1YzAwMFxcdTJhY2JcXHVmZTAwc2V0bmVxXFx1MDEwMDtxXFx1Mzk4ZlxcdTM5OTJcXHVjMDAwXFx1MjI4YlxcdWZlMDA7XFx1YzAwMFxcdTJhY2NcXHVmZTAwXFx1MDEwMGhyXFx1Mzk5YlxcdTM5OWZldFxceGUxXFx1MzY5Y2lhbmdsZVxcdTAxMDBsclxcdTM5YWFcXHUzOWFmZWZ0XFx4YmJcXHUwOTI1aWdodFxceGJiXFx1MTA1MXk7XFx1NDQzMmFzaFxceGJiXFx1MTAzNlxcdTAxODBlbHJcXHUzOWM0XFx1MzlkMlxcdTM5ZDdcXHUwMTgwO2JlXFx1MmRlYVxcdTM5Y2JcXHUzOWNmYXI7XFx1NjJiYnE7XFx1NjI1YWxpcDtcXHU2MmVlXFx1MDEwMGJ0XFx1MzlkY1xcdTE0NjhhXFx4ZjJcXHUxNDY5cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMzN0clxceGU5XFx1MzlhZXN1XFx1MDEwMGJwXFx1MzllZlxcdTM5ZjFcXHhiYlxcdTBkMWNcXHhiYlxcdTBkNTlwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNjdyb1xceGYwXFx1MGVmYnRyXFx4ZTlcXHUzOWI0XFx1MDEwMGN1XFx1M2EwNlxcdTNhMGJyO1xcdWMwMDBcXHVkODM1XFx1ZGNjYlxcdTAxMDBicFxcdTNhMTBcXHUzYTE4blxcdTAxMDBFZVxcdTM5ODBcXHUzYTE2XFx4YmJcXHUzOTdlblxcdTAxMDBFZVxcdTM5OTJcXHUzYTFlXFx4YmJcXHUzOTkwaWd6YWc7XFx1Njk5YVxcdTAzODBjZWZvcHJzXFx1M2EzNlxcdTNhM2JcXHUzYTU2XFx1M2E1YlxcdTNhNTRcXHUzYTYxXFx1M2E2YWlyYztcXHU0MTc1XFx1MDEwMGRpXFx1M2E0MFxcdTNhNTFcXHUwMTAwYmdcXHUzYTQ1XFx1M2E0OWFyO1xcdTZhNWZlXFx1MDEwMDtxXFx1MTVmYVxcdTNhNGY7XFx1NjI1OWVycDtcXHU2MTE4cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMzRwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNjhcXHUwMTAwO2VcXHUxNDc5XFx1M2E2NmF0XFx4ZThcXHUxNDc5Y3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2NjXFx1MGFlM1xcdTE3OGVcXHUzYTg3XFwwXFx1M2E4YlxcMFxcdTNhOTBcXHUzYTliXFwwXFwwXFx1M2E5ZFxcdTNhYThcXHUzYWFiXFx1M2FhZlxcMFxcMFxcdTNhYzNcXHUzYWNlXFwwXFx1M2FkOFxcdTE3ZGNcXHUxN2RmdHJcXHhlOVxcdTE3ZDFyO1xcdWMwMDBcXHVkODM1XFx1ZGQzNVxcdTAxMDBBYVxcdTNhOTRcXHUzYTk3clxceGYyXFx1MDNjM3JcXHhmMlxcdTA5ZjY7XFx1NDNiZVxcdTAxMDBBYVxcdTNhYTFcXHUzYWE0clxceGYyXFx1MDNiOHJcXHhmMlxcdTA5ZWJhXFx4ZjBcXHUyNzEzaXM7XFx1NjJmYlxcdTAxODBkcHRcXHUxN2E0XFx1M2FiNVxcdTNhYmVcXHUwMTAwZmxcXHUzYWJhXFx1MTdhOTtcXHVjMDAwXFx1ZDgzNVxcdWRkNjlpbVxceGU1XFx1MTdiMlxcdTAxMDBBYVxcdTNhYzdcXHUzYWNhclxceGYyXFx1MDNjZXJcXHhmMlxcdTBhMDFcXHUwMTAwY3FcXHUzYWQyXFx1MTdiOHI7XFx1YzAwMFxcdWQ4MzVcXHVkY2NkXFx1MDEwMHB0XFx1MTdkNlxcdTNhZGNyXFx4ZTlcXHUxN2Q0XFx1MDQwMGFjZWZpb3N1XFx1M2FmMFxcdTNhZmRcXHUzYjA4XFx1M2IwY1xcdTNiMTFcXHUzYjE1XFx1M2IxYlxcdTNiMjFjXFx1MDEwMHV5XFx1M2FmNlxcdTNhZmJ0ZVxcdTgwM2JcXHhmZFxcdTQwZmQ7XFx1NDQ0ZlxcdTAxMDBpeVxcdTNiMDJcXHUzYjA2cmM7XFx1NDE3NztcXHU0NDRiblxcdTgwM2JcXHhhNVxcdTQwYTVyO1xcdWMwMDBcXHVkODM1XFx1ZGQzNmN5O1xcdTQ0NTdwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNmFjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjY2VcXHUwMTAwY21cXHUzYjI2XFx1M2IyOXk7XFx1NDQ0ZWxcXHU4MDNiXFx4ZmZcXHU0MGZmXFx1MDUwMGFjZGVmaGlvc3dcXHUzYjQyXFx1M2I0OFxcdTNiNTRcXHUzYjU4XFx1M2I2NFxcdTNiNjlcXHUzYjZkXFx1M2I3NFxcdTNiN2FcXHUzYjgwY3V0ZTtcXHU0MTdhXFx1MDEwMGF5XFx1M2I0ZFxcdTNiNTJyb247XFx1NDE3ZTtcXHU0NDM3b3Q7XFx1NDE3Y1xcdTAxMDBldFxcdTNiNWRcXHUzYjYxdHJcXHhlNlxcdTE1NWZhO1xcdTQzYjZyO1xcdWMwMDBcXHVkODM1XFx1ZGQzN2N5O1xcdTQ0MzZncmFycjtcXHU2MWRkcGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDZiY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2NmXFx1MDEwMGpuXFx1M2I4NVxcdTNiODc7XFx1NjAwZGo7XFx1NjAwY1wiXG4gICAgLnNwbGl0KFwiXCIpXG4gICAgLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5jaGFyQ29kZUF0KDApOyB9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGUtZGF0YS1odG1sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gR2VuZXJhdGVkIHVzaW5nIHNjcmlwdHMvd3JpdGUtZGVjb2RlLW1hcC50c1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFVpbnQxNkFycmF5KFxuLy8gcHJldHRpZXItaWdub3JlXG5cIlxcdTAyMDBhZ2xxXFx0XFx4MTVcXHgxOFxceDFiXFx1MDI2ZFxceDBmXFwwXFwwXFx4MTJwO1xcdTQwMjZvcztcXHU0MDI3dDtcXHU0MDNldDtcXHU0MDNjdW90O1xcdTQwMjJcIlxuICAgIC5zcGxpdChcIlwiKVxuICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTsgfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLWRhdGEteG1sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gR2VuZXJhdGVkIHVzaW5nIHNjcmlwdHMvd3JpdGUtZW5jb2RlLW1hcC50c1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gcmVzdG9yZURpZmYoYXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldWzBdICs9IGFycltpIC0gMV1bMF0gKyAxO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgTWFwKC8qICNfX1BVUkVfXyAqLyByZXN0b3JlRGlmZihbWzksIFwiJlRhYjtcIl0sIFswLCBcIiZOZXdMaW5lO1wiXSwgWzIyLCBcIiZleGNsO1wiXSwgWzAsIFwiJnF1b3Q7XCJdLCBbMCwgXCImbnVtO1wiXSwgWzAsIFwiJmRvbGxhcjtcIl0sIFswLCBcIiZwZXJjbnQ7XCJdLCBbMCwgXCImYW1wO1wiXSwgWzAsIFwiJmFwb3M7XCJdLCBbMCwgXCImbHBhcjtcIl0sIFswLCBcIiZycGFyO1wiXSwgWzAsIFwiJmFzdDtcIl0sIFswLCBcIiZwbHVzO1wiXSwgWzAsIFwiJmNvbW1hO1wiXSwgWzEsIFwiJnBlcmlvZDtcIl0sIFswLCBcIiZzb2w7XCJdLCBbMTAsIFwiJmNvbG9uO1wiXSwgWzAsIFwiJnNlbWk7XCJdLCBbMCwgeyB2OiBcIiZsdDtcIiwgbjogODQwMiwgbzogXCImbnZsdDtcIiB9XSwgWzAsIHsgdjogXCImZXF1YWxzO1wiLCBuOiA4NDIxLCBvOiBcIiZibmU7XCIgfV0sIFswLCB7IHY6IFwiJmd0O1wiLCBuOiA4NDAyLCBvOiBcIiZudmd0O1wiIH1dLCBbMCwgXCImcXVlc3Q7XCJdLCBbMCwgXCImY29tbWF0O1wiXSwgWzI2LCBcIiZsYnJhY2s7XCJdLCBbMCwgXCImYnNvbDtcIl0sIFswLCBcIiZyYnJhY2s7XCJdLCBbMCwgXCImSGF0O1wiXSwgWzAsIFwiJmxvd2JhcjtcIl0sIFswLCBcIiZEaWFjcml0aWNhbEdyYXZlO1wiXSwgWzUsIHsgbjogMTA2LCBvOiBcIiZmamxpZztcIiB9XSwgWzIwLCBcIiZsYnJhY2U7XCJdLCBbMCwgXCImdmVyYmFyO1wiXSwgWzAsIFwiJnJicmFjZTtcIl0sIFszNCwgXCImbmJzcDtcIl0sIFswLCBcIiZpZXhjbDtcIl0sIFswLCBcIiZjZW50O1wiXSwgWzAsIFwiJnBvdW5kO1wiXSwgWzAsIFwiJmN1cnJlbjtcIl0sIFswLCBcIiZ5ZW47XCJdLCBbMCwgXCImYnJ2YmFyO1wiXSwgWzAsIFwiJnNlY3Q7XCJdLCBbMCwgXCImZGllO1wiXSwgWzAsIFwiJmNvcHk7XCJdLCBbMCwgXCImb3JkZjtcIl0sIFswLCBcIiZsYXF1bztcIl0sIFswLCBcIiZub3Q7XCJdLCBbMCwgXCImc2h5O1wiXSwgWzAsIFwiJmNpcmNsZWRSO1wiXSwgWzAsIFwiJm1hY3I7XCJdLCBbMCwgXCImZGVnO1wiXSwgWzAsIFwiJlBsdXNNaW51cztcIl0sIFswLCBcIiZzdXAyO1wiXSwgWzAsIFwiJnN1cDM7XCJdLCBbMCwgXCImYWN1dGU7XCJdLCBbMCwgXCImbWljcm87XCJdLCBbMCwgXCImcGFyYTtcIl0sIFswLCBcIiZjZW50ZXJkb3Q7XCJdLCBbMCwgXCImY2VkaWw7XCJdLCBbMCwgXCImc3VwMTtcIl0sIFswLCBcIiZvcmRtO1wiXSwgWzAsIFwiJnJhcXVvO1wiXSwgWzAsIFwiJmZyYWMxNDtcIl0sIFswLCBcIiZmcmFjMTI7XCJdLCBbMCwgXCImZnJhYzM0O1wiXSwgWzAsIFwiJmlxdWVzdDtcIl0sIFswLCBcIiZBZ3JhdmU7XCJdLCBbMCwgXCImQWFjdXRlO1wiXSwgWzAsIFwiJkFjaXJjO1wiXSwgWzAsIFwiJkF0aWxkZTtcIl0sIFswLCBcIiZBdW1sO1wiXSwgWzAsIFwiJmFuZ3N0O1wiXSwgWzAsIFwiJkFFbGlnO1wiXSwgWzAsIFwiJkNjZWRpbDtcIl0sIFswLCBcIiZFZ3JhdmU7XCJdLCBbMCwgXCImRWFjdXRlO1wiXSwgWzAsIFwiJkVjaXJjO1wiXSwgWzAsIFwiJkV1bWw7XCJdLCBbMCwgXCImSWdyYXZlO1wiXSwgWzAsIFwiJklhY3V0ZTtcIl0sIFswLCBcIiZJY2lyYztcIl0sIFswLCBcIiZJdW1sO1wiXSwgWzAsIFwiJkVUSDtcIl0sIFswLCBcIiZOdGlsZGU7XCJdLCBbMCwgXCImT2dyYXZlO1wiXSwgWzAsIFwiJk9hY3V0ZTtcIl0sIFswLCBcIiZPY2lyYztcIl0sIFswLCBcIiZPdGlsZGU7XCJdLCBbMCwgXCImT3VtbDtcIl0sIFswLCBcIiZ0aW1lcztcIl0sIFswLCBcIiZPc2xhc2g7XCJdLCBbMCwgXCImVWdyYXZlO1wiXSwgWzAsIFwiJlVhY3V0ZTtcIl0sIFswLCBcIiZVY2lyYztcIl0sIFswLCBcIiZVdW1sO1wiXSwgWzAsIFwiJllhY3V0ZTtcIl0sIFswLCBcIiZUSE9STjtcIl0sIFswLCBcIiZzemxpZztcIl0sIFswLCBcIiZhZ3JhdmU7XCJdLCBbMCwgXCImYWFjdXRlO1wiXSwgWzAsIFwiJmFjaXJjO1wiXSwgWzAsIFwiJmF0aWxkZTtcIl0sIFswLCBcIiZhdW1sO1wiXSwgWzAsIFwiJmFyaW5nO1wiXSwgWzAsIFwiJmFlbGlnO1wiXSwgWzAsIFwiJmNjZWRpbDtcIl0sIFswLCBcIiZlZ3JhdmU7XCJdLCBbMCwgXCImZWFjdXRlO1wiXSwgWzAsIFwiJmVjaXJjO1wiXSwgWzAsIFwiJmV1bWw7XCJdLCBbMCwgXCImaWdyYXZlO1wiXSwgWzAsIFwiJmlhY3V0ZTtcIl0sIFswLCBcIiZpY2lyYztcIl0sIFswLCBcIiZpdW1sO1wiXSwgWzAsIFwiJmV0aDtcIl0sIFswLCBcIiZudGlsZGU7XCJdLCBbMCwgXCImb2dyYXZlO1wiXSwgWzAsIFwiJm9hY3V0ZTtcIl0sIFswLCBcIiZvY2lyYztcIl0sIFswLCBcIiZvdGlsZGU7XCJdLCBbMCwgXCImb3VtbDtcIl0sIFswLCBcIiZkaXY7XCJdLCBbMCwgXCImb3NsYXNoO1wiXSwgWzAsIFwiJnVncmF2ZTtcIl0sIFswLCBcIiZ1YWN1dGU7XCJdLCBbMCwgXCImdWNpcmM7XCJdLCBbMCwgXCImdXVtbDtcIl0sIFswLCBcIiZ5YWN1dGU7XCJdLCBbMCwgXCImdGhvcm47XCJdLCBbMCwgXCImeXVtbDtcIl0sIFswLCBcIiZBbWFjcjtcIl0sIFswLCBcIiZhbWFjcjtcIl0sIFswLCBcIiZBYnJldmU7XCJdLCBbMCwgXCImYWJyZXZlO1wiXSwgWzAsIFwiJkFvZ29uO1wiXSwgWzAsIFwiJmFvZ29uO1wiXSwgWzAsIFwiJkNhY3V0ZTtcIl0sIFswLCBcIiZjYWN1dGU7XCJdLCBbMCwgXCImQ2NpcmM7XCJdLCBbMCwgXCImY2NpcmM7XCJdLCBbMCwgXCImQ2RvdDtcIl0sIFswLCBcIiZjZG90O1wiXSwgWzAsIFwiJkNjYXJvbjtcIl0sIFswLCBcIiZjY2Fyb247XCJdLCBbMCwgXCImRGNhcm9uO1wiXSwgWzAsIFwiJmRjYXJvbjtcIl0sIFswLCBcIiZEc3Ryb2s7XCJdLCBbMCwgXCImZHN0cm9rO1wiXSwgWzAsIFwiJkVtYWNyO1wiXSwgWzAsIFwiJmVtYWNyO1wiXSwgWzIsIFwiJkVkb3Q7XCJdLCBbMCwgXCImZWRvdDtcIl0sIFswLCBcIiZFb2dvbjtcIl0sIFswLCBcIiZlb2dvbjtcIl0sIFswLCBcIiZFY2Fyb247XCJdLCBbMCwgXCImZWNhcm9uO1wiXSwgWzAsIFwiJkdjaXJjO1wiXSwgWzAsIFwiJmdjaXJjO1wiXSwgWzAsIFwiJkdicmV2ZTtcIl0sIFswLCBcIiZnYnJldmU7XCJdLCBbMCwgXCImR2RvdDtcIl0sIFswLCBcIiZnZG90O1wiXSwgWzAsIFwiJkdjZWRpbDtcIl0sIFsxLCBcIiZIY2lyYztcIl0sIFswLCBcIiZoY2lyYztcIl0sIFswLCBcIiZIc3Ryb2s7XCJdLCBbMCwgXCImaHN0cm9rO1wiXSwgWzAsIFwiJkl0aWxkZTtcIl0sIFswLCBcIiZpdGlsZGU7XCJdLCBbMCwgXCImSW1hY3I7XCJdLCBbMCwgXCImaW1hY3I7XCJdLCBbMiwgXCImSW9nb247XCJdLCBbMCwgXCImaW9nb247XCJdLCBbMCwgXCImSWRvdDtcIl0sIFswLCBcIiZpbWF0aDtcIl0sIFswLCBcIiZJSmxpZztcIl0sIFswLCBcIiZpamxpZztcIl0sIFswLCBcIiZKY2lyYztcIl0sIFswLCBcIiZqY2lyYztcIl0sIFswLCBcIiZLY2VkaWw7XCJdLCBbMCwgXCIma2NlZGlsO1wiXSwgWzAsIFwiJmtncmVlbjtcIl0sIFswLCBcIiZMYWN1dGU7XCJdLCBbMCwgXCImbGFjdXRlO1wiXSwgWzAsIFwiJkxjZWRpbDtcIl0sIFswLCBcIiZsY2VkaWw7XCJdLCBbMCwgXCImTGNhcm9uO1wiXSwgWzAsIFwiJmxjYXJvbjtcIl0sIFswLCBcIiZMbWlkb3Q7XCJdLCBbMCwgXCImbG1pZG90O1wiXSwgWzAsIFwiJkxzdHJvaztcIl0sIFswLCBcIiZsc3Ryb2s7XCJdLCBbMCwgXCImTmFjdXRlO1wiXSwgWzAsIFwiJm5hY3V0ZTtcIl0sIFswLCBcIiZOY2VkaWw7XCJdLCBbMCwgXCImbmNlZGlsO1wiXSwgWzAsIFwiJk5jYXJvbjtcIl0sIFswLCBcIiZuY2Fyb247XCJdLCBbMCwgXCImbmFwb3M7XCJdLCBbMCwgXCImRU5HO1wiXSwgWzAsIFwiJmVuZztcIl0sIFswLCBcIiZPbWFjcjtcIl0sIFswLCBcIiZvbWFjcjtcIl0sIFsyLCBcIiZPZGJsYWM7XCJdLCBbMCwgXCImb2RibGFjO1wiXSwgWzAsIFwiJk9FbGlnO1wiXSwgWzAsIFwiJm9lbGlnO1wiXSwgWzAsIFwiJlJhY3V0ZTtcIl0sIFswLCBcIiZyYWN1dGU7XCJdLCBbMCwgXCImUmNlZGlsO1wiXSwgWzAsIFwiJnJjZWRpbDtcIl0sIFswLCBcIiZSY2Fyb247XCJdLCBbMCwgXCImcmNhcm9uO1wiXSwgWzAsIFwiJlNhY3V0ZTtcIl0sIFswLCBcIiZzYWN1dGU7XCJdLCBbMCwgXCImU2NpcmM7XCJdLCBbMCwgXCImc2NpcmM7XCJdLCBbMCwgXCImU2NlZGlsO1wiXSwgWzAsIFwiJnNjZWRpbDtcIl0sIFswLCBcIiZTY2Fyb247XCJdLCBbMCwgXCImc2Nhcm9uO1wiXSwgWzAsIFwiJlRjZWRpbDtcIl0sIFswLCBcIiZ0Y2VkaWw7XCJdLCBbMCwgXCImVGNhcm9uO1wiXSwgWzAsIFwiJnRjYXJvbjtcIl0sIFswLCBcIiZUc3Ryb2s7XCJdLCBbMCwgXCImdHN0cm9rO1wiXSwgWzAsIFwiJlV0aWxkZTtcIl0sIFswLCBcIiZ1dGlsZGU7XCJdLCBbMCwgXCImVW1hY3I7XCJdLCBbMCwgXCImdW1hY3I7XCJdLCBbMCwgXCImVWJyZXZlO1wiXSwgWzAsIFwiJnVicmV2ZTtcIl0sIFswLCBcIiZVcmluZztcIl0sIFswLCBcIiZ1cmluZztcIl0sIFswLCBcIiZVZGJsYWM7XCJdLCBbMCwgXCImdWRibGFjO1wiXSwgWzAsIFwiJlVvZ29uO1wiXSwgWzAsIFwiJnVvZ29uO1wiXSwgWzAsIFwiJldjaXJjO1wiXSwgWzAsIFwiJndjaXJjO1wiXSwgWzAsIFwiJlljaXJjO1wiXSwgWzAsIFwiJnljaXJjO1wiXSwgWzAsIFwiJll1bWw7XCJdLCBbMCwgXCImWmFjdXRlO1wiXSwgWzAsIFwiJnphY3V0ZTtcIl0sIFswLCBcIiZaZG90O1wiXSwgWzAsIFwiJnpkb3Q7XCJdLCBbMCwgXCImWmNhcm9uO1wiXSwgWzAsIFwiJnpjYXJvbjtcIl0sIFsxOSwgXCImZm5vZjtcIl0sIFszNCwgXCImaW1wZWQ7XCJdLCBbNjMsIFwiJmdhY3V0ZTtcIl0sIFs2NSwgXCImam1hdGg7XCJdLCBbMTQyLCBcIiZjaXJjO1wiXSwgWzAsIFwiJmNhcm9uO1wiXSwgWzE2LCBcIiZicmV2ZTtcIl0sIFswLCBcIiZEaWFjcml0aWNhbERvdDtcIl0sIFswLCBcIiZyaW5nO1wiXSwgWzAsIFwiJm9nb247XCJdLCBbMCwgXCImRGlhY3JpdGljYWxUaWxkZTtcIl0sIFswLCBcIiZkYmxhYztcIl0sIFs1MSwgXCImRG93bkJyZXZlO1wiXSwgWzEyNywgXCImQWxwaGE7XCJdLCBbMCwgXCImQmV0YTtcIl0sIFswLCBcIiZHYW1tYTtcIl0sIFswLCBcIiZEZWx0YTtcIl0sIFswLCBcIiZFcHNpbG9uO1wiXSwgWzAsIFwiJlpldGE7XCJdLCBbMCwgXCImRXRhO1wiXSwgWzAsIFwiJlRoZXRhO1wiXSwgWzAsIFwiJklvdGE7XCJdLCBbMCwgXCImS2FwcGE7XCJdLCBbMCwgXCImTGFtYmRhO1wiXSwgWzAsIFwiJk11O1wiXSwgWzAsIFwiJk51O1wiXSwgWzAsIFwiJlhpO1wiXSwgWzAsIFwiJk9taWNyb247XCJdLCBbMCwgXCImUGk7XCJdLCBbMCwgXCImUmhvO1wiXSwgWzEsIFwiJlNpZ21hO1wiXSwgWzAsIFwiJlRhdTtcIl0sIFswLCBcIiZVcHNpbG9uO1wiXSwgWzAsIFwiJlBoaTtcIl0sIFswLCBcIiZDaGk7XCJdLCBbMCwgXCImUHNpO1wiXSwgWzAsIFwiJm9obTtcIl0sIFs3LCBcIiZhbHBoYTtcIl0sIFswLCBcIiZiZXRhO1wiXSwgWzAsIFwiJmdhbW1hO1wiXSwgWzAsIFwiJmRlbHRhO1wiXSwgWzAsIFwiJmVwc2k7XCJdLCBbMCwgXCImemV0YTtcIl0sIFswLCBcIiZldGE7XCJdLCBbMCwgXCImdGhldGE7XCJdLCBbMCwgXCImaW90YTtcIl0sIFswLCBcIiZrYXBwYTtcIl0sIFswLCBcIiZsYW1iZGE7XCJdLCBbMCwgXCImbXU7XCJdLCBbMCwgXCImbnU7XCJdLCBbMCwgXCImeGk7XCJdLCBbMCwgXCImb21pY3JvbjtcIl0sIFswLCBcIiZwaTtcIl0sIFswLCBcIiZyaG87XCJdLCBbMCwgXCImc2lnbWFmO1wiXSwgWzAsIFwiJnNpZ21hO1wiXSwgWzAsIFwiJnRhdTtcIl0sIFswLCBcIiZ1cHNpO1wiXSwgWzAsIFwiJnBoaTtcIl0sIFswLCBcIiZjaGk7XCJdLCBbMCwgXCImcHNpO1wiXSwgWzAsIFwiJm9tZWdhO1wiXSwgWzcsIFwiJnRoZXRhc3ltO1wiXSwgWzAsIFwiJlVwc2k7XCJdLCBbMiwgXCImcGhpdjtcIl0sIFswLCBcIiZwaXY7XCJdLCBbNSwgXCImR2FtbWFkO1wiXSwgWzAsIFwiJmRpZ2FtbWE7XCJdLCBbMTgsIFwiJmthcHBhdjtcIl0sIFswLCBcIiZyaG92O1wiXSwgWzMsIFwiJmVwc2l2O1wiXSwgWzAsIFwiJmJhY2tlcHNpbG9uO1wiXSwgWzEwLCBcIiZJT2N5O1wiXSwgWzAsIFwiJkRKY3k7XCJdLCBbMCwgXCImR0pjeTtcIl0sIFswLCBcIiZKdWtjeTtcIl0sIFswLCBcIiZEU2N5O1wiXSwgWzAsIFwiJkl1a2N5O1wiXSwgWzAsIFwiJllJY3k7XCJdLCBbMCwgXCImSnNlcmN5O1wiXSwgWzAsIFwiJkxKY3k7XCJdLCBbMCwgXCImTkpjeTtcIl0sIFswLCBcIiZUU0hjeTtcIl0sIFswLCBcIiZLSmN5O1wiXSwgWzEsIFwiJlVicmN5O1wiXSwgWzAsIFwiJkRaY3k7XCJdLCBbMCwgXCImQWN5O1wiXSwgWzAsIFwiJkJjeTtcIl0sIFswLCBcIiZWY3k7XCJdLCBbMCwgXCImR2N5O1wiXSwgWzAsIFwiJkRjeTtcIl0sIFswLCBcIiZJRWN5O1wiXSwgWzAsIFwiJlpIY3k7XCJdLCBbMCwgXCImWmN5O1wiXSwgWzAsIFwiJkljeTtcIl0sIFswLCBcIiZKY3k7XCJdLCBbMCwgXCImS2N5O1wiXSwgWzAsIFwiJkxjeTtcIl0sIFswLCBcIiZNY3k7XCJdLCBbMCwgXCImTmN5O1wiXSwgWzAsIFwiJk9jeTtcIl0sIFswLCBcIiZQY3k7XCJdLCBbMCwgXCImUmN5O1wiXSwgWzAsIFwiJlNjeTtcIl0sIFswLCBcIiZUY3k7XCJdLCBbMCwgXCImVWN5O1wiXSwgWzAsIFwiJkZjeTtcIl0sIFswLCBcIiZLSGN5O1wiXSwgWzAsIFwiJlRTY3k7XCJdLCBbMCwgXCImQ0hjeTtcIl0sIFswLCBcIiZTSGN5O1wiXSwgWzAsIFwiJlNIQ0hjeTtcIl0sIFswLCBcIiZIQVJEY3k7XCJdLCBbMCwgXCImWWN5O1wiXSwgWzAsIFwiJlNPRlRjeTtcIl0sIFswLCBcIiZFY3k7XCJdLCBbMCwgXCImWVVjeTtcIl0sIFswLCBcIiZZQWN5O1wiXSwgWzAsIFwiJmFjeTtcIl0sIFswLCBcIiZiY3k7XCJdLCBbMCwgXCImdmN5O1wiXSwgWzAsIFwiJmdjeTtcIl0sIFswLCBcIiZkY3k7XCJdLCBbMCwgXCImaWVjeTtcIl0sIFswLCBcIiZ6aGN5O1wiXSwgWzAsIFwiJnpjeTtcIl0sIFswLCBcIiZpY3k7XCJdLCBbMCwgXCImamN5O1wiXSwgWzAsIFwiJmtjeTtcIl0sIFswLCBcIiZsY3k7XCJdLCBbMCwgXCImbWN5O1wiXSwgWzAsIFwiJm5jeTtcIl0sIFswLCBcIiZvY3k7XCJdLCBbMCwgXCImcGN5O1wiXSwgWzAsIFwiJnJjeTtcIl0sIFswLCBcIiZzY3k7XCJdLCBbMCwgXCImdGN5O1wiXSwgWzAsIFwiJnVjeTtcIl0sIFswLCBcIiZmY3k7XCJdLCBbMCwgXCIma2hjeTtcIl0sIFswLCBcIiZ0c2N5O1wiXSwgWzAsIFwiJmNoY3k7XCJdLCBbMCwgXCImc2hjeTtcIl0sIFswLCBcIiZzaGNoY3k7XCJdLCBbMCwgXCImaGFyZGN5O1wiXSwgWzAsIFwiJnljeTtcIl0sIFswLCBcIiZzb2Z0Y3k7XCJdLCBbMCwgXCImZWN5O1wiXSwgWzAsIFwiJnl1Y3k7XCJdLCBbMCwgXCImeWFjeTtcIl0sIFsxLCBcIiZpb2N5O1wiXSwgWzAsIFwiJmRqY3k7XCJdLCBbMCwgXCImZ2pjeTtcIl0sIFswLCBcIiZqdWtjeTtcIl0sIFswLCBcIiZkc2N5O1wiXSwgWzAsIFwiJml1a2N5O1wiXSwgWzAsIFwiJnlpY3k7XCJdLCBbMCwgXCImanNlcmN5O1wiXSwgWzAsIFwiJmxqY3k7XCJdLCBbMCwgXCImbmpjeTtcIl0sIFswLCBcIiZ0c2hjeTtcIl0sIFswLCBcIiZramN5O1wiXSwgWzEsIFwiJnVicmN5O1wiXSwgWzAsIFwiJmR6Y3k7XCJdLCBbNzA3NCwgXCImZW5zcDtcIl0sIFswLCBcIiZlbXNwO1wiXSwgWzAsIFwiJmVtc3AxMztcIl0sIFswLCBcIiZlbXNwMTQ7XCJdLCBbMSwgXCImbnVtc3A7XCJdLCBbMCwgXCImcHVuY3NwO1wiXSwgWzAsIFwiJlRoaW5TcGFjZTtcIl0sIFswLCBcIiZoYWlyc3A7XCJdLCBbMCwgXCImTmVnYXRpdmVNZWRpdW1TcGFjZTtcIl0sIFswLCBcIiZ6d25qO1wiXSwgWzAsIFwiJnp3ajtcIl0sIFswLCBcIiZscm07XCJdLCBbMCwgXCImcmxtO1wiXSwgWzAsIFwiJmRhc2g7XCJdLCBbMiwgXCImbmRhc2g7XCJdLCBbMCwgXCImbWRhc2g7XCJdLCBbMCwgXCImaG9yYmFyO1wiXSwgWzAsIFwiJlZlcmJhcjtcIl0sIFsxLCBcIiZsc3F1bztcIl0sIFswLCBcIiZDbG9zZUN1cmx5UXVvdGU7XCJdLCBbMCwgXCImbHNxdW9yO1wiXSwgWzEsIFwiJmxkcXVvO1wiXSwgWzAsIFwiJkNsb3NlQ3VybHlEb3VibGVRdW90ZTtcIl0sIFswLCBcIiZiZHF1bztcIl0sIFsxLCBcIiZkYWdnZXI7XCJdLCBbMCwgXCImRGFnZ2VyO1wiXSwgWzAsIFwiJmJ1bGw7XCJdLCBbMiwgXCImbmxkcjtcIl0sIFswLCBcIiZoZWxsaXA7XCJdLCBbOSwgXCImcGVybWlsO1wiXSwgWzAsIFwiJnBlcnRlbms7XCJdLCBbMCwgXCImcHJpbWU7XCJdLCBbMCwgXCImUHJpbWU7XCJdLCBbMCwgXCImdHByaW1lO1wiXSwgWzAsIFwiJmJhY2twcmltZTtcIl0sIFszLCBcIiZsc2FxdW87XCJdLCBbMCwgXCImcnNhcXVvO1wiXSwgWzMsIFwiJm9saW5lO1wiXSwgWzIsIFwiJmNhcmV0O1wiXSwgWzEsIFwiJmh5YnVsbDtcIl0sIFswLCBcIiZmcmFzbDtcIl0sIFsxMCwgXCImYnNlbWk7XCJdLCBbNywgXCImcXByaW1lO1wiXSwgWzcsIHsgdjogXCImTWVkaXVtU3BhY2U7XCIsIG46IDgyMDIsIG86IFwiJlRoaWNrU3BhY2U7XCIgfV0sIFswLCBcIiZOb0JyZWFrO1wiXSwgWzAsIFwiJmFmO1wiXSwgWzAsIFwiJkludmlzaWJsZVRpbWVzO1wiXSwgWzAsIFwiJmljO1wiXSwgWzcyLCBcIiZldXJvO1wiXSwgWzQ2LCBcIiZ0ZG90O1wiXSwgWzAsIFwiJkRvdERvdDtcIl0sIFszNywgXCImY29tcGxleGVzO1wiXSwgWzIsIFwiJmluY2FyZTtcIl0sIFs0LCBcIiZnc2NyO1wiXSwgWzAsIFwiJmhhbWlsdDtcIl0sIFswLCBcIiZIZnI7XCJdLCBbMCwgXCImSG9wZjtcIl0sIFswLCBcIiZwbGFuY2toO1wiXSwgWzAsIFwiJmhiYXI7XCJdLCBbMCwgXCImaW1hZ2xpbmU7XCJdLCBbMCwgXCImSWZyO1wiXSwgWzAsIFwiJmxhZ3JhbjtcIl0sIFswLCBcIiZlbGw7XCJdLCBbMSwgXCImbmF0dXJhbHM7XCJdLCBbMCwgXCImbnVtZXJvO1wiXSwgWzAsIFwiJmNvcHlzcjtcIl0sIFswLCBcIiZ3ZWllcnA7XCJdLCBbMCwgXCImUG9wZjtcIl0sIFswLCBcIiZRb3BmO1wiXSwgWzAsIFwiJnJlYWxpbmU7XCJdLCBbMCwgXCImcmVhbDtcIl0sIFswLCBcIiZyZWFscztcIl0sIFswLCBcIiZyeDtcIl0sIFszLCBcIiZ0cmFkZTtcIl0sIFsxLCBcIiZpbnRlZ2VycztcIl0sIFsyLCBcIiZtaG87XCJdLCBbMCwgXCImemVldHJmO1wiXSwgWzAsIFwiJmlpb3RhO1wiXSwgWzIsIFwiJmJlcm5vdTtcIl0sIFswLCBcIiZDYXlsZXlzO1wiXSwgWzEsIFwiJmVzY3I7XCJdLCBbMCwgXCImRXNjcjtcIl0sIFswLCBcIiZGb3VyaWVydHJmO1wiXSwgWzEsIFwiJk1lbGxpbnRyZjtcIl0sIFswLCBcIiZvcmRlcjtcIl0sIFswLCBcIiZhbGVmc3ltO1wiXSwgWzAsIFwiJmJldGg7XCJdLCBbMCwgXCImZ2ltZWw7XCJdLCBbMCwgXCImZGFsZXRoO1wiXSwgWzEyLCBcIiZDYXBpdGFsRGlmZmVyZW50aWFsRDtcIl0sIFswLCBcIiZkZDtcIl0sIFswLCBcIiZlZTtcIl0sIFswLCBcIiZpaTtcIl0sIFsxMCwgXCImZnJhYzEzO1wiXSwgWzAsIFwiJmZyYWMyMztcIl0sIFswLCBcIiZmcmFjMTU7XCJdLCBbMCwgXCImZnJhYzI1O1wiXSwgWzAsIFwiJmZyYWMzNTtcIl0sIFswLCBcIiZmcmFjNDU7XCJdLCBbMCwgXCImZnJhYzE2O1wiXSwgWzAsIFwiJmZyYWM1NjtcIl0sIFswLCBcIiZmcmFjMTg7XCJdLCBbMCwgXCImZnJhYzM4O1wiXSwgWzAsIFwiJmZyYWM1ODtcIl0sIFswLCBcIiZmcmFjNzg7XCJdLCBbNDksIFwiJmxhcnI7XCJdLCBbMCwgXCImU2hvcnRVcEFycm93O1wiXSwgWzAsIFwiJnJhcnI7XCJdLCBbMCwgXCImZGFycjtcIl0sIFswLCBcIiZoYXJyO1wiXSwgWzAsIFwiJnVwZG93bmFycm93O1wiXSwgWzAsIFwiJm53YXJyO1wiXSwgWzAsIFwiJm5lYXJyO1wiXSwgWzAsIFwiJkxvd2VyUmlnaHRBcnJvdztcIl0sIFswLCBcIiZMb3dlckxlZnRBcnJvdztcIl0sIFswLCBcIiZubGFycjtcIl0sIFswLCBcIiZucmFycjtcIl0sIFsxLCB7IHY6IFwiJnJhcnJ3O1wiLCBuOiA4MjQsIG86IFwiJm5yYXJydztcIiB9XSwgWzAsIFwiJkxhcnI7XCJdLCBbMCwgXCImVWFycjtcIl0sIFswLCBcIiZSYXJyO1wiXSwgWzAsIFwiJkRhcnI7XCJdLCBbMCwgXCImbGFycnRsO1wiXSwgWzAsIFwiJnJhcnJ0bDtcIl0sIFswLCBcIiZMZWZ0VGVlQXJyb3c7XCJdLCBbMCwgXCImbWFwc3RvdXA7XCJdLCBbMCwgXCImbWFwO1wiXSwgWzAsIFwiJkRvd25UZWVBcnJvdztcIl0sIFsxLCBcIiZob29rbGVmdGFycm93O1wiXSwgWzAsIFwiJmhvb2tyaWdodGFycm93O1wiXSwgWzAsIFwiJmxhcnJscDtcIl0sIFswLCBcIiZsb29wYXJyb3dyaWdodDtcIl0sIFswLCBcIiZoYXJydztcIl0sIFswLCBcIiZuaGFycjtcIl0sIFsxLCBcIiZsc2g7XCJdLCBbMCwgXCImcnNoO1wiXSwgWzAsIFwiJmxkc2g7XCJdLCBbMCwgXCImcmRzaDtcIl0sIFsxLCBcIiZjcmFycjtcIl0sIFswLCBcIiZjdWxhcnI7XCJdLCBbMCwgXCImY3VyYXJyO1wiXSwgWzIsIFwiJmNpcmNsZWFycm93bGVmdDtcIl0sIFswLCBcIiZjaXJjbGVhcnJvd3JpZ2h0O1wiXSwgWzAsIFwiJmxlZnRoYXJwb29udXA7XCJdLCBbMCwgXCImRG93bkxlZnRWZWN0b3I7XCJdLCBbMCwgXCImUmlnaHRVcFZlY3RvcjtcIl0sIFswLCBcIiZMZWZ0VXBWZWN0b3I7XCJdLCBbMCwgXCImcmhhcnU7XCJdLCBbMCwgXCImRG93blJpZ2h0VmVjdG9yO1wiXSwgWzAsIFwiJmRoYXJyO1wiXSwgWzAsIFwiJmRoYXJsO1wiXSwgWzAsIFwiJlJpZ2h0QXJyb3dMZWZ0QXJyb3c7XCJdLCBbMCwgXCImdWRhcnI7XCJdLCBbMCwgXCImTGVmdEFycm93UmlnaHRBcnJvdztcIl0sIFswLCBcIiZsZWZ0bGVmdGFycm93cztcIl0sIFswLCBcIiZ1cHVwYXJyb3dzO1wiXSwgWzAsIFwiJnJpZ2h0cmlnaHRhcnJvd3M7XCJdLCBbMCwgXCImZGRhcnI7XCJdLCBbMCwgXCImbGVmdHJpZ2h0aGFycG9vbnM7XCJdLCBbMCwgXCImRXF1aWxpYnJpdW07XCJdLCBbMCwgXCImbmxBcnI7XCJdLCBbMCwgXCImbmhBcnI7XCJdLCBbMCwgXCImbnJBcnI7XCJdLCBbMCwgXCImRG91YmxlTGVmdEFycm93O1wiXSwgWzAsIFwiJkRvdWJsZVVwQXJyb3c7XCJdLCBbMCwgXCImRG91YmxlUmlnaHRBcnJvdztcIl0sIFswLCBcIiZkQXJyO1wiXSwgWzAsIFwiJkRvdWJsZUxlZnRSaWdodEFycm93O1wiXSwgWzAsIFwiJkRvdWJsZVVwRG93bkFycm93O1wiXSwgWzAsIFwiJm53QXJyO1wiXSwgWzAsIFwiJm5lQXJyO1wiXSwgWzAsIFwiJnNlQXJyO1wiXSwgWzAsIFwiJnN3QXJyO1wiXSwgWzAsIFwiJmxBYXJyO1wiXSwgWzAsIFwiJnJBYXJyO1wiXSwgWzEsIFwiJnppZ3JhcnI7XCJdLCBbNiwgXCImbGFycmI7XCJdLCBbMCwgXCImcmFycmI7XCJdLCBbMTUsIFwiJkRvd25BcnJvd1VwQXJyb3c7XCJdLCBbNywgXCImbG9hcnI7XCJdLCBbMCwgXCImcm9hcnI7XCJdLCBbMCwgXCImaG9hcnI7XCJdLCBbMCwgXCImZm9yYWxsO1wiXSwgWzAsIFwiJmNvbXA7XCJdLCBbMCwgeyB2OiBcIiZwYXJ0O1wiLCBuOiA4MjQsIG86IFwiJm5wYXJ0O1wiIH1dLCBbMCwgXCImZXhpc3Q7XCJdLCBbMCwgXCImbmV4aXN0O1wiXSwgWzAsIFwiJmVtcHR5O1wiXSwgWzEsIFwiJkRlbDtcIl0sIFswLCBcIiZFbGVtZW50O1wiXSwgWzAsIFwiJk5vdEVsZW1lbnQ7XCJdLCBbMSwgXCImbmk7XCJdLCBbMCwgXCImbm90bmk7XCJdLCBbMiwgXCImcHJvZDtcIl0sIFswLCBcIiZjb3Byb2Q7XCJdLCBbMCwgXCImc3VtO1wiXSwgWzAsIFwiJm1pbnVzO1wiXSwgWzAsIFwiJk1pbnVzUGx1cztcIl0sIFswLCBcIiZkb3RwbHVzO1wiXSwgWzEsIFwiJkJhY2tzbGFzaDtcIl0sIFswLCBcIiZsb3dhc3Q7XCJdLCBbMCwgXCImY29tcGZuO1wiXSwgWzEsIFwiJnJhZGljO1wiXSwgWzIsIFwiJnByb3A7XCJdLCBbMCwgXCImaW5maW47XCJdLCBbMCwgXCImYW5ncnQ7XCJdLCBbMCwgeyB2OiBcIiZhbmc7XCIsIG46IDg0MDIsIG86IFwiJm5hbmc7XCIgfV0sIFswLCBcIiZhbmdtc2Q7XCJdLCBbMCwgXCImYW5nc3BoO1wiXSwgWzAsIFwiJm1pZDtcIl0sIFswLCBcIiZubWlkO1wiXSwgWzAsIFwiJkRvdWJsZVZlcnRpY2FsQmFyO1wiXSwgWzAsIFwiJk5vdERvdWJsZVZlcnRpY2FsQmFyO1wiXSwgWzAsIFwiJmFuZDtcIl0sIFswLCBcIiZvcjtcIl0sIFswLCB7IHY6IFwiJmNhcDtcIiwgbjogNjUwMjQsIG86IFwiJmNhcHM7XCIgfV0sIFswLCB7IHY6IFwiJmN1cDtcIiwgbjogNjUwMjQsIG86IFwiJmN1cHM7XCIgfV0sIFswLCBcIiZpbnQ7XCJdLCBbMCwgXCImSW50O1wiXSwgWzAsIFwiJmlpaW50O1wiXSwgWzAsIFwiJmNvbmludDtcIl0sIFswLCBcIiZDb25pbnQ7XCJdLCBbMCwgXCImQ2NvbmludDtcIl0sIFswLCBcIiZjd2ludDtcIl0sIFswLCBcIiZDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7XCJdLCBbMCwgXCImYXdjb25pbnQ7XCJdLCBbMCwgXCImdGhlcmU0O1wiXSwgWzAsIFwiJmJlY2F1cztcIl0sIFswLCBcIiZyYXRpbztcIl0sIFswLCBcIiZDb2xvbjtcIl0sIFswLCBcIiZkb3RtaW51cztcIl0sIFsxLCBcIiZtRERvdDtcIl0sIFswLCBcIiZob210aHQ7XCJdLCBbMCwgeyB2OiBcIiZzaW07XCIsIG46IDg0MDIsIG86IFwiJm52c2ltO1wiIH1dLCBbMCwgeyB2OiBcIiZiYWNrc2ltO1wiLCBuOiA4MTcsIG86IFwiJnJhY2U7XCIgfV0sIFswLCB7IHY6IFwiJmFjO1wiLCBuOiA4MTksIG86IFwiJmFjRTtcIiB9XSwgWzAsIFwiJmFjZDtcIl0sIFswLCBcIiZWZXJ0aWNhbFRpbGRlO1wiXSwgWzAsIFwiJk5vdFRpbGRlO1wiXSwgWzAsIHsgdjogXCImZXFzaW07XCIsIG46IDgyNCwgbzogXCImbmVzaW07XCIgfV0sIFswLCBcIiZzaW1lO1wiXSwgWzAsIFwiJk5vdFRpbGRlRXF1YWw7XCJdLCBbMCwgXCImY29uZztcIl0sIFswLCBcIiZzaW1uZTtcIl0sIFswLCBcIiZuY29uZztcIl0sIFswLCBcIiZhcDtcIl0sIFswLCBcIiZuYXA7XCJdLCBbMCwgXCImYXBlO1wiXSwgWzAsIHsgdjogXCImYXBpZDtcIiwgbjogODI0LCBvOiBcIiZuYXBpZDtcIiB9XSwgWzAsIFwiJmJhY2tjb25nO1wiXSwgWzAsIHsgdjogXCImYXN5bXBlcTtcIiwgbjogODQwMiwgbzogXCImbnZhcDtcIiB9XSwgWzAsIHsgdjogXCImYnVtcDtcIiwgbjogODI0LCBvOiBcIiZuYnVtcDtcIiB9XSwgWzAsIHsgdjogXCImYnVtcGU7XCIsIG46IDgyNCwgbzogXCImbmJ1bXBlO1wiIH1dLCBbMCwgeyB2OiBcIiZkb3RlcTtcIiwgbjogODI0LCBvOiBcIiZuZWRvdDtcIiB9XSwgWzAsIFwiJmRvdGVxZG90O1wiXSwgWzAsIFwiJmVmRG90O1wiXSwgWzAsIFwiJmVyRG90O1wiXSwgWzAsIFwiJkFzc2lnbjtcIl0sIFswLCBcIiZlY29sb247XCJdLCBbMCwgXCImZWNpcjtcIl0sIFswLCBcIiZjaXJjZXE7XCJdLCBbMSwgXCImd2VkZ2VxO1wiXSwgWzAsIFwiJnZlZWVxO1wiXSwgWzEsIFwiJnRyaWFuZ2xlcTtcIl0sIFsyLCBcIiZlcXVlc3Q7XCJdLCBbMCwgXCImbmU7XCJdLCBbMCwgeyB2OiBcIiZDb25ncnVlbnQ7XCIsIG46IDg0MjEsIG86IFwiJmJuZXF1aXY7XCIgfV0sIFswLCBcIiZuZXF1aXY7XCJdLCBbMSwgeyB2OiBcIiZsZTtcIiwgbjogODQwMiwgbzogXCImbnZsZTtcIiB9XSwgWzAsIHsgdjogXCImZ2U7XCIsIG46IDg0MDIsIG86IFwiJm52Z2U7XCIgfV0sIFswLCB7IHY6IFwiJmxFO1wiLCBuOiA4MjQsIG86IFwiJm5sRTtcIiB9XSwgWzAsIHsgdjogXCImZ0U7XCIsIG46IDgyNCwgbzogXCImbmdFO1wiIH1dLCBbMCwgeyB2OiBcIiZsbkU7XCIsIG46IDY1MDI0LCBvOiBcIiZsdmVydG5lcXE7XCIgfV0sIFswLCB7IHY6IFwiJmduRTtcIiwgbjogNjUwMjQsIG86IFwiJmd2ZXJ0bmVxcTtcIiB9XSwgWzAsIHsgdjogXCImbGw7XCIsIG46IG5ldyBNYXAoLyogI19fUFVSRV9fICovIHJlc3RvcmVEaWZmKFtbODI0LCBcIiZuTHR2O1wiXSwgWzc1NzcsIFwiJm5MdDtcIl1dKSkgfV0sIFswLCB7IHY6IFwiJmdnO1wiLCBuOiBuZXcgTWFwKC8qICNfX1BVUkVfXyAqLyByZXN0b3JlRGlmZihbWzgyNCwgXCImbkd0djtcIl0sIFs3NTc3LCBcIiZuR3Q7XCJdXSkpIH1dLCBbMCwgXCImYmV0d2VlbjtcIl0sIFswLCBcIiZOb3RDdXBDYXA7XCJdLCBbMCwgXCImbmxlc3M7XCJdLCBbMCwgXCImbmd0O1wiXSwgWzAsIFwiJm5sZTtcIl0sIFswLCBcIiZuZ2U7XCJdLCBbMCwgXCImbGVzc3NpbTtcIl0sIFswLCBcIiZHcmVhdGVyVGlsZGU7XCJdLCBbMCwgXCImbmxzaW07XCJdLCBbMCwgXCImbmdzaW07XCJdLCBbMCwgXCImTGVzc0dyZWF0ZXI7XCJdLCBbMCwgXCImZ2w7XCJdLCBbMCwgXCImTm90TGVzc0dyZWF0ZXI7XCJdLCBbMCwgXCImTm90R3JlYXRlckxlc3M7XCJdLCBbMCwgXCImcHI7XCJdLCBbMCwgXCImc2M7XCJdLCBbMCwgXCImcHJjdWU7XCJdLCBbMCwgXCImc2NjdWU7XCJdLCBbMCwgXCImUHJlY2VkZXNUaWxkZTtcIl0sIFswLCB7IHY6IFwiJnNjc2ltO1wiLCBuOiA4MjQsIG86IFwiJk5vdFN1Y2NlZWRzVGlsZGU7XCIgfV0sIFswLCBcIiZOb3RQcmVjZWRlcztcIl0sIFswLCBcIiZOb3RTdWNjZWVkcztcIl0sIFswLCB7IHY6IFwiJnN1YjtcIiwgbjogODQwMiwgbzogXCImTm90U3Vic2V0O1wiIH1dLCBbMCwgeyB2OiBcIiZzdXA7XCIsIG46IDg0MDIsIG86IFwiJk5vdFN1cGVyc2V0O1wiIH1dLCBbMCwgXCImbnN1YjtcIl0sIFswLCBcIiZuc3VwO1wiXSwgWzAsIFwiJnN1YmU7XCJdLCBbMCwgXCImc3VwZTtcIl0sIFswLCBcIiZOb3RTdWJzZXRFcXVhbDtcIl0sIFswLCBcIiZOb3RTdXBlcnNldEVxdWFsO1wiXSwgWzAsIHsgdjogXCImc3VibmU7XCIsIG46IDY1MDI0LCBvOiBcIiZ2YXJzdWJzZXRuZXE7XCIgfV0sIFswLCB7IHY6IFwiJnN1cG5lO1wiLCBuOiA2NTAyNCwgbzogXCImdmFyc3Vwc2V0bmVxO1wiIH1dLCBbMSwgXCImY3VwZG90O1wiXSwgWzAsIFwiJlVuaW9uUGx1cztcIl0sIFswLCB7IHY6IFwiJnNxc3ViO1wiLCBuOiA4MjQsIG86IFwiJk5vdFNxdWFyZVN1YnNldDtcIiB9XSwgWzAsIHsgdjogXCImc3FzdXA7XCIsIG46IDgyNCwgbzogXCImTm90U3F1YXJlU3VwZXJzZXQ7XCIgfV0sIFswLCBcIiZzcXN1YmU7XCJdLCBbMCwgXCImc3FzdXBlO1wiXSwgWzAsIHsgdjogXCImc3FjYXA7XCIsIG46IDY1MDI0LCBvOiBcIiZzcWNhcHM7XCIgfV0sIFswLCB7IHY6IFwiJnNxY3VwO1wiLCBuOiA2NTAyNCwgbzogXCImc3FjdXBzO1wiIH1dLCBbMCwgXCImQ2lyY2xlUGx1cztcIl0sIFswLCBcIiZDaXJjbGVNaW51cztcIl0sIFswLCBcIiZDaXJjbGVUaW1lcztcIl0sIFswLCBcIiZvc29sO1wiXSwgWzAsIFwiJkNpcmNsZURvdDtcIl0sIFswLCBcIiZjaXJjbGVkY2lyYztcIl0sIFswLCBcIiZjaXJjbGVkYXN0O1wiXSwgWzEsIFwiJmNpcmNsZWRkYXNoO1wiXSwgWzAsIFwiJmJveHBsdXM7XCJdLCBbMCwgXCImYm94bWludXM7XCJdLCBbMCwgXCImYm94dGltZXM7XCJdLCBbMCwgXCImZG90c3F1YXJlO1wiXSwgWzAsIFwiJlJpZ2h0VGVlO1wiXSwgWzAsIFwiJmRhc2h2O1wiXSwgWzAsIFwiJkRvd25UZWU7XCJdLCBbMCwgXCImYm90O1wiXSwgWzEsIFwiJm1vZGVscztcIl0sIFswLCBcIiZEb3VibGVSaWdodFRlZTtcIl0sIFswLCBcIiZWZGFzaDtcIl0sIFswLCBcIiZWdmRhc2g7XCJdLCBbMCwgXCImVkRhc2g7XCJdLCBbMCwgXCImbnZkYXNoO1wiXSwgWzAsIFwiJm52RGFzaDtcIl0sIFswLCBcIiZuVmRhc2g7XCJdLCBbMCwgXCImblZEYXNoO1wiXSwgWzAsIFwiJnBydXJlbDtcIl0sIFsxLCBcIiZMZWZ0VHJpYW5nbGU7XCJdLCBbMCwgXCImUmlnaHRUcmlhbmdsZTtcIl0sIFswLCB7IHY6IFwiJkxlZnRUcmlhbmdsZUVxdWFsO1wiLCBuOiA4NDAyLCBvOiBcIiZudmx0cmllO1wiIH1dLCBbMCwgeyB2OiBcIiZSaWdodFRyaWFuZ2xlRXF1YWw7XCIsIG46IDg0MDIsIG86IFwiJm52cnRyaWU7XCIgfV0sIFswLCBcIiZvcmlnb2Y7XCJdLCBbMCwgXCImaW1vZjtcIl0sIFswLCBcIiZtdWx0aW1hcDtcIl0sIFswLCBcIiZoZXJjb247XCJdLCBbMCwgXCImaW50Y2FsO1wiXSwgWzAsIFwiJnZlZWJhcjtcIl0sIFsxLCBcIiZiYXJ2ZWU7XCJdLCBbMCwgXCImYW5ncnR2YjtcIl0sIFswLCBcIiZscnRyaTtcIl0sIFswLCBcIiZiaWd3ZWRnZTtcIl0sIFswLCBcIiZiaWd2ZWU7XCJdLCBbMCwgXCImYmlnY2FwO1wiXSwgWzAsIFwiJmJpZ2N1cDtcIl0sIFswLCBcIiZkaWFtO1wiXSwgWzAsIFwiJnNkb3Q7XCJdLCBbMCwgXCImc3N0YXJmO1wiXSwgWzAsIFwiJmRpdmlkZW9udGltZXM7XCJdLCBbMCwgXCImYm93dGllO1wiXSwgWzAsIFwiJmx0aW1lcztcIl0sIFswLCBcIiZydGltZXM7XCJdLCBbMCwgXCImbGVmdHRocmVldGltZXM7XCJdLCBbMCwgXCImcmlnaHR0aHJlZXRpbWVzO1wiXSwgWzAsIFwiJmJhY2tzaW1lcTtcIl0sIFswLCBcIiZjdXJseXZlZTtcIl0sIFswLCBcIiZjdXJseXdlZGdlO1wiXSwgWzAsIFwiJlN1YjtcIl0sIFswLCBcIiZTdXA7XCJdLCBbMCwgXCImQ2FwO1wiXSwgWzAsIFwiJkN1cDtcIl0sIFswLCBcIiZmb3JrO1wiXSwgWzAsIFwiJmVwYXI7XCJdLCBbMCwgXCImbGVzc2RvdDtcIl0sIFswLCBcIiZndGRvdDtcIl0sIFswLCB7IHY6IFwiJkxsO1wiLCBuOiA4MjQsIG86IFwiJm5MbDtcIiB9XSwgWzAsIHsgdjogXCImR2c7XCIsIG46IDgyNCwgbzogXCImbkdnO1wiIH1dLCBbMCwgeyB2OiBcIiZsZWc7XCIsIG46IDY1MDI0LCBvOiBcIiZsZXNnO1wiIH1dLCBbMCwgeyB2OiBcIiZnZWw7XCIsIG46IDY1MDI0LCBvOiBcIiZnZXNsO1wiIH1dLCBbMiwgXCImY3VlcHI7XCJdLCBbMCwgXCImY3Vlc2M7XCJdLCBbMCwgXCImTm90UHJlY2VkZXNTbGFudEVxdWFsO1wiXSwgWzAsIFwiJk5vdFN1Y2NlZWRzU2xhbnRFcXVhbDtcIl0sIFswLCBcIiZOb3RTcXVhcmVTdWJzZXRFcXVhbDtcIl0sIFswLCBcIiZOb3RTcXVhcmVTdXBlcnNldEVxdWFsO1wiXSwgWzIsIFwiJmxuc2ltO1wiXSwgWzAsIFwiJmduc2ltO1wiXSwgWzAsIFwiJnByZWNuc2ltO1wiXSwgWzAsIFwiJnNjbnNpbTtcIl0sIFswLCBcIiZubHRyaTtcIl0sIFswLCBcIiZOb3RSaWdodFRyaWFuZ2xlO1wiXSwgWzAsIFwiJm5sdHJpZTtcIl0sIFswLCBcIiZOb3RSaWdodFRyaWFuZ2xlRXF1YWw7XCJdLCBbMCwgXCImdmVsbGlwO1wiXSwgWzAsIFwiJmN0ZG90O1wiXSwgWzAsIFwiJnV0ZG90O1wiXSwgWzAsIFwiJmR0ZG90O1wiXSwgWzAsIFwiJmRpc2luO1wiXSwgWzAsIFwiJmlzaW5zdjtcIl0sIFswLCBcIiZpc2lucztcIl0sIFswLCB7IHY6IFwiJmlzaW5kb3Q7XCIsIG46IDgyNCwgbzogXCImbm90aW5kb3Q7XCIgfV0sIFswLCBcIiZub3RpbnZjO1wiXSwgWzAsIFwiJm5vdGludmI7XCJdLCBbMSwgeyB2OiBcIiZpc2luRTtcIiwgbjogODI0LCBvOiBcIiZub3RpbkU7XCIgfV0sIFswLCBcIiZuaXNkO1wiXSwgWzAsIFwiJnhuaXM7XCJdLCBbMCwgXCImbmlzO1wiXSwgWzAsIFwiJm5vdG5pdmM7XCJdLCBbMCwgXCImbm90bml2YjtcIl0sIFs2LCBcIiZiYXJ3ZWQ7XCJdLCBbMCwgXCImQmFyd2VkO1wiXSwgWzEsIFwiJmxjZWlsO1wiXSwgWzAsIFwiJnJjZWlsO1wiXSwgWzAsIFwiJkxlZnRGbG9vcjtcIl0sIFswLCBcIiZyZmxvb3I7XCJdLCBbMCwgXCImZHJjcm9wO1wiXSwgWzAsIFwiJmRsY3JvcDtcIl0sIFswLCBcIiZ1cmNyb3A7XCJdLCBbMCwgXCImdWxjcm9wO1wiXSwgWzAsIFwiJmJub3Q7XCJdLCBbMSwgXCImcHJvZmxpbmU7XCJdLCBbMCwgXCImcHJvZnN1cmY7XCJdLCBbMSwgXCImdGVscmVjO1wiXSwgWzAsIFwiJnRhcmdldDtcIl0sIFs1LCBcIiZ1bGNvcm47XCJdLCBbMCwgXCImdXJjb3JuO1wiXSwgWzAsIFwiJmRsY29ybjtcIl0sIFswLCBcIiZkcmNvcm47XCJdLCBbMiwgXCImZnJvd247XCJdLCBbMCwgXCImc21pbGU7XCJdLCBbOSwgXCImY3lsY3R5O1wiXSwgWzAsIFwiJnByb2ZhbGFyO1wiXSwgWzcsIFwiJnRvcGJvdDtcIl0sIFs2LCBcIiZvdmJhcjtcIl0sIFsxLCBcIiZzb2xiYXI7XCJdLCBbNjAsIFwiJmFuZ3phcnI7XCJdLCBbNTEsIFwiJmxtb3VzdGFjaGU7XCJdLCBbMCwgXCImcm1vdXN0YWNoZTtcIl0sIFsyLCBcIiZPdmVyQnJhY2tldDtcIl0sIFswLCBcIiZiYnJrO1wiXSwgWzAsIFwiJmJicmt0YnJrO1wiXSwgWzM3LCBcIiZPdmVyUGFyZW50aGVzaXM7XCJdLCBbMCwgXCImVW5kZXJQYXJlbnRoZXNpcztcIl0sIFswLCBcIiZPdmVyQnJhY2U7XCJdLCBbMCwgXCImVW5kZXJCcmFjZTtcIl0sIFsyLCBcIiZ0cnBleml1bTtcIl0sIFs0LCBcIiZlbGludGVycztcIl0sIFs1OSwgXCImYmxhbms7XCJdLCBbMTY0LCBcIiZjaXJjbGVkUztcIl0sIFs1NSwgXCImYm94aDtcIl0sIFsxLCBcIiZib3h2O1wiXSwgWzksIFwiJmJveGRyO1wiXSwgWzMsIFwiJmJveGRsO1wiXSwgWzMsIFwiJmJveHVyO1wiXSwgWzMsIFwiJmJveHVsO1wiXSwgWzMsIFwiJmJveHZyO1wiXSwgWzcsIFwiJmJveHZsO1wiXSwgWzcsIFwiJmJveGhkO1wiXSwgWzcsIFwiJmJveGh1O1wiXSwgWzcsIFwiJmJveHZoO1wiXSwgWzE5LCBcIiZib3hIO1wiXSwgWzAsIFwiJmJveFY7XCJdLCBbMCwgXCImYm94ZFI7XCJdLCBbMCwgXCImYm94RHI7XCJdLCBbMCwgXCImYm94RFI7XCJdLCBbMCwgXCImYm94ZEw7XCJdLCBbMCwgXCImYm94RGw7XCJdLCBbMCwgXCImYm94REw7XCJdLCBbMCwgXCImYm94dVI7XCJdLCBbMCwgXCImYm94VXI7XCJdLCBbMCwgXCImYm94VVI7XCJdLCBbMCwgXCImYm94dUw7XCJdLCBbMCwgXCImYm94VWw7XCJdLCBbMCwgXCImYm94VUw7XCJdLCBbMCwgXCImYm94dlI7XCJdLCBbMCwgXCImYm94VnI7XCJdLCBbMCwgXCImYm94VlI7XCJdLCBbMCwgXCImYm94dkw7XCJdLCBbMCwgXCImYm94Vmw7XCJdLCBbMCwgXCImYm94Vkw7XCJdLCBbMCwgXCImYm94SGQ7XCJdLCBbMCwgXCImYm94aEQ7XCJdLCBbMCwgXCImYm94SEQ7XCJdLCBbMCwgXCImYm94SHU7XCJdLCBbMCwgXCImYm94aFU7XCJdLCBbMCwgXCImYm94SFU7XCJdLCBbMCwgXCImYm94dkg7XCJdLCBbMCwgXCImYm94Vmg7XCJdLCBbMCwgXCImYm94Vkg7XCJdLCBbMTksIFwiJnVoYmxrO1wiXSwgWzMsIFwiJmxoYmxrO1wiXSwgWzMsIFwiJmJsb2NrO1wiXSwgWzgsIFwiJmJsazE0O1wiXSwgWzAsIFwiJmJsazEyO1wiXSwgWzAsIFwiJmJsazM0O1wiXSwgWzEzLCBcIiZzcXVhcmU7XCJdLCBbOCwgXCImYmxhY2tzcXVhcmU7XCJdLCBbMCwgXCImRW1wdHlWZXJ5U21hbGxTcXVhcmU7XCJdLCBbMSwgXCImcmVjdDtcIl0sIFswLCBcIiZtYXJrZXI7XCJdLCBbMiwgXCImZmx0bnM7XCJdLCBbMSwgXCImYmlndHJpYW5nbGV1cDtcIl0sIFswLCBcIiZibGFja3RyaWFuZ2xlO1wiXSwgWzAsIFwiJnRyaWFuZ2xlO1wiXSwgWzIsIFwiJmJsYWNrdHJpYW5nbGVyaWdodDtcIl0sIFswLCBcIiZydHJpO1wiXSwgWzMsIFwiJmJpZ3RyaWFuZ2xlZG93bjtcIl0sIFswLCBcIiZibGFja3RyaWFuZ2xlZG93bjtcIl0sIFswLCBcIiZkdHJpO1wiXSwgWzIsIFwiJmJsYWNrdHJpYW5nbGVsZWZ0O1wiXSwgWzAsIFwiJmx0cmk7XCJdLCBbNiwgXCImbG96O1wiXSwgWzAsIFwiJmNpcjtcIl0sIFszMiwgXCImdHJpZG90O1wiXSwgWzIsIFwiJmJpZ2NpcmM7XCJdLCBbOCwgXCImdWx0cmk7XCJdLCBbMCwgXCImdXJ0cmk7XCJdLCBbMCwgXCImbGx0cmk7XCJdLCBbMCwgXCImRW1wdHlTbWFsbFNxdWFyZTtcIl0sIFswLCBcIiZGaWxsZWRTbWFsbFNxdWFyZTtcIl0sIFs4LCBcIiZiaWdzdGFyO1wiXSwgWzAsIFwiJnN0YXI7XCJdLCBbNywgXCImcGhvbmU7XCJdLCBbNDksIFwiJmZlbWFsZTtcIl0sIFsxLCBcIiZtYWxlO1wiXSwgWzI5LCBcIiZzcGFkZXM7XCJdLCBbMiwgXCImY2x1YnM7XCJdLCBbMSwgXCImaGVhcnRzO1wiXSwgWzAsIFwiJmRpYW1vbmRzdWl0O1wiXSwgWzMsIFwiJnN1bmc7XCJdLCBbMiwgXCImZmxhdDtcIl0sIFswLCBcIiZuYXR1cmFsO1wiXSwgWzAsIFwiJnNoYXJwO1wiXSwgWzE2MywgXCImY2hlY2s7XCJdLCBbMywgXCImY3Jvc3M7XCJdLCBbOCwgXCImbWFsdDtcIl0sIFsyMSwgXCImc2V4dDtcIl0sIFszMywgXCImVmVydGljYWxTZXBhcmF0b3I7XCJdLCBbMjUsIFwiJmxiYnJrO1wiXSwgWzAsIFwiJnJiYnJrO1wiXSwgWzg0LCBcIiZic29saHN1YjtcIl0sIFswLCBcIiZzdXBoc29sO1wiXSwgWzI4LCBcIiZMZWZ0RG91YmxlQnJhY2tldDtcIl0sIFswLCBcIiZSaWdodERvdWJsZUJyYWNrZXQ7XCJdLCBbMCwgXCImbGFuZztcIl0sIFswLCBcIiZyYW5nO1wiXSwgWzAsIFwiJkxhbmc7XCJdLCBbMCwgXCImUmFuZztcIl0sIFswLCBcIiZsb2FuZztcIl0sIFswLCBcIiZyb2FuZztcIl0sIFs3LCBcIiZsb25nbGVmdGFycm93O1wiXSwgWzAsIFwiJmxvbmdyaWdodGFycm93O1wiXSwgWzAsIFwiJmxvbmdsZWZ0cmlnaHRhcnJvdztcIl0sIFswLCBcIiZEb3VibGVMb25nTGVmdEFycm93O1wiXSwgWzAsIFwiJkRvdWJsZUxvbmdSaWdodEFycm93O1wiXSwgWzAsIFwiJkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdztcIl0sIFsxLCBcIiZsb25nbWFwc3RvO1wiXSwgWzIsIFwiJmR6aWdyYXJyO1wiXSwgWzI1OCwgXCImbnZsQXJyO1wiXSwgWzAsIFwiJm52ckFycjtcIl0sIFswLCBcIiZudkhhcnI7XCJdLCBbMCwgXCImTWFwO1wiXSwgWzYsIFwiJmxiYXJyO1wiXSwgWzAsIFwiJmJrYXJvdztcIl0sIFswLCBcIiZsQmFycjtcIl0sIFswLCBcIiZkYmthcm93O1wiXSwgWzAsIFwiJmRyYmthcm93O1wiXSwgWzAsIFwiJkREb3RyYWhkO1wiXSwgWzAsIFwiJlVwQXJyb3dCYXI7XCJdLCBbMCwgXCImRG93bkFycm93QmFyO1wiXSwgWzIsIFwiJlJhcnJ0bDtcIl0sIFsyLCBcIiZsYXRhaWw7XCJdLCBbMCwgXCImcmF0YWlsO1wiXSwgWzAsIFwiJmxBdGFpbDtcIl0sIFswLCBcIiZyQXRhaWw7XCJdLCBbMCwgXCImbGFycmZzO1wiXSwgWzAsIFwiJnJhcnJmcztcIl0sIFswLCBcIiZsYXJyYmZzO1wiXSwgWzAsIFwiJnJhcnJiZnM7XCJdLCBbMiwgXCImbndhcmhrO1wiXSwgWzAsIFwiJm5lYXJoaztcIl0sIFswLCBcIiZoa3NlYXJvdztcIl0sIFswLCBcIiZoa3N3YXJvdztcIl0sIFswLCBcIiZud25lYXI7XCJdLCBbMCwgXCImbmVzZWFyO1wiXSwgWzAsIFwiJnNlc3dhcjtcIl0sIFswLCBcIiZzd253YXI7XCJdLCBbOCwgeyB2OiBcIiZyYXJyYztcIiwgbjogODI0LCBvOiBcIiZucmFycmM7XCIgfV0sIFsxLCBcIiZjdWRhcnJyO1wiXSwgWzAsIFwiJmxkY2E7XCJdLCBbMCwgXCImcmRjYTtcIl0sIFswLCBcIiZjdWRhcnJsO1wiXSwgWzAsIFwiJmxhcnJwbDtcIl0sIFsyLCBcIiZjdXJhcnJtO1wiXSwgWzAsIFwiJmN1bGFycnA7XCJdLCBbNywgXCImcmFycnBsO1wiXSwgWzIsIFwiJmhhcnJjaXI7XCJdLCBbMCwgXCImVWFycm9jaXI7XCJdLCBbMCwgXCImbHVyZHNoYXI7XCJdLCBbMCwgXCImbGRydXNoYXI7XCJdLCBbMiwgXCImTGVmdFJpZ2h0VmVjdG9yO1wiXSwgWzAsIFwiJlJpZ2h0VXBEb3duVmVjdG9yO1wiXSwgWzAsIFwiJkRvd25MZWZ0UmlnaHRWZWN0b3I7XCJdLCBbMCwgXCImTGVmdFVwRG93blZlY3RvcjtcIl0sIFswLCBcIiZMZWZ0VmVjdG9yQmFyO1wiXSwgWzAsIFwiJlJpZ2h0VmVjdG9yQmFyO1wiXSwgWzAsIFwiJlJpZ2h0VXBWZWN0b3JCYXI7XCJdLCBbMCwgXCImUmlnaHREb3duVmVjdG9yQmFyO1wiXSwgWzAsIFwiJkRvd25MZWZ0VmVjdG9yQmFyO1wiXSwgWzAsIFwiJkRvd25SaWdodFZlY3RvckJhcjtcIl0sIFswLCBcIiZMZWZ0VXBWZWN0b3JCYXI7XCJdLCBbMCwgXCImTGVmdERvd25WZWN0b3JCYXI7XCJdLCBbMCwgXCImTGVmdFRlZVZlY3RvcjtcIl0sIFswLCBcIiZSaWdodFRlZVZlY3RvcjtcIl0sIFswLCBcIiZSaWdodFVwVGVlVmVjdG9yO1wiXSwgWzAsIFwiJlJpZ2h0RG93blRlZVZlY3RvcjtcIl0sIFswLCBcIiZEb3duTGVmdFRlZVZlY3RvcjtcIl0sIFswLCBcIiZEb3duUmlnaHRUZWVWZWN0b3I7XCJdLCBbMCwgXCImTGVmdFVwVGVlVmVjdG9yO1wiXSwgWzAsIFwiJkxlZnREb3duVGVlVmVjdG9yO1wiXSwgWzAsIFwiJmxIYXI7XCJdLCBbMCwgXCImdUhhcjtcIl0sIFswLCBcIiZySGFyO1wiXSwgWzAsIFwiJmRIYXI7XCJdLCBbMCwgXCImbHVydWhhcjtcIl0sIFswLCBcIiZsZHJkaGFyO1wiXSwgWzAsIFwiJnJ1bHVoYXI7XCJdLCBbMCwgXCImcmRsZGhhcjtcIl0sIFswLCBcIiZsaGFydWw7XCJdLCBbMCwgXCImbGxoYXJkO1wiXSwgWzAsIFwiJnJoYXJ1bDtcIl0sIFswLCBcIiZscmhhcmQ7XCJdLCBbMCwgXCImdWRoYXI7XCJdLCBbMCwgXCImZHVoYXI7XCJdLCBbMCwgXCImUm91bmRJbXBsaWVzO1wiXSwgWzAsIFwiJmVyYXJyO1wiXSwgWzAsIFwiJnNpbXJhcnI7XCJdLCBbMCwgXCImbGFycnNpbTtcIl0sIFswLCBcIiZyYXJyc2ltO1wiXSwgWzAsIFwiJnJhcnJhcDtcIl0sIFswLCBcIiZsdGxhcnI7XCJdLCBbMSwgXCImZ3RyYXJyO1wiXSwgWzAsIFwiJnN1YnJhcnI7XCJdLCBbMSwgXCImc3VwbGFycjtcIl0sIFswLCBcIiZsZmlzaHQ7XCJdLCBbMCwgXCImcmZpc2h0O1wiXSwgWzAsIFwiJnVmaXNodDtcIl0sIFswLCBcIiZkZmlzaHQ7XCJdLCBbNSwgXCImbG9wYXI7XCJdLCBbMCwgXCImcm9wYXI7XCJdLCBbNCwgXCImbGJya2U7XCJdLCBbMCwgXCImcmJya2U7XCJdLCBbMCwgXCImbGJya3NsdTtcIl0sIFswLCBcIiZyYnJrc2xkO1wiXSwgWzAsIFwiJmxicmtzbGQ7XCJdLCBbMCwgXCImcmJya3NsdTtcIl0sIFswLCBcIiZsYW5nZDtcIl0sIFswLCBcIiZyYW5nZDtcIl0sIFswLCBcIiZscGFybHQ7XCJdLCBbMCwgXCImcnBhcmd0O1wiXSwgWzAsIFwiJmd0bFBhcjtcIl0sIFswLCBcIiZsdHJQYXI7XCJdLCBbMywgXCImdnppZ3phZztcIl0sIFsxLCBcIiZ2YW5ncnQ7XCJdLCBbMCwgXCImYW5ncnR2YmQ7XCJdLCBbNiwgXCImYW5nZTtcIl0sIFswLCBcIiZyYW5nZTtcIl0sIFswLCBcIiZkd2FuZ2xlO1wiXSwgWzAsIFwiJnV3YW5nbGU7XCJdLCBbMCwgXCImYW5nbXNkYWE7XCJdLCBbMCwgXCImYW5nbXNkYWI7XCJdLCBbMCwgXCImYW5nbXNkYWM7XCJdLCBbMCwgXCImYW5nbXNkYWQ7XCJdLCBbMCwgXCImYW5nbXNkYWU7XCJdLCBbMCwgXCImYW5nbXNkYWY7XCJdLCBbMCwgXCImYW5nbXNkYWc7XCJdLCBbMCwgXCImYW5nbXNkYWg7XCJdLCBbMCwgXCImYmVtcHR5djtcIl0sIFswLCBcIiZkZW1wdHl2O1wiXSwgWzAsIFwiJmNlbXB0eXY7XCJdLCBbMCwgXCImcmFlbXB0eXY7XCJdLCBbMCwgXCImbGFlbXB0eXY7XCJdLCBbMCwgXCImb2hiYXI7XCJdLCBbMCwgXCImb21pZDtcIl0sIFswLCBcIiZvcGFyO1wiXSwgWzEsIFwiJm9wZXJwO1wiXSwgWzEsIFwiJm9sY3Jvc3M7XCJdLCBbMCwgXCImb2Rzb2xkO1wiXSwgWzEsIFwiJm9sY2lyO1wiXSwgWzAsIFwiJm9mY2lyO1wiXSwgWzAsIFwiJm9sdDtcIl0sIFswLCBcIiZvZ3Q7XCJdLCBbMCwgXCImY2lyc2NpcjtcIl0sIFswLCBcIiZjaXJFO1wiXSwgWzAsIFwiJnNvbGI7XCJdLCBbMCwgXCImYnNvbGI7XCJdLCBbMywgXCImYm94Ym94O1wiXSwgWzMsIFwiJnRyaXNiO1wiXSwgWzAsIFwiJnJ0cmlsdHJpO1wiXSwgWzAsIHsgdjogXCImTGVmdFRyaWFuZ2xlQmFyO1wiLCBuOiA4MjQsIG86IFwiJk5vdExlZnRUcmlhbmdsZUJhcjtcIiB9XSwgWzAsIHsgdjogXCImUmlnaHRUcmlhbmdsZUJhcjtcIiwgbjogODI0LCBvOiBcIiZOb3RSaWdodFRyaWFuZ2xlQmFyO1wiIH1dLCBbMTEsIFwiJmlpbmZpbjtcIl0sIFswLCBcIiZpbmZpbnRpZTtcIl0sIFswLCBcIiZudmluZmluO1wiXSwgWzQsIFwiJmVwYXJzbDtcIl0sIFswLCBcIiZzbWVwYXJzbDtcIl0sIFswLCBcIiZlcXZwYXJzbDtcIl0sIFs1LCBcIiZibGFja2xvemVuZ2U7XCJdLCBbOCwgXCImUnVsZURlbGF5ZWQ7XCJdLCBbMSwgXCImZHNvbDtcIl0sIFs5LCBcIiZiaWdvZG90O1wiXSwgWzAsIFwiJmJpZ29wbHVzO1wiXSwgWzAsIFwiJmJpZ290aW1lcztcIl0sIFsxLCBcIiZiaWd1cGx1cztcIl0sIFsxLCBcIiZiaWdzcWN1cDtcIl0sIFs1LCBcIiZpaWlpbnQ7XCJdLCBbMCwgXCImZnBhcnRpbnQ7XCJdLCBbMiwgXCImY2lyZm5pbnQ7XCJdLCBbMCwgXCImYXdpbnQ7XCJdLCBbMCwgXCImcnBwb2xpbnQ7XCJdLCBbMCwgXCImc2Nwb2xpbnQ7XCJdLCBbMCwgXCImbnBvbGludDtcIl0sIFswLCBcIiZwb2ludGludDtcIl0sIFswLCBcIiZxdWF0aW50O1wiXSwgWzAsIFwiJmludGxhcmhrO1wiXSwgWzEwLCBcIiZwbHVzY2lyO1wiXSwgWzAsIFwiJnBsdXNhY2lyO1wiXSwgWzAsIFwiJnNpbXBsdXM7XCJdLCBbMCwgXCImcGx1c2R1O1wiXSwgWzAsIFwiJnBsdXNzaW07XCJdLCBbMCwgXCImcGx1c3R3bztcIl0sIFsxLCBcIiZtY29tbWE7XCJdLCBbMCwgXCImbWludXNkdTtcIl0sIFsyLCBcIiZsb3BsdXM7XCJdLCBbMCwgXCImcm9wbHVzO1wiXSwgWzAsIFwiJkNyb3NzO1wiXSwgWzAsIFwiJnRpbWVzZDtcIl0sIFswLCBcIiZ0aW1lc2JhcjtcIl0sIFsxLCBcIiZzbWFzaHA7XCJdLCBbMCwgXCImbG90aW1lcztcIl0sIFswLCBcIiZyb3RpbWVzO1wiXSwgWzAsIFwiJm90aW1lc2FzO1wiXSwgWzAsIFwiJk90aW1lcztcIl0sIFswLCBcIiZvZGl2O1wiXSwgWzAsIFwiJnRyaXBsdXM7XCJdLCBbMCwgXCImdHJpbWludXM7XCJdLCBbMCwgXCImdHJpdGltZTtcIl0sIFswLCBcIiZpbnRwcm9kO1wiXSwgWzIsIFwiJmFtYWxnO1wiXSwgWzAsIFwiJmNhcGRvdDtcIl0sIFsxLCBcIiZuY3VwO1wiXSwgWzAsIFwiJm5jYXA7XCJdLCBbMCwgXCImY2FwYW5kO1wiXSwgWzAsIFwiJmN1cG9yO1wiXSwgWzAsIFwiJmN1cGNhcDtcIl0sIFswLCBcIiZjYXBjdXA7XCJdLCBbMCwgXCImY3VwYnJjYXA7XCJdLCBbMCwgXCImY2FwYnJjdXA7XCJdLCBbMCwgXCImY3VwY3VwO1wiXSwgWzAsIFwiJmNhcGNhcDtcIl0sIFswLCBcIiZjY3VwcztcIl0sIFswLCBcIiZjY2FwcztcIl0sIFsyLCBcIiZjY3Vwc3NtO1wiXSwgWzIsIFwiJkFuZDtcIl0sIFswLCBcIiZPcjtcIl0sIFswLCBcIiZhbmRhbmQ7XCJdLCBbMCwgXCImb3JvcjtcIl0sIFswLCBcIiZvcnNsb3BlO1wiXSwgWzAsIFwiJmFuZHNsb3BlO1wiXSwgWzEsIFwiJmFuZHY7XCJdLCBbMCwgXCImb3J2O1wiXSwgWzAsIFwiJmFuZGQ7XCJdLCBbMCwgXCImb3JkO1wiXSwgWzEsIFwiJndlZGJhcjtcIl0sIFs2LCBcIiZzZG90ZTtcIl0sIFszLCBcIiZzaW1kb3Q7XCJdLCBbMiwgeyB2OiBcIiZjb25nZG90O1wiLCBuOiA4MjQsIG86IFwiJm5jb25nZG90O1wiIH1dLCBbMCwgXCImZWFzdGVyO1wiXSwgWzAsIFwiJmFwYWNpcjtcIl0sIFswLCB7IHY6IFwiJmFwRTtcIiwgbjogODI0LCBvOiBcIiZuYXBFO1wiIH1dLCBbMCwgXCImZXBsdXM7XCJdLCBbMCwgXCImcGx1c2U7XCJdLCBbMCwgXCImRXNpbTtcIl0sIFswLCBcIiZDb2xvbmU7XCJdLCBbMCwgXCImRXF1YWw7XCJdLCBbMSwgXCImZGRvdHNlcTtcIl0sIFswLCBcIiZlcXVpdkREO1wiXSwgWzAsIFwiJmx0Y2lyO1wiXSwgWzAsIFwiJmd0Y2lyO1wiXSwgWzAsIFwiJmx0cXVlc3Q7XCJdLCBbMCwgXCImZ3RxdWVzdDtcIl0sIFswLCB7IHY6IFwiJmxlcXNsYW50O1wiLCBuOiA4MjQsIG86IFwiJm5sZXFzbGFudDtcIiB9XSwgWzAsIHsgdjogXCImZ2Vxc2xhbnQ7XCIsIG46IDgyNCwgbzogXCImbmdlcXNsYW50O1wiIH1dLCBbMCwgXCImbGVzZG90O1wiXSwgWzAsIFwiJmdlc2RvdDtcIl0sIFswLCBcIiZsZXNkb3RvO1wiXSwgWzAsIFwiJmdlc2RvdG87XCJdLCBbMCwgXCImbGVzZG90b3I7XCJdLCBbMCwgXCImZ2VzZG90b2w7XCJdLCBbMCwgXCImbGFwO1wiXSwgWzAsIFwiJmdhcDtcIl0sIFswLCBcIiZsbmU7XCJdLCBbMCwgXCImZ25lO1wiXSwgWzAsIFwiJmxuYXA7XCJdLCBbMCwgXCImZ25hcDtcIl0sIFswLCBcIiZsRWc7XCJdLCBbMCwgXCImZ0VsO1wiXSwgWzAsIFwiJmxzaW1lO1wiXSwgWzAsIFwiJmdzaW1lO1wiXSwgWzAsIFwiJmxzaW1nO1wiXSwgWzAsIFwiJmdzaW1sO1wiXSwgWzAsIFwiJmxnRTtcIl0sIFswLCBcIiZnbEU7XCJdLCBbMCwgXCImbGVzZ2VzO1wiXSwgWzAsIFwiJmdlc2xlcztcIl0sIFswLCBcIiZlbHM7XCJdLCBbMCwgXCImZWdzO1wiXSwgWzAsIFwiJmVsc2RvdDtcIl0sIFswLCBcIiZlZ3Nkb3Q7XCJdLCBbMCwgXCImZWw7XCJdLCBbMCwgXCImZWc7XCJdLCBbMiwgXCImc2ltbDtcIl0sIFswLCBcIiZzaW1nO1wiXSwgWzAsIFwiJnNpbWxFO1wiXSwgWzAsIFwiJnNpbWdFO1wiXSwgWzAsIHsgdjogXCImTGVzc0xlc3M7XCIsIG46IDgyNCwgbzogXCImTm90TmVzdGVkTGVzc0xlc3M7XCIgfV0sIFswLCB7IHY6IFwiJkdyZWF0ZXJHcmVhdGVyO1wiLCBuOiA4MjQsIG86IFwiJk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyO1wiIH1dLCBbMSwgXCImZ2xqO1wiXSwgWzAsIFwiJmdsYTtcIl0sIFswLCBcIiZsdGNjO1wiXSwgWzAsIFwiJmd0Y2M7XCJdLCBbMCwgXCImbGVzY2M7XCJdLCBbMCwgXCImZ2VzY2M7XCJdLCBbMCwgXCImc210O1wiXSwgWzAsIFwiJmxhdDtcIl0sIFswLCB7IHY6IFwiJnNtdGU7XCIsIG46IDY1MDI0LCBvOiBcIiZzbXRlcztcIiB9XSwgWzAsIHsgdjogXCImbGF0ZTtcIiwgbjogNjUwMjQsIG86IFwiJmxhdGVzO1wiIH1dLCBbMCwgXCImYnVtcEU7XCJdLCBbMCwgeyB2OiBcIiZQcmVjZWRlc0VxdWFsO1wiLCBuOiA4MjQsIG86IFwiJk5vdFByZWNlZGVzRXF1YWw7XCIgfV0sIFswLCB7IHY6IFwiJnNjZTtcIiwgbjogODI0LCBvOiBcIiZOb3RTdWNjZWVkc0VxdWFsO1wiIH1dLCBbMiwgXCImcHJFO1wiXSwgWzAsIFwiJnNjRTtcIl0sIFswLCBcIiZwcmVjbmVxcTtcIl0sIFswLCBcIiZzY25FO1wiXSwgWzAsIFwiJnByYXA7XCJdLCBbMCwgXCImc2NhcDtcIl0sIFswLCBcIiZwcmVjbmFwcHJveDtcIl0sIFswLCBcIiZzY25hcDtcIl0sIFswLCBcIiZQcjtcIl0sIFswLCBcIiZTYztcIl0sIFswLCBcIiZzdWJkb3Q7XCJdLCBbMCwgXCImc3VwZG90O1wiXSwgWzAsIFwiJnN1YnBsdXM7XCJdLCBbMCwgXCImc3VwcGx1cztcIl0sIFswLCBcIiZzdWJtdWx0O1wiXSwgWzAsIFwiJnN1cG11bHQ7XCJdLCBbMCwgXCImc3ViZWRvdDtcIl0sIFswLCBcIiZzdXBlZG90O1wiXSwgWzAsIHsgdjogXCImc3ViRTtcIiwgbjogODI0LCBvOiBcIiZuc3ViRTtcIiB9XSwgWzAsIHsgdjogXCImc3VwRTtcIiwgbjogODI0LCBvOiBcIiZuc3VwRTtcIiB9XSwgWzAsIFwiJnN1YnNpbTtcIl0sIFswLCBcIiZzdXBzaW07XCJdLCBbMiwgeyB2OiBcIiZzdWJuRTtcIiwgbjogNjUwMjQsIG86IFwiJnZhcnN1YnNldG5lcXE7XCIgfV0sIFswLCB7IHY6IFwiJnN1cG5FO1wiLCBuOiA2NTAyNCwgbzogXCImdmFyc3Vwc2V0bmVxcTtcIiB9XSwgWzIsIFwiJmNzdWI7XCJdLCBbMCwgXCImY3N1cDtcIl0sIFswLCBcIiZjc3ViZTtcIl0sIFswLCBcIiZjc3VwZTtcIl0sIFswLCBcIiZzdWJzdXA7XCJdLCBbMCwgXCImc3Vwc3ViO1wiXSwgWzAsIFwiJnN1YnN1YjtcIl0sIFswLCBcIiZzdXBzdXA7XCJdLCBbMCwgXCImc3VwaHN1YjtcIl0sIFswLCBcIiZzdXBkc3ViO1wiXSwgWzAsIFwiJmZvcmt2O1wiXSwgWzAsIFwiJnRvcGZvcms7XCJdLCBbMCwgXCImbWxjcDtcIl0sIFs4LCBcIiZEYXNodjtcIl0sIFsxLCBcIiZWZGFzaGw7XCJdLCBbMCwgXCImQmFydjtcIl0sIFswLCBcIiZ2QmFyO1wiXSwgWzAsIFwiJnZCYXJ2O1wiXSwgWzEsIFwiJlZiYXI7XCJdLCBbMCwgXCImTm90O1wiXSwgWzAsIFwiJmJOb3Q7XCJdLCBbMCwgXCImcm5taWQ7XCJdLCBbMCwgXCImY2lybWlkO1wiXSwgWzAsIFwiJm1pZGNpcjtcIl0sIFswLCBcIiZ0b3BjaXI7XCJdLCBbMCwgXCImbmhwYXI7XCJdLCBbMCwgXCImcGFyc2ltO1wiXSwgWzksIHsgdjogXCImcGFyc2w7XCIsIG46IDg0MjEsIG86IFwiJm5wYXJzbDtcIiB9XSwgWzQ0MzQzLCB7IG46IG5ldyBNYXAoLyogI19fUFVSRV9fICovIHJlc3RvcmVEaWZmKFtbNTY0NzYsIFwiJkFzY3I7XCJdLCBbMSwgXCImQ3NjcjtcIl0sIFswLCBcIiZEc2NyO1wiXSwgWzIsIFwiJkdzY3I7XCJdLCBbMiwgXCImSnNjcjtcIl0sIFswLCBcIiZLc2NyO1wiXSwgWzIsIFwiJk5zY3I7XCJdLCBbMCwgXCImT3NjcjtcIl0sIFswLCBcIiZQc2NyO1wiXSwgWzAsIFwiJlFzY3I7XCJdLCBbMSwgXCImU3NjcjtcIl0sIFswLCBcIiZUc2NyO1wiXSwgWzAsIFwiJlVzY3I7XCJdLCBbMCwgXCImVnNjcjtcIl0sIFswLCBcIiZXc2NyO1wiXSwgWzAsIFwiJlhzY3I7XCJdLCBbMCwgXCImWXNjcjtcIl0sIFswLCBcIiZac2NyO1wiXSwgWzAsIFwiJmFzY3I7XCJdLCBbMCwgXCImYnNjcjtcIl0sIFswLCBcIiZjc2NyO1wiXSwgWzAsIFwiJmRzY3I7XCJdLCBbMSwgXCImZnNjcjtcIl0sIFsxLCBcIiZoc2NyO1wiXSwgWzAsIFwiJmlzY3I7XCJdLCBbMCwgXCImanNjcjtcIl0sIFswLCBcIiZrc2NyO1wiXSwgWzAsIFwiJmxzY3I7XCJdLCBbMCwgXCImbXNjcjtcIl0sIFswLCBcIiZuc2NyO1wiXSwgWzEsIFwiJnBzY3I7XCJdLCBbMCwgXCImcXNjcjtcIl0sIFswLCBcIiZyc2NyO1wiXSwgWzAsIFwiJnNzY3I7XCJdLCBbMCwgXCImdHNjcjtcIl0sIFswLCBcIiZ1c2NyO1wiXSwgWzAsIFwiJnZzY3I7XCJdLCBbMCwgXCImd3NjcjtcIl0sIFswLCBcIiZ4c2NyO1wiXSwgWzAsIFwiJnlzY3I7XCJdLCBbMCwgXCImenNjcjtcIl0sIFs1MiwgXCImQWZyO1wiXSwgWzAsIFwiJkJmcjtcIl0sIFsxLCBcIiZEZnI7XCJdLCBbMCwgXCImRWZyO1wiXSwgWzAsIFwiJkZmcjtcIl0sIFswLCBcIiZHZnI7XCJdLCBbMiwgXCImSmZyO1wiXSwgWzAsIFwiJktmcjtcIl0sIFswLCBcIiZMZnI7XCJdLCBbMCwgXCImTWZyO1wiXSwgWzAsIFwiJk5mcjtcIl0sIFswLCBcIiZPZnI7XCJdLCBbMCwgXCImUGZyO1wiXSwgWzAsIFwiJlFmcjtcIl0sIFsxLCBcIiZTZnI7XCJdLCBbMCwgXCImVGZyO1wiXSwgWzAsIFwiJlVmcjtcIl0sIFswLCBcIiZWZnI7XCJdLCBbMCwgXCImV2ZyO1wiXSwgWzAsIFwiJlhmcjtcIl0sIFswLCBcIiZZZnI7XCJdLCBbMSwgXCImYWZyO1wiXSwgWzAsIFwiJmJmcjtcIl0sIFswLCBcIiZjZnI7XCJdLCBbMCwgXCImZGZyO1wiXSwgWzAsIFwiJmVmcjtcIl0sIFswLCBcIiZmZnI7XCJdLCBbMCwgXCImZ2ZyO1wiXSwgWzAsIFwiJmhmcjtcIl0sIFswLCBcIiZpZnI7XCJdLCBbMCwgXCImamZyO1wiXSwgWzAsIFwiJmtmcjtcIl0sIFswLCBcIiZsZnI7XCJdLCBbMCwgXCImbWZyO1wiXSwgWzAsIFwiJm5mcjtcIl0sIFswLCBcIiZvZnI7XCJdLCBbMCwgXCImcGZyO1wiXSwgWzAsIFwiJnFmcjtcIl0sIFswLCBcIiZyZnI7XCJdLCBbMCwgXCImc2ZyO1wiXSwgWzAsIFwiJnRmcjtcIl0sIFswLCBcIiZ1ZnI7XCJdLCBbMCwgXCImdmZyO1wiXSwgWzAsIFwiJndmcjtcIl0sIFswLCBcIiZ4ZnI7XCJdLCBbMCwgXCImeWZyO1wiXSwgWzAsIFwiJnpmcjtcIl0sIFswLCBcIiZBb3BmO1wiXSwgWzAsIFwiJkJvcGY7XCJdLCBbMSwgXCImRG9wZjtcIl0sIFswLCBcIiZFb3BmO1wiXSwgWzAsIFwiJkZvcGY7XCJdLCBbMCwgXCImR29wZjtcIl0sIFsxLCBcIiZJb3BmO1wiXSwgWzAsIFwiJkpvcGY7XCJdLCBbMCwgXCImS29wZjtcIl0sIFswLCBcIiZMb3BmO1wiXSwgWzAsIFwiJk1vcGY7XCJdLCBbMSwgXCImT29wZjtcIl0sIFszLCBcIiZTb3BmO1wiXSwgWzAsIFwiJlRvcGY7XCJdLCBbMCwgXCImVW9wZjtcIl0sIFswLCBcIiZWb3BmO1wiXSwgWzAsIFwiJldvcGY7XCJdLCBbMCwgXCImWG9wZjtcIl0sIFswLCBcIiZZb3BmO1wiXSwgWzEsIFwiJmFvcGY7XCJdLCBbMCwgXCImYm9wZjtcIl0sIFswLCBcIiZjb3BmO1wiXSwgWzAsIFwiJmRvcGY7XCJdLCBbMCwgXCImZW9wZjtcIl0sIFswLCBcIiZmb3BmO1wiXSwgWzAsIFwiJmdvcGY7XCJdLCBbMCwgXCImaG9wZjtcIl0sIFswLCBcIiZpb3BmO1wiXSwgWzAsIFwiJmpvcGY7XCJdLCBbMCwgXCIma29wZjtcIl0sIFswLCBcIiZsb3BmO1wiXSwgWzAsIFwiJm1vcGY7XCJdLCBbMCwgXCImbm9wZjtcIl0sIFswLCBcIiZvb3BmO1wiXSwgWzAsIFwiJnBvcGY7XCJdLCBbMCwgXCImcW9wZjtcIl0sIFswLCBcIiZyb3BmO1wiXSwgWzAsIFwiJnNvcGY7XCJdLCBbMCwgXCImdG9wZjtcIl0sIFswLCBcIiZ1b3BmO1wiXSwgWzAsIFwiJnZvcGY7XCJdLCBbMCwgXCImd29wZjtcIl0sIFswLCBcIiZ4b3BmO1wiXSwgWzAsIFwiJnlvcGY7XCJdLCBbMCwgXCImem9wZjtcIl1dKSkgfV0sIFs4OTA2LCBcIiZmZmxpZztcIl0sIFswLCBcIiZmaWxpZztcIl0sIFswLCBcIiZmbGxpZztcIl0sIFswLCBcIiZmZmlsaWc7XCJdLCBbMCwgXCImZmZsbGlnO1wiXV0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY29kZS1odG1sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVYTUxTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw1U3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDUgPSBleHBvcnRzLmRlY29kZUhUTUw0ID0gZXhwb3J0cy5kZWNvZGVIVE1MQXR0cmlidXRlID0gZXhwb3J0cy5kZWNvZGVIVE1MU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MID0gZXhwb3J0cy5kZWNvZGVYTUwgPSBleHBvcnRzLkRlY29kaW5nTW9kZSA9IGV4cG9ydHMuRW50aXR5RGVjb2RlciA9IGV4cG9ydHMuZW5jb2RlSFRNTDUgPSBleHBvcnRzLmVuY29kZUhUTUw0ID0gZXhwb3J0cy5lbmNvZGVOb25Bc2NpaUhUTUwgPSBleHBvcnRzLmVuY29kZUhUTUwgPSBleHBvcnRzLmVzY2FwZVRleHQgPSBleHBvcnRzLmVzY2FwZUF0dHJpYnV0ZSA9IGV4cG9ydHMuZXNjYXBlVVRGOCA9IGV4cG9ydHMuZXNjYXBlID0gZXhwb3J0cy5lbmNvZGVYTUwgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLkVuY29kaW5nTW9kZSA9IGV4cG9ydHMuRW50aXR5TGV2ZWwgPSB2b2lkIDA7XG52YXIgZGVjb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9kZWNvZGUuanNcIik7XG52YXIgZW5jb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9lbmNvZGUuanNcIik7XG52YXIgZXNjYXBlX2pzXzEgPSByZXF1aXJlKFwiLi9lc2NhcGUuanNcIik7XG4vKiogVGhlIGxldmVsIG9mIGVudGl0aWVzIHRvIHN1cHBvcnQuICovXG52YXIgRW50aXR5TGV2ZWw7XG4oZnVuY3Rpb24gKEVudGl0eUxldmVsKSB7XG4gICAgLyoqIFN1cHBvcnQgb25seSBYTUwgZW50aXRpZXMuICovXG4gICAgRW50aXR5TGV2ZWxbRW50aXR5TGV2ZWxbXCJYTUxcIl0gPSAwXSA9IFwiWE1MXCI7XG4gICAgLyoqIFN1cHBvcnQgSFRNTCBlbnRpdGllcywgd2hpY2ggYXJlIGEgc3VwZXJzZXQgb2YgWE1MIGVudGl0aWVzLiAqL1xuICAgIEVudGl0eUxldmVsW0VudGl0eUxldmVsW1wiSFRNTFwiXSA9IDFdID0gXCJIVE1MXCI7XG59KShFbnRpdHlMZXZlbCA9IGV4cG9ydHMuRW50aXR5TGV2ZWwgfHwgKGV4cG9ydHMuRW50aXR5TGV2ZWwgPSB7fSkpO1xudmFyIEVuY29kaW5nTW9kZTtcbihmdW5jdGlvbiAoRW5jb2RpbmdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBpcyBVVEYtOCBlbmNvZGVkLiBPbmx5IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGVzY2FwaW5nIHdpdGhpblxuICAgICAqIFhNTCB3aWxsIGJlIGVzY2FwZWQuXG4gICAgICovXG4gICAgRW5jb2RpbmdNb2RlW0VuY29kaW5nTW9kZVtcIlVURjhcIl0gPSAwXSA9IFwiVVRGOFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgY29uc2lzdHMgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzLiBDaGFyYWN0ZXJzIHRoYXQgbmVlZFxuICAgICAqIGVzY2FwaW5nIHdpdGhpbiBIVE1MLCBhbmQgY2hhcmFjdGVycyB0aGF0IGFyZW4ndCBBU0NJSSBjaGFyYWN0ZXJzIHdpbGxcbiAgICAgKiBiZSBlc2NhcGVkLlxuICAgICAqL1xuICAgIEVuY29kaW5nTW9kZVtFbmNvZGluZ01vZGVbXCJBU0NJSVwiXSA9IDFdID0gXCJBU0NJSVwiO1xuICAgIC8qKlxuICAgICAqIEVuY29kZSBhbGwgY2hhcmFjdGVycyB0aGF0IGhhdmUgYW4gZXF1aXZhbGVudCBlbnRpdHksIGFzIHdlbGwgYXMgYWxsXG4gICAgICogY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgQVNDSUkgY2hhcmFjdGVycy5cbiAgICAgKi9cbiAgICBFbmNvZGluZ01vZGVbRW5jb2RpbmdNb2RlW1wiRXh0ZW5zaXZlXCJdID0gMl0gPSBcIkV4dGVuc2l2ZVwiO1xuICAgIC8qKlxuICAgICAqIEVuY29kZSBhbGwgY2hhcmFjdGVycyB0aGF0IGhhdmUgdG8gYmUgZXNjYXBlZCBpbiBIVE1MIGF0dHJpYnV0ZXMsXG4gICAgICogZm9sbG93aW5nIHtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjZXNjYXBpbmdTdHJpbmd9LlxuICAgICAqL1xuICAgIEVuY29kaW5nTW9kZVtFbmNvZGluZ01vZGVbXCJBdHRyaWJ1dGVcIl0gPSAzXSA9IFwiQXR0cmlidXRlXCI7XG4gICAgLyoqXG4gICAgICogRW5jb2RlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSB0byBiZSBlc2NhcGVkIGluIEhUTUwgdGV4dCxcbiAgICAgKiBmb2xsb3dpbmcge0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNlc2NhcGluZ1N0cmluZ30uXG4gICAgICovXG4gICAgRW5jb2RpbmdNb2RlW0VuY29kaW5nTW9kZVtcIlRleHRcIl0gPSA0XSA9IFwiVGV4dFwiO1xufSkoRW5jb2RpbmdNb2RlID0gZXhwb3J0cy5FbmNvZGluZ01vZGUgfHwgKGV4cG9ydHMuRW5jb2RpbmdNb2RlID0ge30pKTtcbi8qKlxuICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyBEZWNvZGluZyBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWNvZGUoZGF0YSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IEVudGl0eUxldmVsLlhNTDsgfVxuICAgIHZhciBsZXZlbCA9IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID8gb3B0aW9ucyA6IG9wdGlvbnMubGV2ZWw7XG4gICAgaWYgKGxldmVsID09PSBFbnRpdHlMZXZlbC5IVE1MKSB7XG4gICAgICAgIHZhciBtb2RlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLm1vZGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAoMCwgZGVjb2RlX2pzXzEuZGVjb2RlSFRNTCkoZGF0YSwgbW9kZSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZGVjb2RlX2pzXzEuZGVjb2RlWE1MKShkYXRhKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqXG4gKiBEZWNvZGVzIGEgc3RyaW5nIHdpdGggZW50aXRpZXMuIERvZXMgbm90IGFsbG93IG1pc3NpbmcgdHJhaWxpbmcgc2VtaWNvbG9ucyBmb3IgZW50aXRpZXMuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIERlY29kaW5nIG9wdGlvbnMuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZWAgd2l0aCB0aGUgYG1vZGVgIHNldCB0byBgU3RyaWN0YC5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlU3RyaWN0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRW50aXR5TGV2ZWwuWE1MOyB9XG4gICAgdmFyIG9wdHMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/IHsgbGV2ZWw6IG9wdGlvbnMgfSA6IG9wdGlvbnM7XG4gICAgKF9hID0gb3B0cy5tb2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAob3B0cy5tb2RlID0gZGVjb2RlX2pzXzEuRGVjb2RpbmdNb2RlLlN0cmljdCk7XG4gICAgcmV0dXJuIGRlY29kZShkYXRhLCBvcHRzKTtcbn1cbmV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZGVjb2RlU3RyaWN0O1xuLyoqXG4gKiBFbmNvZGVzIGEgc3RyaW5nIHdpdGggZW50aXRpZXMuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIEVuY29kaW5nIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRW50aXR5TGV2ZWwuWE1MOyB9XG4gICAgdmFyIG9wdHMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/IHsgbGV2ZWw6IG9wdGlvbnMgfSA6IG9wdGlvbnM7XG4gICAgLy8gTW9kZSBgVVRGOGAganVzdCBlc2NhcGVzIFhNTCBlbnRpdGllc1xuICAgIGlmIChvcHRzLm1vZGUgPT09IEVuY29kaW5nTW9kZS5VVEY4KVxuICAgICAgICByZXR1cm4gKDAsIGVzY2FwZV9qc18xLmVzY2FwZVVURjgpKGRhdGEpO1xuICAgIGlmIChvcHRzLm1vZGUgPT09IEVuY29kaW5nTW9kZS5BdHRyaWJ1dGUpXG4gICAgICAgIHJldHVybiAoMCwgZXNjYXBlX2pzXzEuZXNjYXBlQXR0cmlidXRlKShkYXRhKTtcbiAgICBpZiAob3B0cy5tb2RlID09PSBFbmNvZGluZ01vZGUuVGV4dClcbiAgICAgICAgcmV0dXJuICgwLCBlc2NhcGVfanNfMS5lc2NhcGVUZXh0KShkYXRhKTtcbiAgICBpZiAob3B0cy5sZXZlbCA9PT0gRW50aXR5TGV2ZWwuSFRNTCkge1xuICAgICAgICBpZiAob3B0cy5tb2RlID09PSBFbmNvZGluZ01vZGUuQVNDSUkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZW5jb2RlX2pzXzEuZW5jb2RlTm9uQXNjaWlIVE1MKShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGVuY29kZV9qc18xLmVuY29kZUhUTUwpKGRhdGEpO1xuICAgIH1cbiAgICAvLyBBU0NJSSBhbmQgRXh0ZW5zaXZlIGFyZSBlcXVpdmFsZW50XG4gICAgcmV0dXJuICgwLCBlc2NhcGVfanNfMS5lbmNvZGVYTUwpKGRhdGEpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG52YXIgZXNjYXBlX2pzXzIgPSByZXF1aXJlKFwiLi9lc2NhcGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVYTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVzY2FwZV9qc18yLmVuY29kZVhNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXNjYXBlX2pzXzIuZXNjYXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlVVRGOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXNjYXBlX2pzXzIuZXNjYXBlVVRGODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZUF0dHJpYnV0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXNjYXBlX2pzXzIuZXNjYXBlQXR0cmlidXRlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlVGV4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXNjYXBlX2pzXzIuZXNjYXBlVGV4dDsgfSB9KTtcbnZhciBlbmNvZGVfanNfMiA9IHJlcXVpcmUoXCIuL2VuY29kZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV9qc18yLmVuY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVOb25Bc2NpaUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV9qc18yLmVuY29kZU5vbkFzY2lpSFRNTDsgfSB9KTtcbi8vIExlZ2FjeSBhbGlhc2VzIChkZXByZWNhdGVkKVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlSFRNTDRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV9qc18yLmVuY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MNVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlX2pzXzIuZW5jb2RlSFRNTDsgfSB9KTtcbnZhciBkZWNvZGVfanNfMiA9IHJlcXVpcmUoXCIuL2RlY29kZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVudGl0eURlY29kZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV9qc18yLkVudGl0eURlY29kZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNvZGluZ01vZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV9qc18yLkRlY29kaW5nTW9kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVhNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlX2pzXzIuZGVjb2RlWE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlX2pzXzIuZGVjb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUxTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV9qc18yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MQXR0cmlidXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfanNfMi5kZWNvZGVIVE1MQXR0cmlidXRlOyB9IH0pO1xuLy8gTGVnYWN5IGFsaWFzZXMgKGRlcHJlY2F0ZWQpXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlX2pzXzIuZGVjb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfanNfMi5kZWNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDRTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV9qc18yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNVN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlX2pzXzIuZGVjb2RlSFRNTFN0cmljdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVhNTFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlX2pzXzIuZGVjb2RlWE1MOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZyA9PiB7XG5cdGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHQvLyBFc2NhcGUgY2hhcmFjdGVycyB3aXRoIHNwZWNpYWwgbWVhbmluZyBlaXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgY2hhcmFjdGVyIHNldHMuXG5cdC8vIFVzZSBhIHNpbXBsZSBiYWNrc2xhc2ggZXNjYXBlIHdoZW4gaXTigJlzIGFsd2F5cyB2YWxpZCwgYW5kIGEgXFx1bm5ubiBlc2NhcGUgd2hlbiB0aGUgc2ltcGxlciBmb3JtIHdvdWxkIGJlIGRpc2FsbG93ZWQgYnkgVW5pY29kZSBwYXR0ZXJuc+KAmSBzdHJpY3RlciBncmFtbWFyLlxuXHRyZXR1cm4gc3RyaW5nXG5cdFx0LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCAnXFxcXCQmJylcblx0XHQucmVwbGFjZSgvLS9nLCAnXFxcXHgyZCcpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcnNlciA9IHZvaWQgMDtcbnZhciBUb2tlbml6ZXJfanNfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9Ub2tlbml6ZXIuanNcIikpO1xudmFyIGRlY29kZV9qc18xID0gcmVxdWlyZShcImVudGl0aWVzL2xpYi9kZWNvZGUuanNcIik7XG52YXIgZm9ybVRhZ3MgPSBuZXcgU2V0KFtcbiAgICBcImlucHV0XCIsXG4gICAgXCJvcHRpb25cIixcbiAgICBcIm9wdGdyb3VwXCIsXG4gICAgXCJzZWxlY3RcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwiZGF0YWxpc3RcIixcbiAgICBcInRleHRhcmVhXCIsXG5dKTtcbnZhciBwVGFnID0gbmV3IFNldChbXCJwXCJdKTtcbnZhciB0YWJsZVNlY3Rpb25UYWdzID0gbmV3IFNldChbXCJ0aGVhZFwiLCBcInRib2R5XCJdKTtcbnZhciBkZHRUYWdzID0gbmV3IFNldChbXCJkZFwiLCBcImR0XCJdKTtcbnZhciBydHBUYWdzID0gbmV3IFNldChbXCJydFwiLCBcInJwXCJdKTtcbnZhciBvcGVuSW1wbGllc0Nsb3NlID0gbmV3IE1hcChbXG4gICAgW1widHJcIiwgbmV3IFNldChbXCJ0clwiLCBcInRoXCIsIFwidGRcIl0pXSxcbiAgICBbXCJ0aFwiLCBuZXcgU2V0KFtcInRoXCJdKV0sXG4gICAgW1widGRcIiwgbmV3IFNldChbXCJ0aGVhZFwiLCBcInRoXCIsIFwidGRcIl0pXSxcbiAgICBbXCJib2R5XCIsIG5ldyBTZXQoW1wiaGVhZFwiLCBcImxpbmtcIiwgXCJzY3JpcHRcIl0pXSxcbiAgICBbXCJsaVwiLCBuZXcgU2V0KFtcImxpXCJdKV0sXG4gICAgW1wicFwiLCBwVGFnXSxcbiAgICBbXCJoMVwiLCBwVGFnXSxcbiAgICBbXCJoMlwiLCBwVGFnXSxcbiAgICBbXCJoM1wiLCBwVGFnXSxcbiAgICBbXCJoNFwiLCBwVGFnXSxcbiAgICBbXCJoNVwiLCBwVGFnXSxcbiAgICBbXCJoNlwiLCBwVGFnXSxcbiAgICBbXCJzZWxlY3RcIiwgZm9ybVRhZ3NdLFxuICAgIFtcImlucHV0XCIsIGZvcm1UYWdzXSxcbiAgICBbXCJvdXRwdXRcIiwgZm9ybVRhZ3NdLFxuICAgIFtcImJ1dHRvblwiLCBmb3JtVGFnc10sXG4gICAgW1wiZGF0YWxpc3RcIiwgZm9ybVRhZ3NdLFxuICAgIFtcInRleHRhcmVhXCIsIGZvcm1UYWdzXSxcbiAgICBbXCJvcHRpb25cIiwgbmV3IFNldChbXCJvcHRpb25cIl0pXSxcbiAgICBbXCJvcHRncm91cFwiLCBuZXcgU2V0KFtcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCJdKV0sXG4gICAgW1wiZGRcIiwgZGR0VGFnc10sXG4gICAgW1wiZHRcIiwgZGR0VGFnc10sXG4gICAgW1wiYWRkcmVzc1wiLCBwVGFnXSxcbiAgICBbXCJhcnRpY2xlXCIsIHBUYWddLFxuICAgIFtcImFzaWRlXCIsIHBUYWddLFxuICAgIFtcImJsb2NrcXVvdGVcIiwgcFRhZ10sXG4gICAgW1wiZGV0YWlsc1wiLCBwVGFnXSxcbiAgICBbXCJkaXZcIiwgcFRhZ10sXG4gICAgW1wiZGxcIiwgcFRhZ10sXG4gICAgW1wiZmllbGRzZXRcIiwgcFRhZ10sXG4gICAgW1wiZmlnY2FwdGlvblwiLCBwVGFnXSxcbiAgICBbXCJmaWd1cmVcIiwgcFRhZ10sXG4gICAgW1wiZm9vdGVyXCIsIHBUYWddLFxuICAgIFtcImZvcm1cIiwgcFRhZ10sXG4gICAgW1wiaGVhZGVyXCIsIHBUYWddLFxuICAgIFtcImhyXCIsIHBUYWddLFxuICAgIFtcIm1haW5cIiwgcFRhZ10sXG4gICAgW1wibmF2XCIsIHBUYWddLFxuICAgIFtcIm9sXCIsIHBUYWddLFxuICAgIFtcInByZVwiLCBwVGFnXSxcbiAgICBbXCJzZWN0aW9uXCIsIHBUYWddLFxuICAgIFtcInRhYmxlXCIsIHBUYWddLFxuICAgIFtcInVsXCIsIHBUYWddLFxuICAgIFtcInJ0XCIsIHJ0cFRhZ3NdLFxuICAgIFtcInJwXCIsIHJ0cFRhZ3NdLFxuICAgIFtcInRib2R5XCIsIHRhYmxlU2VjdGlvblRhZ3NdLFxuICAgIFtcInRmb290XCIsIHRhYmxlU2VjdGlvblRhZ3NdLFxuXSk7XG52YXIgdm9pZEVsZW1lbnRzID0gbmV3IFNldChbXG4gICAgXCJhcmVhXCIsXG4gICAgXCJiYXNlXCIsXG4gICAgXCJiYXNlZm9udFwiLFxuICAgIFwiYnJcIixcbiAgICBcImNvbFwiLFxuICAgIFwiY29tbWFuZFwiLFxuICAgIFwiZW1iZWRcIixcbiAgICBcImZyYW1lXCIsXG4gICAgXCJoclwiLFxuICAgIFwiaW1nXCIsXG4gICAgXCJpbnB1dFwiLFxuICAgIFwiaXNpbmRleFwiLFxuICAgIFwia2V5Z2VuXCIsXG4gICAgXCJsaW5rXCIsXG4gICAgXCJtZXRhXCIsXG4gICAgXCJwYXJhbVwiLFxuICAgIFwic291cmNlXCIsXG4gICAgXCJ0cmFja1wiLFxuICAgIFwid2JyXCIsXG5dKTtcbnZhciBmb3JlaWduQ29udGV4dEVsZW1lbnRzID0gbmV3IFNldChbXCJtYXRoXCIsIFwic3ZnXCJdKTtcbnZhciBodG1sSW50ZWdyYXRpb25FbGVtZW50cyA9IG5ldyBTZXQoW1xuICAgIFwibWlcIixcbiAgICBcIm1vXCIsXG4gICAgXCJtblwiLFxuICAgIFwibXNcIixcbiAgICBcIm10ZXh0XCIsXG4gICAgXCJhbm5vdGF0aW9uLXhtbFwiLFxuICAgIFwiZm9yZWlnbm9iamVjdFwiLFxuICAgIFwiZGVzY1wiLFxuICAgIFwidGl0bGVcIixcbl0pO1xudmFyIHJlTmFtZUVuZCA9IC9cXHN8XFwvLztcbnZhciBQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKGNicywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvKiogVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBsYXN0IGV2ZW50LiAqL1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAvKiogVGhlIGVuZCBpbmRleCBvZiB0aGUgbGFzdCBldmVudC4gKi9cbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZSB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIGN1cnJlbnQgb3BlbiB0YWcsXG4gICAgICAgICAqIHNvIHdlIGNhbiB1cGRhdGUgdGhlIHN0YXJ0IGluZGV4IGZvciBhdHRyaWJ1dGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuVGFnU3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnRhZ25hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5hdHRyaWJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLmZvcmVpZ25Db250ZXh0ID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGxhc3Qgd3JpdHRlbiBidWZmZXIuIFVzZWQgd2hlbiByZXN1bWluZyBhZnRlciBhIGBwYXVzZSgpYC4gKi9cbiAgICAgICAgdGhpcy53cml0ZUluZGV4ID0gMDtcbiAgICAgICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwYXJzZXIgaGFzIGZpbmlzaGVkIHJ1bm5pbmcgLyBgLmVuZGAgaGFzIGJlZW4gY2FsbGVkLiAqL1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2JzID0gY2JzICE9PSBudWxsICYmIGNicyAhPT0gdm9pZCAwID8gY2JzIDoge307XG4gICAgICAgIHRoaXMubG93ZXJDYXNlVGFnTmFtZXMgPSAoX2EgPSBvcHRpb25zLmxvd2VyQ2FzZVRhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICFvcHRpb25zLnhtbE1vZGU7XG4gICAgICAgIHRoaXMubG93ZXJDYXNlQXR0cmlidXRlTmFtZXMgPVxuICAgICAgICAgICAgKF9iID0gb3B0aW9ucy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogIW9wdGlvbnMueG1sTW9kZTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSBuZXcgKChfYyA9IG9wdGlvbnMuVG9rZW5pemVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBUb2tlbml6ZXJfanNfMS5kZWZhdWx0KSh0aGlzLm9wdGlvbnMsIHRoaXMpO1xuICAgICAgICAoX2UgPSAoX2QgPSB0aGlzLmNicykub25wYXJzZXJpbml0KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCwgdGhpcyk7XG4gICAgfVxuICAgIC8vIFRva2VuaXplciBldmVudCBoYW5kbGVyc1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9udGV4dCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBlbmRJbmRleCk7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleCAtIDE7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBkYXRhKTtcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXg7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbnRleHRlbnRpdHkgPSBmdW5jdGlvbiAoY3ApIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLypcbiAgICAgICAgICogRW50aXRpZXMgY2FuIGJlIGVtaXR0ZWQgb24gdGhlIGNoYXJhY3Rlciwgb3IgZGlyZWN0bHkgYWZ0ZXIuXG4gICAgICAgICAqIFdlIHVzZSB0aGUgc2VjdGlvbiBzdGFydCBoZXJlIHRvIGdldCBhY2N1cmF0ZSBpbmRpY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy50b2tlbml6ZXIuZ2V0U2VjdGlvblN0YXJ0KCk7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBpbmRleCAtIDE7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAoMCwgZGVjb2RlX2pzXzEuZnJvbUNvZGVQb2ludCkoY3ApKTtcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gaW5kZXg7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmlzVm9pZEVsZW1lbnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gIXRoaXMub3B0aW9ucy54bWxNb2RlICYmIHZvaWRFbGVtZW50cy5oYXMobmFtZSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbm9wZW50YWduYW1lID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRPcGVuVGFnKG5hbWUpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5lbWl0T3BlblRhZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5vcGVuVGFnU3RhcnQgPSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IG5hbWU7XG4gICAgICAgIHZhciBpbXBsaWVzQ2xvc2UgPSAhdGhpcy5vcHRpb25zLnhtbE1vZGUgJiYgb3BlbkltcGxpZXNDbG9zZS5nZXQobmFtZSk7XG4gICAgICAgIGlmIChpbXBsaWVzQ2xvc2UpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBpbXBsaWVzQ2xvc2UuaGFzKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uY2xvc2V0YWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNWb2lkRWxlbWVudChuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGZvcmVpZ25Db250ZXh0RWxlbWVudHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dC5wdXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaHRtbEludGVncmF0aW9uRWxlbWVudHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dC5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub25vcGVudGFnbmFtZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIG5hbWUpO1xuICAgICAgICBpZiAodGhpcy5jYnMub25vcGVudGFnKVxuICAgICAgICAgICAgdGhpcy5hdHRyaWJzID0ge307XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmVuZE9wZW5UYWcgPSBmdW5jdGlvbiAoaXNJbXBsaWVkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHRoaXMub3BlblRhZ1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5hdHRyaWJzKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25vcGVudGFnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcy50YWduYW1lLCB0aGlzLmF0dHJpYnMsIGlzSW1wbGllZCk7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNicy5vbmNsb3NldGFnICYmIHRoaXMuaXNWb2lkRWxlbWVudCh0aGlzLnRhZ25hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmNsb3NldGFnKHRoaXMudGFnbmFtZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YWduYW1lID0gXCJcIjtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9ub3BlbnRhZ2VuZCA9IGZ1bmN0aW9uIChlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHRoaXMuZW5kT3BlblRhZyhmYWxzZSk7XG4gICAgICAgIC8vIFNldCBgc3RhcnRJbmRleGAgZm9yIG5leHQgbm9kZVxuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmNsb3NldGFnID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMubG93ZXJDYXNlVGFnTmFtZXMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcmVpZ25Db250ZXh0RWxlbWVudHMuaGFzKG5hbWUpIHx8XG4gICAgICAgICAgICBodG1sSW50ZWdyYXRpb25FbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzVm9pZEVsZW1lbnQobmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnN0YWNrLmxhc3RJbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYnMub25jbG9zZXRhZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIHBvcztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIHN0YWNrIGhhcyBzdWZmaWNpZW50IGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYnMub25jbG9zZXRhZyh0aGlzLnN0YWNrLnBvcCgpLCBjb3VudCAhPT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMueG1sTW9kZSAmJiBuYW1lID09PSBcInBcIikge1xuICAgICAgICAgICAgICAgIC8vIEltcGxpY2l0IG9wZW4gYmVmb3JlIGNsb3NlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0T3BlblRhZyhcInBcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUN1cnJlbnRUYWcodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMub3B0aW9ucy54bWxNb2RlICYmIG5hbWUgPT09IFwiYnJcIikge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIGBlbWl0T3BlblRhZ2AgZm9yIGltcGxpY2l0IG9wZW4sIGFzIGBicmAgd291bGQgYmUgaW1wbGljaXRseSBjbG9zZWQuXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25vcGVudGFnbmFtZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIFwiYnJcIik7XG4gICAgICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub25vcGVudGFnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgXCJiclwiLCB7fSwgdHJ1ZSk7XG4gICAgICAgICAgICAoX2YgPSAoX2UgPSB0aGlzLmNicykub25jbG9zZXRhZykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UsIFwiYnJcIiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBgc3RhcnRJbmRleGAgZm9yIG5leHQgbm9kZVxuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbnNlbGZjbG9zaW5ndGFnID0gZnVuY3Rpb24gKGVuZEluZGV4KSB7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy54bWxNb2RlIHx8XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVjb2duaXplU2VsZkNsb3NpbmcgfHxcbiAgICAgICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHRbdGhpcy5mb3JlaWduQ29udGV4dC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUN1cnJlbnRUYWcoZmFsc2UpO1xuICAgICAgICAgICAgLy8gU2V0IGBzdGFydEluZGV4YCBmb3IgbmV4dCBub2RlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZy5cbiAgICAgICAgICAgIHRoaXMub25vcGVudGFnZW5kKGVuZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5jbG9zZUN1cnJlbnRUYWcgPSBmdW5jdGlvbiAoaXNPcGVuSW1wbGllZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGFnbmFtZTtcbiAgICAgICAgdGhpcy5lbmRPcGVuVGFnKGlzT3BlbkltcGxpZWQpO1xuICAgICAgICAvLyBTZWxmLWNsb3NpbmcgdGFncyB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvcGVuaW5nIHRhZyBpc24ndCBpbXBsaWVkLCB0aGUgY2xvc2luZyB0YWcgaGFzIHRvIGJlIGltcGxpZWQuXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jbG9zZXRhZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5hbWUsICFpc09wZW5JbXBsaWVkKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9uYXR0cmlibmFtZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kSW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnQ7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICB0aGlzLmF0dHJpYm5hbWUgPSB0aGlzLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzXG4gICAgICAgICAgICA/IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgOiBuYW1lO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUub25hdHRyaWJkYXRhID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmF0dHJpYnZhbHVlICs9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9uYXR0cmliZW50aXR5ID0gZnVuY3Rpb24gKGNwKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidmFsdWUgKz0gKDAsIGRlY29kZV9qc18xLmZyb21Db2RlUG9pbnQpKGNwKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9uYXR0cmliZW5kID0gZnVuY3Rpb24gKHF1b3RlLCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMuYXR0cmlibmFtZSwgdGhpcy5hdHRyaWJ2YWx1ZSwgcXVvdGUgPT09IFRva2VuaXplcl9qc18xLlF1b3RlVHlwZS5Eb3VibGVcbiAgICAgICAgICAgID8gJ1wiJ1xuICAgICAgICAgICAgOiBxdW90ZSA9PT0gVG9rZW5pemVyX2pzXzEuUXVvdGVUeXBlLlNpbmdsZVxuICAgICAgICAgICAgICAgID8gXCInXCJcbiAgICAgICAgICAgICAgICA6IHF1b3RlID09PSBUb2tlbml6ZXJfanNfMS5RdW90ZVR5cGUuTm9WYWx1ZVxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IG51bGwpO1xuICAgICAgICBpZiAodGhpcy5hdHRyaWJzICYmXG4gICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlicywgdGhpcy5hdHRyaWJuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJzW3RoaXMuYXR0cmlibmFtZV0gPSB0aGlzLmF0dHJpYnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0cmlidmFsdWUgPSBcIlwiO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5nZXRJbnN0cnVjdGlvbk5hbWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdmFsdWUuc2VhcmNoKHJlTmFtZUVuZCk7XG4gICAgICAgIHZhciBuYW1lID0gaW5kZXggPCAwID8gdmFsdWUgOiB2YWx1ZS5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9uZGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZEluZGV4KSB7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXRJbnN0cnVjdGlvbk5hbWUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24oXCIhXCIuY29uY2F0KG5hbWUpLCBcIiFcIi5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZEluZGV4KSB7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXRJbnN0cnVjdGlvbk5hbWUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24oXCI/XCIuY29uY2F0KG5hbWUpLCBcIj9cIi5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUub25jb21tZW50ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmRJbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jb21tZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXggLSBvZmZzZXQpKTtcbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYnMpLm9uY29tbWVudGVuZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUub25jZGF0YSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kSW5kZXgsIG9mZnNldCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXggLSBvZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnhtbE1vZGUgfHwgdGhpcy5vcHRpb25zLnJlY29nbml6ZUNEQVRBKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jZGF0YXN0YXJ0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub250ZXh0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdmFsdWUpO1xuICAgICAgICAgICAgKF9mID0gKF9lID0gdGhpcy5jYnMpLm9uY2RhdGFlbmQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfaCA9IChfZyA9IHRoaXMuY2JzKS5vbmNvbW1lbnQpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5jYWxsKF9nLCBcIltDREFUQVtcIi5jb25jYXQodmFsdWUsIFwiXV1cIikpO1xuICAgICAgICAgICAgKF9rID0gKF9qID0gdGhpcy5jYnMpLm9uY29tbWVudGVuZCkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmNhbGwoX2opO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBgc3RhcnRJbmRleGAgZm9yIG5leHQgbm9kZVxuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuY2JzLm9uY2xvc2V0YWcpIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZW5kIGluZGV4IGZvciBhbGwgcmVtYWluaW5nIHRhZ3NcbiAgICAgICAgICAgIHRoaXMuZW5kSW5kZXggPSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IHRoaXMuc3RhY2subGVuZ3RoOyBpbmRleCA+IDA7IHRoaXMuY2JzLm9uY2xvc2V0YWcodGhpcy5zdGFja1stLWluZGV4XSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmVuZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBwYXJzZXIgdG8gYSBibGFuayBzdGF0ZSwgcmVhZHkgdG8gcGFyc2UgYSBuZXcgSFRNTCBkb2N1bWVudFxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9ucmVzZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy50YWduYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5hdHRyaWJuYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5hdHRyaWJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gMDtcbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYnMpLm9ucGFyc2VyaW5pdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIHRoaXMpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLndyaXRlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHBhcnNlciwgdGhlbiBwYXJzZXMgYSBjb21wbGV0ZSBkb2N1bWVudCBhbmRcbiAgICAgKiBwdXNoZXMgaXQgdG8gdGhlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBEb2N1bWVudCB0byBwYXJzZS5cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcGxldGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZW5kKGRhdGEpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5nZXRTbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHdoaWxlIChzdGFydCAtIHRoaXMuYnVmZmVyT2Zmc2V0ID49IHRoaXMuYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2xpY2UgPSB0aGlzLmJ1ZmZlcnNbMF0uc2xpY2Uoc3RhcnQgLSB0aGlzLmJ1ZmZlck9mZnNldCwgZW5kIC0gdGhpcy5idWZmZXJPZmZzZXQpO1xuICAgICAgICB3aGlsZSAoZW5kIC0gdGhpcy5idWZmZXJPZmZzZXQgPiB0aGlzLmJ1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0QnVmZmVyKCk7XG4gICAgICAgICAgICBzbGljZSArPSB0aGlzLmJ1ZmZlcnNbMF0uc2xpY2UoMCwgZW5kIC0gdGhpcy5idWZmZXJPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuc2hpZnRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ICs9IHRoaXMuYnVmZmVyc1swXS5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVJbmRleC0tO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuc2hpZnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNodW5rIG9mIGRhdGEgYW5kIGNhbGxzIHRoZSBjb3JyZXNwb25kaW5nIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaHVuayBDaHVuayB0byBwYXJzZS5cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25lcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5ldyBFcnJvcihcIi53cml0ZSgpIGFmdGVyIGRvbmUhXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnRva2VuaXplci5ydW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuaXplci53cml0ZShjaHVuayk7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXgrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBhbmQgY2xlYXJzIHRoZSBzdGFjaywgY2FsbHMgb25lbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2h1bmsgT3B0aW9uYWwgZmluYWwgY2h1bmsgdG8gcGFyc2UuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbmV3IEVycm9yKFwiLmVuZCgpIGFmdGVyIGRvbmUhXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmspXG4gICAgICAgICAgICB0aGlzLndyaXRlKGNodW5rKTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLmVuZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHBhcnNpbmcuIFRoZSBwYXJzZXIgd29uJ3QgZW1pdCBldmVudHMgdW50aWwgYHJlc3VtZWAgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnBhdXNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHBhcnNpbmcgYWZ0ZXIgYHBhdXNlYCB3YXMgY2FsbGVkLlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRva2VuaXplci5yZXN1bWUoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMudG9rZW5pemVyLnJ1bm5pbmcgJiZcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleCA8IHRoaXMuYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLndyaXRlKHRoaXMuYnVmZmVyc1t0aGlzLndyaXRlSW5kZXgrK10pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuZW5kKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBgd3JpdGVgLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2h1bmsgQ2h1bmsgdG8gcGFyc2UuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBgZW5kYCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIE9wdGlvbmFsIGZpbmFsIGNodW5rIHRvIHBhcnNlLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW5kKGNodW5rKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1b3RlVHlwZSA9IHZvaWQgMDtcbnZhciBkZWNvZGVfanNfMSA9IHJlcXVpcmUoXCJlbnRpdGllcy9saWIvZGVjb2RlLmpzXCIpO1xudmFyIENoYXJDb2RlcztcbihmdW5jdGlvbiAoQ2hhckNvZGVzKSB7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlRhYlwiXSA9IDldID0gXCJUYWJcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTmV3TGluZVwiXSA9IDEwXSA9IFwiTmV3TGluZVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJGb3JtRmVlZFwiXSA9IDEyXSA9IFwiRm9ybUZlZWRcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiQ2FycmlhZ2VSZXR1cm5cIl0gPSAxM10gPSBcIkNhcnJpYWdlUmV0dXJuXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJFeGNsYW1hdGlvbk1hcmtcIl0gPSAzM10gPSBcIkV4Y2xhbWF0aW9uTWFya1wiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJOdW1iZXJcIl0gPSAzNV0gPSBcIk51bWJlclwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJBbXBcIl0gPSAzOF0gPSBcIkFtcFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJTaW5nbGVRdW90ZVwiXSA9IDM5XSA9IFwiU2luZ2xlUXVvdGVcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiRG91YmxlUXVvdGVcIl0gPSAzNF0gPSBcIkRvdWJsZVF1b3RlXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkRhc2hcIl0gPSA0NV0gPSBcIkRhc2hcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiU2xhc2hcIl0gPSA0N10gPSBcIlNsYXNoXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlplcm9cIl0gPSA0OF0gPSBcIlplcm9cIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTmluZVwiXSA9IDU3XSA9IFwiTmluZVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJTZW1pXCJdID0gNTldID0gXCJTZW1pXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkx0XCJdID0gNjBdID0gXCJMdFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJFcVwiXSA9IDYxXSA9IFwiRXFcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiR3RcIl0gPSA2Ml0gPSBcIkd0XCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlF1ZXN0aW9ubWFya1wiXSA9IDYzXSA9IFwiUXVlc3Rpb25tYXJrXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlVwcGVyQVwiXSA9IDY1XSA9IFwiVXBwZXJBXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkxvd2VyQVwiXSA9IDk3XSA9IFwiTG93ZXJBXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlVwcGVyRlwiXSA9IDcwXSA9IFwiVXBwZXJGXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkxvd2VyRlwiXSA9IDEwMl0gPSBcIkxvd2VyRlwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJVcHBlclpcIl0gPSA5MF0gPSBcIlVwcGVyWlwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMb3dlclpcIl0gPSAxMjJdID0gXCJMb3dlclpcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTG93ZXJYXCJdID0gMTIwXSA9IFwiTG93ZXJYXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIk9wZW5pbmdTcXVhcmVCcmFja2V0XCJdID0gOTFdID0gXCJPcGVuaW5nU3F1YXJlQnJhY2tldFwiO1xufSkoQ2hhckNvZGVzIHx8IChDaGFyQ29kZXMgPSB7fSkpO1xuLyoqIEFsbCB0aGUgc3RhdGVzIHRoZSB0b2tlbml6ZXIgY2FuIGJlIGluLiAqL1xudmFyIFN0YXRlO1xuKGZ1bmN0aW9uIChTdGF0ZSkge1xuICAgIFN0YXRlW1N0YXRlW1wiVGV4dFwiXSA9IDFdID0gXCJUZXh0XCI7XG4gICAgU3RhdGVbU3RhdGVbXCJCZWZvcmVUYWdOYW1lXCJdID0gMl0gPSBcIkJlZm9yZVRhZ05hbWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluVGFnTmFtZVwiXSA9IDNdID0gXCJJblRhZ05hbWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluU2VsZkNsb3NpbmdUYWdcIl0gPSA0XSA9IFwiSW5TZWxmQ2xvc2luZ1RhZ1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlQ2xvc2luZ1RhZ05hbWVcIl0gPSA1XSA9IFwiQmVmb3JlQ2xvc2luZ1RhZ05hbWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluQ2xvc2luZ1RhZ05hbWVcIl0gPSA2XSA9IFwiSW5DbG9zaW5nVGFnTmFtZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQWZ0ZXJDbG9zaW5nVGFnTmFtZVwiXSA9IDddID0gXCJBZnRlckNsb3NpbmdUYWdOYW1lXCI7XG4gICAgLy8gQXR0cmlidXRlc1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlQXR0cmlidXRlTmFtZVwiXSA9IDhdID0gXCJCZWZvcmVBdHRyaWJ1dGVOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkF0dHJpYnV0ZU5hbWVcIl0gPSA5XSA9IFwiSW5BdHRyaWJ1dGVOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJBZnRlckF0dHJpYnV0ZU5hbWVcIl0gPSAxMF0gPSBcIkFmdGVyQXR0cmlidXRlTmFtZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlQXR0cmlidXRlVmFsdWVcIl0gPSAxMV0gPSBcIkJlZm9yZUF0dHJpYnV0ZVZhbHVlXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkF0dHJpYnV0ZVZhbHVlRHFcIl0gPSAxMl0gPSBcIkluQXR0cmlidXRlVmFsdWVEcVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5BdHRyaWJ1dGVWYWx1ZVNxXCJdID0gMTNdID0gXCJJbkF0dHJpYnV0ZVZhbHVlU3FcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluQXR0cmlidXRlVmFsdWVOcVwiXSA9IDE0XSA9IFwiSW5BdHRyaWJ1dGVWYWx1ZU5xXCI7XG4gICAgLy8gRGVjbGFyYXRpb25zXG4gICAgU3RhdGVbU3RhdGVbXCJCZWZvcmVEZWNsYXJhdGlvblwiXSA9IDE1XSA9IFwiQmVmb3JlRGVjbGFyYXRpb25cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluRGVjbGFyYXRpb25cIl0gPSAxNl0gPSBcIkluRGVjbGFyYXRpb25cIjtcbiAgICAvLyBQcm9jZXNzaW5nIGluc3RydWN0aW9uc1xuICAgIFN0YXRlW1N0YXRlW1wiSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIl0gPSAxN10gPSBcIkluUHJvY2Vzc2luZ0luc3RydWN0aW9uXCI7XG4gICAgLy8gQ29tbWVudHMgJiBDREFUQVxuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlQ29tbWVudFwiXSA9IDE4XSA9IFwiQmVmb3JlQ29tbWVudFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQ0RBVEFTZXF1ZW5jZVwiXSA9IDE5XSA9IFwiQ0RBVEFTZXF1ZW5jZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5TcGVjaWFsQ29tbWVudFwiXSA9IDIwXSA9IFwiSW5TcGVjaWFsQ29tbWVudFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5Db21tZW50TGlrZVwiXSA9IDIxXSA9IFwiSW5Db21tZW50TGlrZVwiO1xuICAgIC8vIFNwZWNpYWwgdGFnc1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlU3BlY2lhbFNcIl0gPSAyMl0gPSBcIkJlZm9yZVNwZWNpYWxTXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJTcGVjaWFsU3RhcnRTZXF1ZW5jZVwiXSA9IDIzXSA9IFwiU3BlY2lhbFN0YXJ0U2VxdWVuY2VcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluU3BlY2lhbFRhZ1wiXSA9IDI0XSA9IFwiSW5TcGVjaWFsVGFnXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJCZWZvcmVFbnRpdHlcIl0gPSAyNV0gPSBcIkJlZm9yZUVudGl0eVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlTnVtZXJpY0VudGl0eVwiXSA9IDI2XSA9IFwiQmVmb3JlTnVtZXJpY0VudGl0eVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5OYW1lZEVudGl0eVwiXSA9IDI3XSA9IFwiSW5OYW1lZEVudGl0eVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5OdW1lcmljRW50aXR5XCJdID0gMjhdID0gXCJJbk51bWVyaWNFbnRpdHlcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluSGV4RW50aXR5XCJdID0gMjldID0gXCJJbkhleEVudGl0eVwiO1xufSkoU3RhdGUgfHwgKFN0YXRlID0ge30pKTtcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKSB7XG4gICAgcmV0dXJuIChjID09PSBDaGFyQ29kZXMuU3BhY2UgfHxcbiAgICAgICAgYyA9PT0gQ2hhckNvZGVzLk5ld0xpbmUgfHxcbiAgICAgICAgYyA9PT0gQ2hhckNvZGVzLlRhYiB8fFxuICAgICAgICBjID09PSBDaGFyQ29kZXMuRm9ybUZlZWQgfHxcbiAgICAgICAgYyA9PT0gQ2hhckNvZGVzLkNhcnJpYWdlUmV0dXJuKTtcbn1cbmZ1bmN0aW9uIGlzRW5kT2ZUYWdTZWN0aW9uKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gQ2hhckNvZGVzLlNsYXNoIHx8IGMgPT09IENoYXJDb2Rlcy5HdCB8fCBpc1doaXRlc3BhY2UoYyk7XG59XG5mdW5jdGlvbiBpc051bWJlcihjKSB7XG4gICAgcmV0dXJuIGMgPj0gQ2hhckNvZGVzLlplcm8gJiYgYyA8PSBDaGFyQ29kZXMuTmluZTtcbn1cbmZ1bmN0aW9uIGlzQVNDSUlBbHBoYShjKSB7XG4gICAgcmV0dXJuICgoYyA+PSBDaGFyQ29kZXMuTG93ZXJBICYmIGMgPD0gQ2hhckNvZGVzLkxvd2VyWikgfHxcbiAgICAgICAgKGMgPj0gQ2hhckNvZGVzLlVwcGVyQSAmJiBjIDw9IENoYXJDb2Rlcy5VcHBlclopKTtcbn1cbmZ1bmN0aW9uIGlzSGV4RGlnaXQoYykge1xuICAgIHJldHVybiAoKGMgPj0gQ2hhckNvZGVzLlVwcGVyQSAmJiBjIDw9IENoYXJDb2Rlcy5VcHBlckYpIHx8XG4gICAgICAgIChjID49IENoYXJDb2Rlcy5Mb3dlckEgJiYgYyA8PSBDaGFyQ29kZXMuTG93ZXJGKSk7XG59XG52YXIgUXVvdGVUeXBlO1xuKGZ1bmN0aW9uIChRdW90ZVR5cGUpIHtcbiAgICBRdW90ZVR5cGVbUXVvdGVUeXBlW1wiTm9WYWx1ZVwiXSA9IDBdID0gXCJOb1ZhbHVlXCI7XG4gICAgUXVvdGVUeXBlW1F1b3RlVHlwZVtcIlVucXVvdGVkXCJdID0gMV0gPSBcIlVucXVvdGVkXCI7XG4gICAgUXVvdGVUeXBlW1F1b3RlVHlwZVtcIlNpbmdsZVwiXSA9IDJdID0gXCJTaW5nbGVcIjtcbiAgICBRdW90ZVR5cGVbUXVvdGVUeXBlW1wiRG91YmxlXCJdID0gM10gPSBcIkRvdWJsZVwiO1xufSkoUXVvdGVUeXBlID0gZXhwb3J0cy5RdW90ZVR5cGUgfHwgKGV4cG9ydHMuUXVvdGVUeXBlID0ge30pKTtcbi8qKlxuICogU2VxdWVuY2VzIHVzZWQgdG8gbWF0Y2ggbG9uZ2VyIHN0cmluZ3MuXG4gKlxuICogV2UgZG9uJ3QgaGF2ZSBgU2NyaXB0YCwgYFN0eWxlYCwgb3IgYFRpdGxlYCBoZXJlLiBJbnN0ZWFkLCB3ZSByZS11c2UgdGhlICpFbmRcbiAqIHNlcXVlbmNlcyB3aXRoIGFuIGluY3JlYXNlZCBvZmZzZXQuXG4gKi9cbnZhciBTZXF1ZW5jZXMgPSB7XG4gICAgQ2RhdGE6IG5ldyBVaW50OEFycmF5KFsweDQzLCAweDQ0LCAweDQxLCAweDU0LCAweDQxLCAweDViXSksXG4gICAgQ2RhdGFFbmQ6IG5ldyBVaW50OEFycmF5KFsweDVkLCAweDVkLCAweDNlXSksXG4gICAgQ29tbWVudEVuZDogbmV3IFVpbnQ4QXJyYXkoWzB4MmQsIDB4MmQsIDB4M2VdKSxcbiAgICBTY3JpcHRFbmQ6IG5ldyBVaW50OEFycmF5KFsweDNjLCAweDJmLCAweDczLCAweDYzLCAweDcyLCAweDY5LCAweDcwLCAweDc0XSksXG4gICAgU3R5bGVFbmQ6IG5ldyBVaW50OEFycmF5KFsweDNjLCAweDJmLCAweDczLCAweDc0LCAweDc5LCAweDZjLCAweDY1XSksXG4gICAgVGl0bGVFbmQ6IG5ldyBVaW50OEFycmF5KFsweDNjLCAweDJmLCAweDc0LCAweDY5LCAweDc0LCAweDZjLCAweDY1XSksIC8vIGA8L3RpdGxlYFxufTtcbnZhciBUb2tlbml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9rZW5pemVyKF9hLCBjYnMpIHtcbiAgICAgICAgdmFyIF9iID0gX2EueG1sTW9kZSwgeG1sTW9kZSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IF9hLmRlY29kZUVudGl0aWVzLCBkZWNvZGVFbnRpdGllcyA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2M7XG4gICAgICAgIHRoaXMuY2JzID0gY2JzO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgdGhlIHRva2VuaXplciBpcyBpbi4gKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgIC8qKiBUaGUgcmVhZCBidWZmZXIuICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgLyoqIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY3Rpb24gdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC4gKi9cbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgICAvKiogVGhlIGluZGV4IHdpdGhpbiB0aGUgYnVmZmVyIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBsb29raW5nIGF0LiAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLyoqIFNvbWUgYmVoYXZpb3IsIGVnLiB3aGVuIGRlY29kaW5nIGVudGl0aWVzLCBpcyBkb25lIHdoaWxlIHdlIGFyZSBpbiBhbm90aGVyIHN0YXRlLiBUaGlzIGtlZXBzIHRyYWNrIG9mIHRoZSBvdGhlciBzdGF0ZSB0eXBlLiAqL1xuICAgICAgICB0aGlzLmJhc2VTdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgIC8qKiBGb3Igc3BlY2lhbCBwYXJzaW5nIGJlaGF2aW9yIGluc2lkZSBvZiBzY3JpcHQgYW5kIHN0eWxlIHRhZ3MuICovXG4gICAgICAgIHRoaXMuaXNTcGVjaWFsID0gZmFsc2U7XG4gICAgICAgIC8qKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdG9rZW5pemVyIGhhcyBiZWVuIHBhdXNlZC4gKi9cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgLyoqIFRoZSBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLiAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRyaWVJbmRleCA9IDA7XG4gICAgICAgIHRoaXMudHJpZUN1cnJlbnQgPSAwO1xuICAgICAgICAvKiogRm9yIG5hbWVkIGVudGl0aWVzLCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlLiBGb3IgbnVtZXJpYyBlbnRpdGllcywgdGhlIGNvZGUgcG9pbnQuICovXG4gICAgICAgIHRoaXMuZW50aXR5UmVzdWx0ID0gMDtcbiAgICAgICAgdGhpcy5lbnRpdHlFeGNlc3MgPSAwO1xuICAgICAgICB0aGlzLnhtbE1vZGUgPSB4bWxNb2RlO1xuICAgICAgICB0aGlzLmRlY29kZUVudGl0aWVzID0gZGVjb2RlRW50aXRpZXM7XG4gICAgICAgIHRoaXMuZW50aXR5VHJpZSA9IHhtbE1vZGUgPyBkZWNvZGVfanNfMS54bWxEZWNvZGVUcmVlIDogZGVjb2RlX2pzXzEuaHRtbERlY29kZVRyZWU7XG4gICAgfVxuICAgIFRva2VuaXplci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGNodW5rO1xuICAgICAgICB0aGlzLnBhcnNlKCk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGluZGV4IHdpdGhpbiBhbGwgb2YgdGhlIHdyaXR0ZW4gZGF0YS5cbiAgICAgKi9cbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBvZiB0aGUgY3VycmVudCBzZWN0aW9uLlxuICAgICAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZ2V0U2VjdGlvblN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWN0aW9uU3RhcnQ7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlVGV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuTHQgfHxcbiAgICAgICAgICAgICghdGhpcy5kZWNvZGVFbnRpdGllcyAmJiB0aGlzLmZhc3RGb3J3YXJkVG8oQ2hhckNvZGVzLkx0KSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID4gdGhpcy5zZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZVRhZ05hbWU7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNvZGVFbnRpdGllcyAmJiBjID09PSBDaGFyQ29kZXMuQW1wKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlRW50aXR5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlU3BlY2lhbFN0YXJ0U2VxdWVuY2UgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgaXNFbmQgPSB0aGlzLnNlcXVlbmNlSW5kZXggPT09IHRoaXMuY3VycmVudFNlcXVlbmNlLmxlbmd0aDtcbiAgICAgICAgdmFyIGlzTWF0Y2ggPSBpc0VuZFxuICAgICAgICAgICAgPyAvLyBJZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG1ha2Ugc3VyZSB0aGUgdGFnIG5hbWUgaGFzIGVuZGVkXG4gICAgICAgICAgICAgICAgaXNFbmRPZlRhZ1NlY3Rpb24oYylcbiAgICAgICAgICAgIDogLy8gT3RoZXJ3aXNlLCBkbyBhIGNhc2UtaW5zZW5zaXRpdmUgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgIChjIHwgMHgyMCkgPT09IHRoaXMuY3VycmVudFNlcXVlbmNlW3RoaXMuc2VxdWVuY2VJbmRleF07XG4gICAgICAgIGlmICghaXNNYXRjaCkge1xuICAgICAgICAgICAgdGhpcy5pc1NwZWNpYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNFbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7XG4gICAgfTtcbiAgICAvKiogTG9vayBmb3IgYW4gZW5kIHRhZy4gRm9yIDx0aXRsZT4gdGFncywgYWxzbyBkZWNvZGUgZW50aXRpZXMuICovXG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluU3BlY2lhbFRhZyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcXVlbmNlSW5kZXggPT09IHRoaXMuY3VycmVudFNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5HdCB8fCBpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kT2ZUZXh0ID0gdGhpcy5pbmRleCAtIHRoaXMuY3VycmVudFNlcXVlbmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCBlbmRPZlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Bvb2YgdGhlIGluZGV4IHNvIHRoYXQgcmVwb3J0ZWQgbG9jYXRpb25zIG1hdGNoIHVwLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0dWFsSW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gZW5kT2ZUZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIGVuZE9mVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBhY3R1YWxJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NwZWNpYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IGVuZE9mVGV4dCArIDI7IC8vIFNraXAgb3ZlciB0aGUgYDwvYFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gV2UgYXJlIGRvbmU7IHNraXAgdGhlIHJlc3Qgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGMgfCAweDIwKSA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2VbdGhpcy5zZXF1ZW5jZUluZGV4XSkge1xuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZXF1ZW5jZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2VxdWVuY2UgPT09IFNlcXVlbmNlcy5UaXRsZUVuZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcGFyc2UgZW50aXRpZXMgaW4gPHRpdGxlPiB0YWdzLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlY29kZUVudGl0aWVzICYmIGMgPT09IENoYXJDb2Rlcy5BbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUVudGl0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZhc3RGb3J3YXJkVG8oQ2hhckNvZGVzLkx0KSkge1xuICAgICAgICAgICAgICAgIC8vIE91dHNpZGUgb2YgPHRpdGxlPiB0YWdzLCB3ZSBjYW4gZmFzdC1mb3J3YXJkLlxuICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBzZWUgYSBgPGAsIHNldCB0aGUgc2VxdWVuY2UgaW5kZXggdG8gMTsgdXNlZnVsIGZvciBlZy4gYDw8L3NjcmlwdD5gLlxuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gTnVtYmVyKGMgPT09IENoYXJDb2Rlcy5MdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVDREFUQVNlcXVlbmNlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFNlcXVlbmNlcy5DZGF0YVt0aGlzLnNlcXVlbmNlSW5kZXhdKSB7XG4gICAgICAgICAgICBpZiAoKyt0aGlzLnNlcXVlbmNlSW5kZXggPT09IFNlcXVlbmNlcy5DZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5Db21tZW50TGlrZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IFNlcXVlbmNlcy5DZGF0YUVuZDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLnN0YXRlSW5EZWNsYXJhdGlvbihjKTsgLy8gUmVjb25zdW1lIHRoZSBjaGFyYWN0ZXJcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSB3YWl0IGZvciBvbmUgc3BlY2lmaWMgY2hhcmFjdGVyLCB3ZSBjYW4gc3BlZWQgdGhpbmdzIHVwXG4gICAgICogYnkgc2tpcHBpbmcgdGhyb3VnaCB0aGUgYnVmZmVyIHVudGlsIHdlIGZpbmQgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgd2FzIGZvdW5kLlxuICAgICAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZmFzdEZvcndhcmRUbyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHdoaWxlICgrK3RoaXMuaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGggKyB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCAtIHRoaXMub2Zmc2V0KSA9PT0gYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdlIGluY3JlbWVudCB0aGUgaW5kZXggYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlYCBsb29wLFxuICAgICAgICAgKiBzbyBzZXQgaXQgdG8gYGJ1ZmZlci5sZW5ndGggLSAxYCBoZXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBSZWZhY3RvciBgcGFyc2VgIHRvIGluY3JlbWVudCBpbmRleCBiZWZvcmUgY2FsbGluZyBzdGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vZmZzZXQgLSAxO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21tZW50cyBhbmQgQ0RBVEEgZW5kIHdpdGggYC0tPmAgYW5kIGBdXT5gLlxuICAgICAqXG4gICAgICogVGhlaXIgY29tbW9uIHF1YWxpdGllcyBhcmU6XG4gICAgICogLSBUaGVpciBlbmQgc2VxdWVuY2VzIGhhdmUgYSBkaXN0aW5jdCBjaGFyYWN0ZXIgdGhleSBzdGFydCB3aXRoLlxuICAgICAqIC0gVGhhdCBjaGFyYWN0ZXIgaXMgdGhlbiByZXBlYXRlZCwgc28gd2UgaGF2ZSB0byBjaGVjayBtdWx0aXBsZSByZXBlYXRzLlxuICAgICAqIC0gQWxsIGNoYXJhY3RlcnMgYnV0IHRoZSBzdGFydCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlIGNhbiBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkNvbW1lbnRMaWtlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IHRoaXMuY3VycmVudFNlcXVlbmNlW3RoaXMuc2VxdWVuY2VJbmRleF0pIHtcbiAgICAgICAgICAgIGlmICgrK3RoaXMuc2VxdWVuY2VJbmRleCA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlcXVlbmNlID09PSBTZXF1ZW5jZXMuQ2RhdGFFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYnMub25jZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCwgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNicy5vbmNvbW1lbnQodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZXF1ZW5jZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBGYXN0LWZvcndhcmQgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIGlmICh0aGlzLmZhc3RGb3J3YXJkVG8odGhpcy5jdXJyZW50U2VxdWVuY2VbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjICE9PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXggLSAxXSkge1xuICAgICAgICAgICAgLy8gQWxsb3cgbG9uZyBzZXF1ZW5jZXMsIGVnLiAtLS0+LCBdXV0+XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIVE1MIG9ubHkgYWxsb3dzIEFTQ0lJIGFscGhhIGNoYXJhY3RlcnMgKGEteiBhbmQgQS1aKSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgdGFnIG5hbWUuXG4gICAgICpcbiAgICAgKiBYTUwgYWxsb3dzIGEgbG90IG1vcmUgY2hhcmFjdGVycyBoZXJlIChAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lU3RhcnRDaGFyKS5cbiAgICAgKiBXZSBhbGxvdyBhbnl0aGluZyB0aGF0IHdvdWxkbid0IGVuZCB0aGUgdGFnLlxuICAgICAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuaXNUYWdTdGFydENoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gdGhpcy54bWxNb2RlID8gIWlzRW5kT2ZUYWdTZWN0aW9uKGMpIDogaXNBU0NJSUFscGhhKGMpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGFydFNwZWNpYWwgPSBmdW5jdGlvbiAoc2VxdWVuY2UsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmlzU3BlY2lhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gc2VxdWVuY2U7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNwZWNpYWxTdGFydFNlcXVlbmNlO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZVRhZ05hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkV4Y2xhbWF0aW9uTWFyaykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBDaGFyQ29kZXMuUXVlc3Rpb25tYXJrKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNUYWdTdGFydENoYXIoYykpIHtcbiAgICAgICAgICAgIHZhciBsb3dlciA9IGMgfCAweDIwO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgaWYgKCF0aGlzLnhtbE1vZGUgJiYgbG93ZXIgPT09IFNlcXVlbmNlcy5UaXRsZUVuZFsyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGVjaWFsKFNlcXVlbmNlcy5UaXRsZUVuZCwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgIXRoaXMueG1sTW9kZSAmJiBsb3dlciA9PT0gU2VxdWVuY2VzLlNjcmlwdEVuZFsyXVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBTdGF0ZS5CZWZvcmVTcGVjaWFsU1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlNsYXNoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQ2xvc2luZ1RhZ05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUZXh0KGMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5UYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGlzRW5kT2ZUYWdTZWN0aW9uKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbm9wZW50YWduYW1lKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlQ2xvc2luZ1RhZ05hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuaXNUYWdTdGFydENoYXIoYylcbiAgICAgICAgICAgICAgICA/IFN0YXRlLkluQ2xvc2luZ1RhZ05hbWVcbiAgICAgICAgICAgICAgICA6IFN0YXRlLkluU3BlY2lhbENvbW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkNsb3NpbmdUYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5HdCB8fCBpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY2xvc2V0YWcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5BZnRlckNsb3NpbmdUYWdOYW1lO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gU2tpcCBldmVyeXRoaW5nIHVudGlsIFwiPlwiXG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5HdCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgdGhpcy5iYXNlU3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkd0KSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbm9wZW50YWdlbmQodGhpcy5pbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5TcGVjaWFsVGFnO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmFzZVN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLlNsYXNoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5TZWxmQ2xvc2luZ1RhZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5BdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5TZWxmQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uc2VsZmNsb3Npbmd0YWcodGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgICAgICB0aGlzLmlzU3BlY2lhbCA9IGZhbHNlOyAvLyBSZXNldCBzcGVjaWFsIHN0YXRlLCBpbiBjYXNlIG9mIHNlbGYtY2xvc2luZyBzcGVjaWFsIHRhZ3NcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5BdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5FcSB8fCBpc0VuZE9mVGFnU2VjdGlvbihjKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJuYW1lKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQWZ0ZXJBdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuRXEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBDaGFyQ29kZXMuU2xhc2ggfHwgYyA9PT0gQ2hhckNvZGVzLkd0KSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZChRdW90ZVR5cGUuTm9WYWx1ZSwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKFF1b3RlVHlwZS5Ob1ZhbHVlLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuRG91YmxlUXVvdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlRHE7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IENoYXJDb2Rlcy5TaW5nbGVRdW90ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQXR0cmlidXRlVmFsdWVTcTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQXR0cmlidXRlVmFsdWVOcTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlTm9RdW90ZXMoYyk7IC8vIFJlY29uc3VtZSB0b2tlblxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmhhbmRsZUluQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoYywgcXVvdGUpIHtcbiAgICAgICAgaWYgKGMgPT09IHF1b3RlIHx8XG4gICAgICAgICAgICAoIXRoaXMuZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5mYXN0Rm9yd2FyZFRvKHF1b3RlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJlbmQocXVvdGUgPT09IENoYXJDb2Rlcy5Eb3VibGVRdW90ZVxuICAgICAgICAgICAgICAgID8gUXVvdGVUeXBlLkRvdWJsZVxuICAgICAgICAgICAgICAgIDogUXVvdGVUeXBlLlNpbmdsZSwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlY29kZUVudGl0aWVzICYmIGMgPT09IENoYXJDb2Rlcy5BbXApIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVFbnRpdHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVJbkF0dHJpYnV0ZVZhbHVlKGMsIENoYXJDb2Rlcy5Eb3VibGVRdW90ZSk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlcyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5BdHRyaWJ1dGVWYWx1ZShjLCBDaGFyQ29kZXMuU2luZ2xlUXVvdGUpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3RlcyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykgfHwgYyA9PT0gQ2hhckNvZGVzLkd0KSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmRhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKFF1b3RlVHlwZS5VbnF1b3RlZCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gQ2hhckNvZGVzLkFtcCkge1xuICAgICAgICAgICAgdGhpcy5iYXNlU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUVudGl0eTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5PcGVuaW5nU3F1YXJlQnJhY2tldCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkNEQVRBU2VxdWVuY2U7XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9XG4gICAgICAgICAgICAgICAgYyA9PT0gQ2hhckNvZGVzLkRhc2hcbiAgICAgICAgICAgICAgICAgICAgPyBTdGF0ZS5CZWZvcmVDb21tZW50XG4gICAgICAgICAgICAgICAgICAgIDogU3RhdGUuSW5EZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkd0IHx8IHRoaXMuZmFzdEZvcndhcmRUbyhDaGFyQ29kZXMuR3QpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmRlY2xhcmF0aW9uKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5HdCB8fCB0aGlzLmZhc3RGb3J3YXJkVG8oQ2hhckNvZGVzLkd0KSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24odGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlQ29tbWVudCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuRGFzaCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQ29tbWVudExpa2U7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IFNlcXVlbmNlcy5Db21tZW50RW5kO1xuICAgICAgICAgICAgLy8gQWxsb3cgc2hvcnQgY29tbWVudHMgKGVnLiA8IS0tPilcbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDI7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluRGVjbGFyYXRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJblNwZWNpYWxDb21tZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5HdCB8fCB0aGlzLmZhc3RGb3J3YXJkVG8oQ2hhckNvZGVzLkd0KSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25jb21tZW50KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4LCAwKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZVNwZWNpYWxTID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGxvd2VyID0gYyB8IDB4MjA7XG4gICAgICAgIGlmIChsb3dlciA9PT0gU2VxdWVuY2VzLlNjcmlwdEVuZFszXSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlNjcmlwdEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG93ZXIgPT09IFNlcXVlbmNlcy5TdHlsZUVuZFszXSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlN0eWxlRW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpOyAvLyBDb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlRW50aXR5ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gU3RhcnQgZXhjZXNzIHdpdGggMSB0byBpbmNsdWRlIHRoZSAnJidcbiAgICAgICAgdGhpcy5lbnRpdHlFeGNlc3MgPSAxO1xuICAgICAgICB0aGlzLmVudGl0eVJlc3VsdCA9IDA7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlTnVtZXJpY0VudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBDaGFyQ29kZXMuQW1wKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHR3byBgJmAgY2hhcmFjdGVycyBpbiBhIHJvdy4gU3RheSBpbiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJpZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMudHJpZUN1cnJlbnQgPSB0aGlzLmVudGl0eVRyaWVbMF07XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5OYW1lZEVudGl0eTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVJbk5hbWVkRW50aXR5KGMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5OYW1lZEVudGl0eSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuZW50aXR5RXhjZXNzICs9IDE7XG4gICAgICAgIHRoaXMudHJpZUluZGV4ID0gKDAsIGRlY29kZV9qc18xLmRldGVybWluZUJyYW5jaCkodGhpcy5lbnRpdHlUcmllLCB0aGlzLnRyaWVDdXJyZW50LCB0aGlzLnRyaWVJbmRleCArIDEsIGMpO1xuICAgICAgICBpZiAodGhpcy50cmllSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXROYW1lZEVudGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC0tO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZUN1cnJlbnQgPSB0aGlzLmVudGl0eVRyaWVbdGhpcy50cmllSW5kZXhdO1xuICAgICAgICB2YXIgbWFza2VkID0gdGhpcy50cmllQ3VycmVudCAmIGRlY29kZV9qc18xLkJpblRyaWVGbGFncy5WQUxVRV9MRU5HVEg7XG4gICAgICAgIC8vIElmIHRoZSBicmFuY2ggaXMgYSB2YWx1ZSwgc3RvcmUgaXQgYW5kIGNvbnRpbnVlXG4gICAgICAgIGlmIChtYXNrZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBtYXNrIGlzIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIHZhbHVlLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgYnl0ZS5cbiAgICAgICAgICAgIHZhciB2YWx1ZUxlbmd0aCA9IChtYXNrZWQgPj4gMTQpIC0gMTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBsZWdhY3kgZW50aXR5IHdoaWxlIHBhcnNpbmcgc3RyaWN0bHksIGp1c3Qgc2tpcCB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dMZWdhY3lFbnRpdHkoKSAmJiBjICE9PSBDaGFyQ29kZXMuU2VtaSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZUluZGV4ICs9IHZhbHVlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIDEgYXMgd2UgaGF2ZSBhbHJlYWR5IGluY3JlbWVudGVkIHRoZSBleGNlc3NcbiAgICAgICAgICAgICAgICB2YXIgZW50aXR5U3RhcnQgPSB0aGlzLmluZGV4IC0gdGhpcy5lbnRpdHlFeGNlc3MgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChlbnRpdHlTdGFydCA+IHRoaXMuc2VjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFBhcnRpYWwodGhpcy5zZWN0aW9uU3RhcnQsIGVudGl0eVN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN1cnJvZ2F0ZSBwYWlyLCBjb25zdW1lIHRoZSBuZXh0IHR3byBieXRlc1xuICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5UmVzdWx0ID0gdGhpcy50cmllSW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy50cmllSW5kZXggKz0gdmFsdWVMZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRpdHlFeGNlc3MgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdE5hbWVkRW50aXR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmVtaXROYW1lZEVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICBpZiAodGhpcy5lbnRpdHlSZXN1bHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVMZW5ndGggPSAodGhpcy5lbnRpdHlUcmllW3RoaXMuZW50aXR5UmVzdWx0XSAmIGRlY29kZV9qc18xLkJpblRyaWVGbGFncy5WQUxVRV9MRU5HVEgpID4+XG4gICAgICAgICAgICAxNDtcbiAgICAgICAgc3dpdGNoICh2YWx1ZUxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29kZVBvaW50KHRoaXMuZW50aXR5VHJpZVt0aGlzLmVudGl0eVJlc3VsdF0gJlxuICAgICAgICAgICAgICAgICAgICB+ZGVjb2RlX2pzXzEuQmluVHJpZUZsYWdzLlZBTFVFX0xFTkdUSCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDb2RlUG9pbnQodGhpcy5lbnRpdHlUcmllW3RoaXMuZW50aXR5UmVzdWx0ICsgMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29kZVBvaW50KHRoaXMuZW50aXR5VHJpZVt0aGlzLmVudGl0eVJlc3VsdCArIDFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDb2RlUG9pbnQodGhpcy5lbnRpdHlUcmllW3RoaXMuZW50aXR5UmVzdWx0ICsgMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlTnVtZXJpY0VudGl0eSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICgoYyB8IDB4MjApID09PSBDaGFyQ29kZXMuTG93ZXJYKSB7XG4gICAgICAgICAgICB0aGlzLmVudGl0eUV4Y2VzcysrO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluSGV4RW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluTnVtZXJpY0VudGl0eTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVJbk51bWVyaWNFbnRpdHkoYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZW1pdE51bWVyaWNFbnRpdHkgPSBmdW5jdGlvbiAoc3RyaWN0KSB7XG4gICAgICAgIHZhciBlbnRpdHlTdGFydCA9IHRoaXMuaW5kZXggLSB0aGlzLmVudGl0eUV4Y2VzcyAtIDE7XG4gICAgICAgIHZhciBudW1iZXJTdGFydCA9IGVudGl0eVN0YXJ0ICsgMiArIE51bWJlcih0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkhleEVudGl0eSk7XG4gICAgICAgIGlmIChudW1iZXJTdGFydCAhPT0gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgLy8gRW1pdCBsZWFkaW5nIGRhdGEgaWYgYW55XG4gICAgICAgICAgICBpZiAoZW50aXR5U3RhcnQgPiB0aGlzLnNlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFBhcnRpYWwodGhpcy5zZWN0aW9uU3RhcnQsIGVudGl0eVN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIE51bWJlcihzdHJpY3QpO1xuICAgICAgICAgICAgdGhpcy5lbWl0Q29kZVBvaW50KCgwLCBkZWNvZGVfanNfMS5yZXBsYWNlQ29kZVBvaW50KSh0aGlzLmVudGl0eVJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmJhc2VTdGF0ZTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbk51bWVyaWNFbnRpdHkgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLlNlbWkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdE51bWVyaWNFbnRpdHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIoYykpIHtcbiAgICAgICAgICAgIHRoaXMuZW50aXR5UmVzdWx0ID0gdGhpcy5lbnRpdHlSZXN1bHQgKiAxMCArIChjIC0gQ2hhckNvZGVzLlplcm8pO1xuICAgICAgICAgICAgdGhpcy5lbnRpdHlFeGNlc3MrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TGVnYWN5RW50aXR5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXROdW1lcmljRW50aXR5KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmJhc2VTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5kZXgtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluSGV4RW50aXR5ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5TZW1pKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXROdW1lcmljRW50aXR5KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmVudGl0eVJlc3VsdCA9IHRoaXMuZW50aXR5UmVzdWx0ICogMTYgKyAoYyAtIENoYXJDb2Rlcy5aZXJvKTtcbiAgICAgICAgICAgIHRoaXMuZW50aXR5RXhjZXNzKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNIZXhEaWdpdChjKSkge1xuICAgICAgICAgICAgdGhpcy5lbnRpdHlSZXN1bHQgPVxuICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5UmVzdWx0ICogMTYgKyAoKGMgfCAweDIwKSAtIENoYXJDb2Rlcy5Mb3dlckEgKyAxMCk7XG4gICAgICAgICAgICB0aGlzLmVudGl0eUV4Y2VzcysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dMZWdhY3lFbnRpdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdE51bWVyaWNFbnRpdHkoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmFsbG93TGVnYWN5RW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLnhtbE1vZGUgJiZcbiAgICAgICAgICAgICh0aGlzLmJhc2VTdGF0ZSA9PT0gU3RhdGUuVGV4dCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVN0YXRlID09PSBTdGF0ZS5JblNwZWNpYWxUYWcpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBkYXRhIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZCBmcm9tIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgaW5zaWRlIG9mIHRleHQgb3IgYXR0cmlidXRlcywgZW1pdCB3aGF0IHdlIGFscmVhZHkgaGF2ZS5cbiAgICAgICAgaWYgKHRoaXMucnVubmluZyAmJiB0aGlzLnNlY3Rpb25TdGFydCAhPT0gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlRleHQgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5TcGVjaWFsVGFnICYmIHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVEcSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVTcSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVOcSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnNob3VsZENvbnRpbnVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMub2Zmc2V0ICYmIHRoaXMucnVubmluZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGJ1ZmZlciwgY2FsbGluZyB0aGUgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFN0YXRlcyB0aGF0IGFyZSBtb3JlIGxpa2VseSB0byBiZSBoaXQgYXJlIGhpZ2hlciB1cCwgYXMgYSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC5cbiAgICAgKi9cbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5zaG91bGRDb250aW51ZSgpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCAtIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuVGV4dDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVGV4dChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuU3BlY2lhbFN0YXJ0U2VxdWVuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVNwZWNpYWxTdGFydFNlcXVlbmNlKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JblNwZWNpYWxUYWc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluU3BlY2lhbFRhZyhjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQ0RBVEFTZXF1ZW5jZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQ0RBVEFTZXF1ZW5jZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZURxOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkF0dHJpYnV0ZU5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5Db21tZW50TGlrZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5Db21tZW50TGlrZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5TcGVjaWFsQ29tbWVudDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5TcGVjaWFsQ29tbWVudChjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5UYWdOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluQ2xvc2luZ1RhZ05hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZVRhZ05hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVRhZ05hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkFmdGVyQXR0cmlidXRlTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlU3E6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZXMoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZUF0dHJpYnV0ZVZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlQ2xvc2luZ1RhZ05hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5BZnRlckNsb3NpbmdUYWdOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVTcGVjaWFsUzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3BlY2lhbFMoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluQXR0cmlidXRlVmFsdWVOcToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JblNlbGZDbG9zaW5nVGFnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblNlbGZDbG9zaW5nVGFnKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkRlY2xhcmF0aW9uKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVEZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlRGVjbGFyYXRpb24oYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZUNvbW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUNvbW1lbnQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluUHJvY2Vzc2luZ0luc3RydWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblByb2Nlc3NpbmdJbnN0cnVjdGlvbihjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5OYW1lZEVudGl0eToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5OYW1lZEVudGl0eShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlRW50aXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVFbnRpdHkoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluSGV4RW50aXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkhleEVudGl0eShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5OdW1lcmljRW50aXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbk51bWVyaWNFbnRpdHkoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGB0aGlzLl9zdGF0ZSA9PT0gU3RhdGUuQmVmb3JlTnVtZXJpY0VudGl0eWBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZU51bWVyaWNFbnRpdHkoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5Jbk5hbWVkRW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXROYW1lZEVudGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIHJlbWFpbmluZyBkYXRhLCBlbWl0IGl0IGluIGEgcmVhc29uYWJsZSB3YXlcbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0IDwgdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGluZ0RhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNicy5vbmVuZCgpO1xuICAgIH07XG4gICAgLyoqIEhhbmRsZSBhbnkgdHJhaWxpbmcgZGF0YS4gKi9cbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmhhbmRsZVRyYWlsaW5nRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkNvbW1lbnRMaWtlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2VxdWVuY2UgPT09IFNlcXVlbmNlcy5DZGF0YUVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uY2RhdGEodGhpcy5zZWN0aW9uU3RhcnQsIGVuZEluZGV4LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uY29tbWVudCh0aGlzLnNlY3Rpb25TdGFydCwgZW5kSW5kZXgsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluTnVtZXJpY0VudGl0eSAmJlxuICAgICAgICAgICAgdGhpcy5hbGxvd0xlZ2FjeUVudGl0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXROdW1lcmljRW50aXR5KGZhbHNlKTtcbiAgICAgICAgICAgIC8vIEFsbCB0cmFpbGluZyBkYXRhIHdpbGwgaGF2ZSBiZWVuIGNvbnN1bWVkXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5IZXhFbnRpdHkgJiZcbiAgICAgICAgICAgIHRoaXMuYWxsb3dMZWdhY3lFbnRpdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0TnVtZXJpY0VudGl0eShmYWxzZSk7XG4gICAgICAgICAgICAvLyBBbGwgdHJhaWxpbmcgZGF0YSB3aWxsIGhhdmUgYmVlbiBjb25zdW1lZFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluVGFnTmFtZSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuQmVmb3JlQXR0cmlidXRlVmFsdWUgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkFmdGVyQXR0cmlidXRlTmFtZSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5BdHRyaWJ1dGVOYW1lIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlU3EgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVEcSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZU5xIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkNsb3NpbmdUYWdOYW1lKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgd2UgYXJlIGN1cnJlbnRseSBpbiBhbiBvcGVuaW5nIG9yIGNsb3NpbmcgdGFnLCB1cyBub3QgY2FsbGluZyB0aGVcbiAgICAgICAgICAgICAqIHJlc3BlY3RpdmUgY2FsbGJhY2sgc2lnbmFscyB0aGF0IHRoZSB0YWcgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmVtaXRQYXJ0aWFsID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlU3RhdGUgIT09IFN0YXRlLlRleHQgJiZcbiAgICAgICAgICAgIHRoaXMuYmFzZVN0YXRlICE9PSBTdGF0ZS5JblNwZWNpYWxUYWcpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHN0YXJ0LCBlbmRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZW1pdENvZGVQb2ludCA9IGZ1bmN0aW9uIChjcCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlU3RhdGUgIT09IFN0YXRlLlRleHQgJiZcbiAgICAgICAgICAgIHRoaXMuYmFzZVN0YXRlICE9PSBTdGF0ZS5JblNwZWNpYWxUYWcpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW50aXR5KGNwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dGVudGl0eShjcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUb2tlbml6ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRvbVV0aWxzID0gZXhwb3J0cy5wYXJzZUZlZWQgPSBleHBvcnRzLmdldEZlZWQgPSBleHBvcnRzLkVsZW1lbnRUeXBlID0gZXhwb3J0cy5Ub2tlbml6ZXIgPSBleHBvcnRzLmNyZWF0ZURvbVN0cmVhbSA9IGV4cG9ydHMucGFyc2VET00gPSBleHBvcnRzLnBhcnNlRG9jdW1lbnQgPSBleHBvcnRzLkRlZmF1bHRIYW5kbGVyID0gZXhwb3J0cy5Eb21IYW5kbGVyID0gZXhwb3J0cy5QYXJzZXIgPSB2b2lkIDA7XG52YXIgUGFyc2VyX2pzXzEgPSByZXF1aXJlKFwiLi9QYXJzZXIuanNcIik7XG52YXIgUGFyc2VyX2pzXzIgPSByZXF1aXJlKFwiLi9QYXJzZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJzZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBhcnNlcl9qc18yLlBhcnNlcjsgfSB9KTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcbnZhciBkb21oYW5kbGVyXzIgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvbUhhbmRsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWhhbmRsZXJfMi5Eb21IYW5kbGVyOyB9IH0pO1xuLy8gT2xkIG5hbWUgZm9yIERvbUhhbmRsZXJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlZmF1bHRIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb21oYW5kbGVyXzIuRG9tSGFuZGxlcjsgfSB9KTtcbi8vIEhlbHBlciBtZXRob2RzXG4vKipcbiAqIFBhcnNlcyB0aGUgZGF0YSwgcmV0dXJucyB0aGUgcmVzdWx0aW5nIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRoYXQgc2hvdWxkIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXIgYW5kIERPTSBidWlsZGVyLlxuICovXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50KGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGFuZGxlciA9IG5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcih1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIG5ldyBQYXJzZXJfanNfMS5QYXJzZXIoaGFuZGxlciwgb3B0aW9ucykuZW5kKGRhdGEpO1xuICAgIHJldHVybiBoYW5kbGVyLnJvb3Q7XG59XG5leHBvcnRzLnBhcnNlRG9jdW1lbnQgPSBwYXJzZURvY3VtZW50O1xuLyoqXG4gKiBQYXJzZXMgZGF0YSwgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcm9vdCBub2Rlcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHJvb3Qgbm9kZXMgc3RpbGwgaGF2ZSBhIGBEb2N1bWVudGAgbm9kZSBhcyB0aGVpciBwYXJlbnQuXG4gKiBVc2UgYHBhcnNlRG9jdW1lbnRgIHRvIGdldCB0aGUgYERvY3VtZW50YCBub2RlIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGJ1aWxkZXIuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHBhcnNlRG9jdW1lbnRgIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRE9NKGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcGFyc2VEb2N1bWVudChkYXRhLCBvcHRpb25zKS5jaGlsZHJlbjtcbn1cbmV4cG9ydHMucGFyc2VET00gPSBwYXJzZURPTTtcbi8qKlxuICogQ3JlYXRlcyBhIHBhcnNlciBpbnN0YW5jZSwgd2l0aCBhbiBhdHRhY2hlZCBET00gaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgcGFyc2luZyBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciB0aGUgcGFyc2VyIGFuZCBET00gYnVpbGRlci5cbiAqIEBwYXJhbSBlbGVtZW50Q2FsbGJhY2sgQW4gb3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBldmVyeSB0aW1lIGEgdGFnIGhhcyBiZWVuIGNvbXBsZXRlZCBpbnNpZGUgb2YgdGhlIERPTS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRG9tU3RyZWFtKGNhbGxiYWNrLCBvcHRpb25zLCBlbGVtZW50Q2FsbGJhY2spIHtcbiAgICB2YXIgaGFuZGxlciA9IG5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcihjYWxsYmFjaywgb3B0aW9ucywgZWxlbWVudENhbGxiYWNrKTtcbiAgICByZXR1cm4gbmV3IFBhcnNlcl9qc18xLlBhcnNlcihoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlRG9tU3RyZWFtID0gY3JlYXRlRG9tU3RyZWFtO1xudmFyIFRva2VuaXplcl9qc18xID0gcmVxdWlyZShcIi4vVG9rZW5pemVyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG9rZW5pemVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQoVG9rZW5pemVyX2pzXzEpLmRlZmF1bHQ7IH0gfSk7XG4vKlxuICogQWxsIG9mIHRoZSBmb2xsb3dpbmcgZXhwb3J0cyBleGlzdCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuXG4gKiBUaGV5IHNob3VsZCBwcm9iYWJseSBiZSByZW1vdmVkIGV2ZW50dWFsbHkuXG4gKi9cbmV4cG9ydHMuRWxlbWVudFR5cGUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpKTtcbnZhciBkb211dGlsc18xID0gcmVxdWlyZShcImRvbXV0aWxzXCIpO1xudmFyIGRvbXV0aWxzXzIgPSByZXF1aXJlKFwiZG9tdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGZWVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb211dGlsc18yLmdldEZlZWQ7IH0gfSk7XG52YXIgcGFyc2VGZWVkRGVmYXVsdE9wdGlvbnMgPSB7IHhtbE1vZGU6IHRydWUgfTtcbi8qKlxuICogUGFyc2UgYSBmZWVkLlxuICpcbiAqIEBwYXJhbSBmZWVkIFRoZSBmZWVkIHRoYXQgc2hvdWxkIGJlIHBhcnNlZCwgYXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbGx5LCBvcHRpb25zIGZvciBwYXJzaW5nLiBXaGVuIHVzaW5nIHRoaXMsIHlvdSBzaG91bGQgc2V0IGB4bWxNb2RlYCB0byBgdHJ1ZWAuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmVlZChmZWVkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gcGFyc2VGZWVkRGVmYXVsdE9wdGlvbnM7IH1cbiAgICByZXR1cm4gKDAsIGRvbXV0aWxzXzEuZ2V0RmVlZCkocGFyc2VET00oZmVlZCwgb3B0aW9ucykpO1xufVxuZXhwb3J0cy5wYXJzZUZlZWQgPSBwYXJzZUZlZWQ7XG5leHBvcnRzLkRvbVV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkb211dGlsc1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKipcbiAqIFNyY3NldCBQYXJzZXJcbiAqXG4gKiBCeSBBbGV4IEJlbGwgfCAgTUlUIExpY2Vuc2VcbiAqXG4gKiBKUyBQYXJzZXIgZm9yIHRoZSBzdHJpbmcgdmFsdWUgdGhhdCBhcHBlYXJzIGluIG1hcmt1cCA8aW1nIHNyY3NldD1cImhlcmVcIj5cbiAqXG4gKiBAcmV0dXJucyBBcnJheSBbe3VybDogXywgZDogXywgdzogXywgaDpffSwgLi4uXVxuICpcbiAqIEJhc2VkIHN1cGVyIGR1cGVyIGNsb3NlbHkgb24gdGhlIHJlZmVyZW5jZSBhbGdvcml0aG0gYXQ6XG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjcGFyc2UtYS1zcmNzZXQtYXR0cmlidXRlXG4gKlxuICogTW9zdCBjb21tZW50cyBhcmUgY29waWVkIGluIGRpcmVjdGx5IGZyb20gdGhlIHNwZWNcbiAqIChleGNlcHQgZm9yIGNvbW1lbnRzIGluIHBhcmVucykuXG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuXHRcdC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuXHRcdC8vIGxpa2UgTm9kZS5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHQvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuXHRcdHJvb3QucGFyc2VTcmNzZXQgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8vIDEuIExldCBpbnB1dCBiZSB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoaXMgYWxnb3JpdGhtLlxuXHRyZXR1cm4gZnVuY3Rpb24gKGlucHV0KSB7XG5cblx0XHQvLyBVVElMSVRZIEZVTkNUSU9OU1xuXG5cdFx0Ly8gTWFudWFsIGlzIGZhc3RlciB0aGFuIFJlZ0V4XG5cdFx0Ly8gaHR0cDovL2Jqb3JuLnRpcGxpbmcuY29tL3N0YXRlLWFuZC1yZWd1bGFyLWV4cHJlc3Npb25zLWluLWphdmFzY3JpcHRcblx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS93aGl0ZXNwYWNlLWNoYXJhY3Rlci81XG5cdFx0ZnVuY3Rpb24gaXNTcGFjZShjKSB7XG5cdFx0XHRyZXR1cm4gKGMgPT09IFwiXFx1MDAyMFwiIHx8IC8vIHNwYWNlXG5cdFx0XHRjID09PSBcIlxcdTAwMDlcIiB8fCAvLyBob3Jpem9udGFsIHRhYlxuXHRcdFx0YyA9PT0gXCJcXHUwMDBBXCIgfHwgLy8gbmV3IGxpbmVcblx0XHRcdGMgPT09IFwiXFx1MDAwQ1wiIHx8IC8vIGZvcm0gZmVlZFxuXHRcdFx0YyA9PT0gXCJcXHUwMDBEXCIpOyAgLy8gY2FycmlhZ2UgcmV0dXJuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29sbGVjdENoYXJhY3RlcnMocmVnRXgpIHtcblx0XHRcdHZhciBjaGFycyxcblx0XHRcdFx0bWF0Y2ggPSByZWdFeC5leGVjKGlucHV0LnN1YnN0cmluZyhwb3MpKTtcblx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRjaGFycyA9IG1hdGNoWyAwIF07XG5cdFx0XHRcdHBvcyArPSBjaGFycy5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiBjaGFycztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cblx0XHRcdC8vIChEb24ndCB1c2UgXFxzLCB0byBhdm9pZCBtYXRjaGluZyBub24tYnJlYWtpbmcgc3BhY2UpXG5cdFx0XHRyZWdleExlYWRpbmdTcGFjZXMgPSAvXlsgXFx0XFxuXFxyXFx1MDAwY10rLyxcblx0XHRcdHJlZ2V4TGVhZGluZ0NvbW1hc09yU3BhY2VzID0gL15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvLFxuXHRcdFx0cmVnZXhMZWFkaW5nTm90U3BhY2VzID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvLFxuXHRcdFx0cmVnZXhUcmFpbGluZ0NvbW1hcyA9IC9bLF0rJC8sXG5cdFx0XHRyZWdleE5vbk5lZ2F0aXZlSW50ZWdlciA9IC9eXFxkKyQvLFxuXG5cdFx0XHQvLyAoIFBvc2l0aXZlIG9yIG5lZ2F0aXZlIG9yIHVuc2lnbmVkIGludGVnZXJzIG9yIGRlY2ltYWxzLCB3aXRob3V0IG9yIHdpdGhvdXQgZXhwb25lbnRzLlxuXHRcdFx0Ly8gTXVzdCBpbmNsdWRlIGF0IGxlYXN0IG9uZSBkaWdpdC5cblx0XHRcdC8vIEFjY29yZGluZyB0byBzcGVjIHRlc3RzIGFueSBkZWNpbWFsIHBvaW50IG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkaWdpdC5cblx0XHRcdC8vIE5vIGxlYWRpbmcgcGx1cyBzaWduIGlzIGFsbG93ZWQuKVxuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN2YWxpZC1mbG9hdGluZy1wb2ludC1udW1iZXJcblx0XHRcdHJlZ2V4RmxvYXRpbmdQb2ludCA9IC9eLT8oPzpbMC05XSt8WzAtOV0qXFwuWzAtOV0rKSg/OltlRV1bKy1dP1swLTldKyk/JC8sXG5cblx0XHRcdHVybCxcblx0XHRcdGRlc2NyaXB0b3JzLFxuXHRcdFx0Y3VycmVudERlc2NyaXB0b3IsXG5cdFx0XHRzdGF0ZSxcblx0XHRcdGMsXG5cblx0XHRcdC8vIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvaW50ZXIgaW50byBpbnB1dCwgaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydFxuXHRcdFx0Ly8gICAgb2YgdGhlIHN0cmluZy5cblx0XHRcdHBvcyA9IDAsXG5cblx0XHRcdC8vIDMuIExldCBjYW5kaWRhdGVzIGJlIGFuIGluaXRpYWxseSBlbXB0eSBzb3VyY2Ugc2V0LlxuXHRcdFx0Y2FuZGlkYXRlcyA9IFtdO1xuXG5cdFx0Ly8gNC4gU3BsaXR0aW5nIGxvb3A6IENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHRoYXQgYXJlIHNwYWNlXG5cdFx0Ly8gICAgY2hhcmFjdGVycyBvciBVKzAwMkMgQ09NTUEgY2hhcmFjdGVycy4gSWYgYW55IFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzXG5cdFx0Ly8gICAgd2VyZSBjb2xsZWN0ZWQsIHRoYXQgaXMgYSBwYXJzZSBlcnJvci5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Y29sbGVjdENoYXJhY3RlcnMocmVnZXhMZWFkaW5nQ29tbWFzT3JTcGFjZXMpO1xuXG5cdFx0XHQvLyA1LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHJldHVybiBjYW5kaWRhdGVzIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cblx0XHRcdGlmIChwb3MgPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGNhbmRpZGF0ZXM7IC8vICh3ZSdyZSBkb25lLCB0aGlzIGlzIHRoZSBzb2xlIHJldHVybiBwYXRoKVxuXHRcdFx0fVxuXG5cdFx0XHQvLyA2LiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBub3Qgc3BhY2UgY2hhcmFjdGVycyxcblx0XHRcdC8vICAgIGFuZCBsZXQgdGhhdCBiZSB1cmwuXG5cdFx0XHR1cmwgPSBjb2xsZWN0Q2hhcmFjdGVycyhyZWdleExlYWRpbmdOb3RTcGFjZXMpO1xuXG5cdFx0XHQvLyA3LiBMZXQgZGVzY3JpcHRvcnMgYmUgYSBuZXcgZW1wdHkgbGlzdC5cblx0XHRcdGRlc2NyaXB0b3JzID0gW107XG5cblx0XHRcdC8vIDguIElmIHVybCBlbmRzIHdpdGggYSBVKzAwMkMgQ09NTUEgY2hhcmFjdGVyICgsKSwgZm9sbG93IHRoZXNlIHN1YnN0ZXBzOlxuXHRcdFx0Ly9cdFx0KDEpLiBSZW1vdmUgYWxsIHRyYWlsaW5nIFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzIGZyb20gdXJsLiBJZiB0aGlzIHJlbW92ZWRcblx0XHRcdC8vICAgICAgICAgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXIsIHRoYXQgaXMgYSBwYXJzZSBlcnJvci5cblx0XHRcdGlmICh1cmwuc2xpY2UoLTEpID09PSBcIixcIikge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZShyZWdleFRyYWlsaW5nQ29tbWFzLCBcIlwiKTtcblx0XHRcdFx0Ly8gKEp1bXAgYWhlYWQgdG8gc3RlcCA5IHRvIHNraXAgdG9rZW5pemF0aW9uIGFuZCBqdXN0IHB1c2ggdGhlIGNhbmRpZGF0ZSkuXG5cdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblxuXHRcdFx0XHQvL1x0T3RoZXJ3aXNlLCBmb2xsb3cgdGhlc2Ugc3Vic3RlcHM6XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b2tlbml6ZSgpO1xuXHRcdFx0fSAvLyAoY2xvc2UgZWxzZSBvZiBzdGVwIDgpXG5cblx0XHRcdC8vIDE2LiBSZXR1cm4gdG8gdGhlIHN0ZXAgbGFiZWxlZCBzcGxpdHRpbmcgbG9vcC5cblx0XHR9IC8vIChDbG9zZSBvZiBiaWcgd2hpbGUgbG9vcC4pXG5cblx0XHQvKipcblx0XHQgKiBUb2tlbml6ZXMgZGVzY3JpcHRvciBwcm9wZXJ0aWVzIHByaW9yIHRvIHBhcnNpbmdcblx0XHQgKiBSZXR1cm5zIHVuZGVmaW5lZC5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0b2tlbml6ZSgpIHtcblxuXHRcdFx0Ly8gOC4xLiBEZXNjcmlwdG9yIHRva2VuaXNlcjogU2tpcCB3aGl0ZXNwYWNlXG5cdFx0XHRjb2xsZWN0Q2hhcmFjdGVycyhyZWdleExlYWRpbmdTcGFjZXMpO1xuXG5cdFx0XHQvLyA4LjIuIExldCBjdXJyZW50IGRlc2NyaXB0b3IgYmUgdGhlIGVtcHR5IHN0cmluZy5cblx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gXCJcIjtcblxuXHRcdFx0Ly8gOC4zLiBMZXQgc3RhdGUgYmUgaW4gZGVzY3JpcHRvci5cblx0XHRcdHN0YXRlID0gXCJpbiBkZXNjcmlwdG9yXCI7XG5cblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cblx0XHRcdFx0Ly8gOC40LiBMZXQgYyBiZSB0aGUgY2hhcmFjdGVyIGF0IHBvc2l0aW9uLlxuXHRcdFx0XHRjID0gaW5wdXQuY2hhckF0KHBvcyk7XG5cblx0XHRcdFx0Ly8gIERvIHRoZSBmb2xsb3dpbmcgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBzdGF0ZS5cblx0XHRcdFx0Ly8gIEZvciB0aGUgcHVycG9zZSBvZiB0aGlzIHN0ZXAsIFwiRU9GXCIgaXMgYSBzcGVjaWFsIGNoYXJhY3RlciByZXByZXNlbnRpbmdcblx0XHRcdFx0Ly8gIHRoYXQgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LlxuXG5cdFx0XHRcdC8vIEluIGRlc2NyaXB0b3Jcblx0XHRcdFx0aWYgKHN0YXRlID09PSBcImluIGRlc2NyaXB0b3JcIikge1xuXHRcdFx0XHRcdC8vIERvIHRoZSBmb2xsb3dpbmcsIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgYzpcblxuXHRcdFx0XHRcdC8vIFNwYWNlIGNoYXJhY3RlclxuXHRcdFx0XHRcdC8vIElmIGN1cnJlbnQgZGVzY3JpcHRvciBpcyBub3QgZW1wdHksIGFwcGVuZCBjdXJyZW50IGRlc2NyaXB0b3IgdG9cblx0XHRcdFx0XHQvLyBkZXNjcmlwdG9ycyBhbmQgbGV0IGN1cnJlbnQgZGVzY3JpcHRvciBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuXHRcdFx0XHRcdC8vIFNldCBzdGF0ZSB0byBhZnRlciBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdGlmIChpc1NwYWNlKGMpKSB7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudERlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBcImFmdGVyIGRlc2NyaXB0b3JcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVSswMDJDIENPTU1BICgsKVxuXHRcdFx0XHRcdFx0Ly8gQWR2YW5jZSBwb3NpdGlvbiB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgaW4gaW5wdXQuIElmIGN1cnJlbnQgZGVzY3JpcHRvclxuXHRcdFx0XHRcdFx0Ly8gaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvIGRlc2NyaXB0b3JzLiBKdW1wIHRvIHRoZSBzdGVwXG5cdFx0XHRcdFx0XHQvLyBsYWJlbGVkIGRlc2NyaXB0b3IgcGFyc2VyLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gXCIsXCIpIHtcblx0XHRcdFx0XHRcdHBvcyArPSAxO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnREZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHQvLyBVKzAwMjggTEVGVCBQQVJFTlRIRVNJUyAoKClcblx0XHRcdFx0XHRcdC8vIEFwcGVuZCBjIHRvIGN1cnJlbnQgZGVzY3JpcHRvci4gU2V0IHN0YXRlIHRvIGluIHBhcmVucy5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXFx1MDAyOFwiKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcblx0XHRcdFx0XHRcdHN0YXRlID0gXCJpbiBwYXJlbnNcIjtcblxuXHRcdFx0XHRcdFx0Ly8gRU9GXG5cdFx0XHRcdFx0XHQvLyBJZiBjdXJyZW50IGRlc2NyaXB0b3IgaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvXG5cdFx0XHRcdFx0XHQvLyBkZXNjcmlwdG9ycy4gSnVtcCB0byB0aGUgc3RlcCBsYWJlbGVkIGRlc2NyaXB0b3IgcGFyc2VyLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnREZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlXG5cdFx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyAoZW5kIFwiaW4gZGVzY3JpcHRvclwiXG5cblx0XHRcdFx0XHQvLyBJbiBwYXJlbnNcblx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJpbiBwYXJlbnNcIikge1xuXG5cdFx0XHRcdFx0Ly8gVSswMDI5IFJJR0hUIFBBUkVOVEhFU0lTICgpKVxuXHRcdFx0XHRcdC8vIEFwcGVuZCBjIHRvIGN1cnJlbnQgZGVzY3JpcHRvci4gU2V0IHN0YXRlIHRvIGluIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0aWYgKGMgPT09IFwiKVwiKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcblx0XHRcdFx0XHRcdHN0YXRlID0gXCJpbiBkZXNjcmlwdG9yXCI7XG5cblx0XHRcdFx0XHRcdC8vIEVPRlxuXHRcdFx0XHRcdFx0Ly8gQXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0byBkZXNjcmlwdG9ycy4gSnVtcCB0byB0aGUgc3RlcCBsYWJlbGVkXG5cdFx0XHRcdFx0XHQvLyBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuXHRcdFx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlXG5cdFx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFmdGVyIGRlc2NyaXB0b3Jcblx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJhZnRlciBkZXNjcmlwdG9yXCIpIHtcblxuXHRcdFx0XHRcdC8vIERvIHRoZSBmb2xsb3dpbmcsIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgYzpcblx0XHRcdFx0XHQvLyBTcGFjZSBjaGFyYWN0ZXI6IFN0YXkgaW4gdGhpcyBzdGF0ZS5cblx0XHRcdFx0XHRpZiAoaXNTcGFjZShjKSkge1xuXG5cdFx0XHRcdFx0XHQvLyBFT0Y6IEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZVxuXHRcdFx0XHRcdFx0Ly8gU2V0IHN0YXRlIHRvIGluIGRlc2NyaXB0b3IuIFNldCBwb3NpdGlvbiB0byB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGluIGlucHV0LlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFwiaW4gZGVzY3JpcHRvclwiO1xuXHRcdFx0XHRcdFx0cG9zIC09IDE7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZHZhbmNlIHBvc2l0aW9uIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBpbiBpbnB1dC5cblx0XHRcdFx0cG9zICs9IDE7XG5cblx0XHRcdFx0Ly8gUmVwZWF0IHRoaXMgc3RlcC5cblx0XHRcdH0gLy8gKGNsb3NlIHdoaWxlIHRydWUgbG9vcClcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBBZGRzIGRlc2NyaXB0b3IgcHJvcGVydGllcyB0byBhIGNhbmRpZGF0ZSwgcHVzaGVzIHRvIHRoZSBjYW5kaWRhdGVzIGFycmF5XG5cdFx0ICogQHJldHVybiB1bmRlZmluZWRcblx0XHQgKi9cblx0XHQvLyBEZWNsYXJlZCBvdXRzaWRlIG9mIHRoZSB3aGlsZSBsb29wIHNvIHRoYXQgaXQncyBvbmx5IGNyZWF0ZWQgb25jZS5cblx0XHRmdW5jdGlvbiBwYXJzZURlc2NyaXB0b3JzKCkge1xuXG5cdFx0XHQvLyA5LiBEZXNjcmlwdG9yIHBhcnNlcjogTGV0IGVycm9yIGJlIG5vLlxuXHRcdFx0dmFyIHBFcnJvciA9IGZhbHNlLFxuXG5cdFx0XHRcdC8vIDEwLiBMZXQgd2lkdGggYmUgYWJzZW50LlxuXHRcdFx0XHQvLyAxMS4gTGV0IGRlbnNpdHkgYmUgYWJzZW50LlxuXHRcdFx0XHQvLyAxMi4gTGV0IGZ1dHVyZS1jb21wYXQtaCBiZSBhYnNlbnQuIChXZSdyZSBpbXBsZW1lbnRpbmcgaXQgbm93IGFzIGgpXG5cdFx0XHRcdHcsIGQsIGgsIGksXG5cdFx0XHRcdGNhbmRpZGF0ZSA9IHt9LFxuXHRcdFx0XHRkZXNjLCBsYXN0Q2hhciwgdmFsdWUsIGludFZhbCwgZmxvYXRWYWw7XG5cblx0XHRcdC8vIDEzLiBGb3IgZWFjaCBkZXNjcmlwdG9yIGluIGRlc2NyaXB0b3JzLCBydW4gdGhlIGFwcHJvcHJpYXRlIHNldCBvZiBzdGVwc1xuXHRcdFx0Ly8gZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG5cdFx0XHRmb3IgKGkgPSAwIDsgaSA8IGRlc2NyaXB0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc2MgPSBkZXNjcmlwdG9yc1sgaSBdO1xuXG5cdFx0XHRcdGxhc3RDaGFyID0gZGVzY1sgZGVzYy5sZW5ndGggLSAxIF07XG5cdFx0XHRcdHZhbHVlID0gZGVzYy5zdWJzdHJpbmcoMCwgZGVzYy5sZW5ndGggLSAxKTtcblx0XHRcdFx0aW50VmFsID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcblx0XHRcdFx0ZmxvYXRWYWwgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZGVzY3JpcHRvciBjb25zaXN0cyBvZiBhIHZhbGlkIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5XG5cdFx0XHRcdC8vIGEgVSswMDc3IExBVElOIFNNQUxMIExFVFRFUiBXIGNoYXJhY3RlclxuXHRcdFx0XHRpZiAocmVnZXhOb25OZWdhdGl2ZUludGVnZXIudGVzdCh2YWx1ZSkgJiYgKGxhc3RDaGFyID09PSBcIndcIikpIHtcblxuXHRcdFx0XHRcdC8vIElmIHdpZHRoIGFuZCBkZW5zaXR5IGFyZSBub3QgYm90aCBhYnNlbnQsIHRoZW4gbGV0IGVycm9yIGJlIHllcy5cblx0XHRcdFx0XHRpZiAodyB8fCBkKSB7cEVycm9yID0gdHJ1ZTt9XG5cblx0XHRcdFx0XHQvLyBBcHBseSB0aGUgcnVsZXMgZm9yIHBhcnNpbmcgbm9uLW5lZ2F0aXZlIGludGVnZXJzIHRvIHRoZSBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdC8vIElmIHRoZSByZXN1bHQgaXMgemVybywgbGV0IGVycm9yIGJlIHllcy5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGxldCB3aWR0aCBiZSB0aGUgcmVzdWx0LlxuXHRcdFx0XHRcdGlmIChpbnRWYWwgPT09IDApIHtwRXJyb3IgPSB0cnVlO30gZWxzZSB7dyA9IGludFZhbDt9XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgZGVzY3JpcHRvciBjb25zaXN0cyBvZiBhIHZhbGlkIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb2xsb3dlZCBieVxuXHRcdFx0XHRcdC8vIGEgVSswMDc4IExBVElOIFNNQUxMIExFVFRFUiBYIGNoYXJhY3RlclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlZ2V4RmxvYXRpbmdQb2ludC50ZXN0KHZhbHVlKSAmJiAobGFzdENoYXIgPT09IFwieFwiKSkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2lkdGgsIGRlbnNpdHkgYW5kIGZ1dHVyZS1jb21wYXQtaCBhcmUgbm90IGFsbCBhYnNlbnQsIHRoZW4gbGV0IGVycm9yXG5cdFx0XHRcdFx0Ly8gYmUgeWVzLlxuXHRcdFx0XHRcdGlmICh3IHx8IGQgfHwgaCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlciB2YWx1ZXMgdG8gdGhlIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHJlc3VsdCBpcyBsZXNzIHRoYW4gemVybywgbGV0IGVycm9yIGJlIHllcy4gT3RoZXJ3aXNlLCBsZXQgZGVuc2l0eVxuXHRcdFx0XHRcdC8vIGJlIHRoZSByZXN1bHQuXG5cdFx0XHRcdFx0aWYgKGZsb2F0VmFsIDwgMCkge3BFcnJvciA9IHRydWU7fSBlbHNlIHtkID0gZmxvYXRWYWw7fVxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBub24tbmVnYXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieVxuXHRcdFx0XHRcdC8vIGEgVSswMDY4IExBVElOIFNNQUxMIExFVFRFUiBIIGNoYXJhY3RlclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlZ2V4Tm9uTmVnYXRpdmVJbnRlZ2VyLnRlc3QodmFsdWUpICYmIChsYXN0Q2hhciA9PT0gXCJoXCIpKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBoZWlnaHQgYW5kIGRlbnNpdHkgYXJlIG5vdCBib3RoIGFic2VudCwgdGhlbiBsZXQgZXJyb3IgYmUgeWVzLlxuXHRcdFx0XHRcdGlmIChoIHx8IGQpIHtwRXJyb3IgPSB0cnVlO31cblxuXHRcdFx0XHRcdC8vIEFwcGx5IHRoZSBydWxlcyBmb3IgcGFyc2luZyBub24tbmVnYXRpdmUgaW50ZWdlcnMgdG8gdGhlIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHJlc3VsdCBpcyB6ZXJvLCBsZXQgZXJyb3IgYmUgeWVzLiBPdGhlcndpc2UsIGxldCBmdXR1cmUtY29tcGF0LWhcblx0XHRcdFx0XHQvLyBiZSB0aGUgcmVzdWx0LlxuXHRcdFx0XHRcdGlmIChpbnRWYWwgPT09IDApIHtwRXJyb3IgPSB0cnVlO30gZWxzZSB7aCA9IGludFZhbDt9XG5cblx0XHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlLCBMZXQgZXJyb3IgYmUgeWVzLlxuXHRcdFx0XHR9IGVsc2Uge3BFcnJvciA9IHRydWU7fVxuXHRcdFx0fSAvLyAoY2xvc2Ugc3RlcCAxMyBmb3IgbG9vcClcblxuXHRcdFx0Ly8gMTUuIElmIGVycm9yIGlzIHN0aWxsIG5vLCB0aGVuIGFwcGVuZCBhIG5ldyBpbWFnZSBzb3VyY2UgdG8gY2FuZGlkYXRlcyB3aG9zZVxuXHRcdFx0Ly8gVVJMIGlzIHVybCwgYXNzb2NpYXRlZCB3aXRoIGEgd2lkdGggd2lkdGggaWYgbm90IGFic2VudCBhbmQgYSBwaXhlbFxuXHRcdFx0Ly8gZGVuc2l0eSBkZW5zaXR5IGlmIG5vdCBhYnNlbnQuIE90aGVyd2lzZSwgdGhlcmUgaXMgYSBwYXJzZSBlcnJvci5cblx0XHRcdGlmICghcEVycm9yKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZS51cmwgPSB1cmw7XG5cdFx0XHRcdGlmICh3KSB7IGNhbmRpZGF0ZS53ID0gdzt9XG5cdFx0XHRcdGlmIChkKSB7IGNhbmRpZGF0ZS5kID0gZDt9XG5cdFx0XHRcdGlmIChoKSB7IGNhbmRpZGF0ZS5oID0gaDt9XG5cdFx0XHRcdGNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xuXHRcdFx0fSBlbHNlIGlmIChjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiSW52YWxpZCBzcmNzZXQgZGVzY3JpcHRvciBmb3VuZCBpbiAnXCIgK1xuXHRcdFx0XHRcdGlucHV0ICsgXCInIGF0ICdcIiArIGRlc2MgKyBcIicuXCIpO1xuXHRcdFx0fVxuXHRcdH0gLy8gKGNsb3NlIHBhcnNlRGVzY3JpcHRvcnMgZm4pXG5cblx0fVxufSkpO1xuIiwidmFyIHg9U3RyaW5nO1xudmFyIGNyZWF0ZT1mdW5jdGlvbigpIHtyZXR1cm4ge2lzQ29sb3JTdXBwb3J0ZWQ6ZmFsc2UscmVzZXQ6eCxib2xkOngsZGltOngsaXRhbGljOngsdW5kZXJsaW5lOngsaW52ZXJzZTp4LGhpZGRlbjp4LHN0cmlrZXRocm91Z2g6eCxibGFjazp4LHJlZDp4LGdyZWVuOngseWVsbG93OngsYmx1ZTp4LG1hZ2VudGE6eCxjeWFuOngsd2hpdGU6eCxncmF5OngsYmdCbGFjazp4LGJnUmVkOngsYmdHcmVlbjp4LGJnWWVsbG93OngsYmdCbHVlOngsYmdNYWdlbnRhOngsYmdDeWFuOngsYmdXaGl0ZTp4LGJsYWNrQnJpZ2h0OngscmVkQnJpZ2h0OngsZ3JlZW5CcmlnaHQ6eCx5ZWxsb3dCcmlnaHQ6eCxibHVlQnJpZ2h0OngsbWFnZW50YUJyaWdodDp4LGN5YW5CcmlnaHQ6eCx3aGl0ZUJyaWdodDp4LGJnQmxhY2tCcmlnaHQ6eCxiZ1JlZEJyaWdodDp4LGJnR3JlZW5CcmlnaHQ6eCxiZ1llbGxvd0JyaWdodDp4LGJnQmx1ZUJyaWdodDp4LGJnTWFnZW50YUJyaWdodDp4LGJnQ3lhbkJyaWdodDp4LGJnV2hpdGVCcmlnaHQ6eH19O1xubW9kdWxlLmV4cG9ydHM9Y3JlYXRlKCk7XG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGU7XG4iLCIndXNlIHN0cmljdCdcblxubGV0IENvbnRhaW5lciA9IHJlcXVpcmUoJy4vY29udGFpbmVyJylcblxuY2xhc3MgQXRSdWxlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAnYXRydWxlJ1xuICB9XG5cbiAgYXBwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICAgIHJldHVybiBzdXBlci5hcHBlbmQoLi4uY2hpbGRyZW4pXG4gIH1cblxuICBwcmVwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICAgIHJldHVybiBzdXBlci5wcmVwZW5kKC4uLmNoaWxkcmVuKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXRSdWxlXG5BdFJ1bGUuZGVmYXVsdCA9IEF0UnVsZVxuXG5Db250YWluZXIucmVnaXN0ZXJBdFJ1bGUoQXRSdWxlKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJylcblxuY2xhc3MgQ29tbWVudCBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKVxuICAgIHRoaXMudHlwZSA9ICdjb21tZW50J1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudFxuQ29tbWVudC5kZWZhdWx0ID0gQ29tbWVudFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBDb21tZW50ID0gcmVxdWlyZSgnLi9jb21tZW50JylcbmxldCBEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vZGVjbGFyYXRpb24nKVxubGV0IE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKVxubGV0IHsgaXNDbGVhbiwgbXkgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5cbmxldCBBdFJ1bGUsIHBhcnNlLCBSb290LCBSdWxlXG5cbmZ1bmN0aW9uIGNsZWFuU291cmNlKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5tYXAoaSA9PiB7XG4gICAgaWYgKGkubm9kZXMpIGkubm9kZXMgPSBjbGVhblNvdXJjZShpLm5vZGVzKVxuICAgIGRlbGV0ZSBpLnNvdXJjZVxuICAgIHJldHVybiBpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1hcmtUcmVlRGlydHkobm9kZSkge1xuICBub2RlW2lzQ2xlYW5dID0gZmFsc2VcbiAgaWYgKG5vZGUucHJveHlPZi5ub2Rlcykge1xuICAgIGZvciAobGV0IGkgb2Ygbm9kZS5wcm94eU9mLm5vZGVzKSB7XG4gICAgICBtYXJrVHJlZURpcnR5KGkpXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIE5vZGUge1xuICBhcHBlbmQoLi4uY2hpbGRyZW4pIHtcbiAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMubGFzdClcbiAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy5wdXNoKG5vZGUpXG4gICAgfVxuXG4gICAgdGhpcy5tYXJrRGlydHkoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgIHN1cGVyLmNsZWFuUmF3cyhrZWVwQmV0d2VlbilcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSBub2RlLmNsZWFuUmF3cyhrZWVwQmV0d2VlbilcbiAgICB9XG4gIH1cblxuICBlYWNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB1bmRlZmluZWRcbiAgICBsZXQgaXRlcmF0b3IgPSB0aGlzLmdldEl0ZXJhdG9yKClcblxuICAgIGxldCBpbmRleCwgcmVzdWx0XG4gICAgd2hpbGUgKHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPCB0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoKSB7XG4gICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpdGVyYXRvcl1cbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHRoaXMucHJveHlPZi5ub2Rlc1tpbmRleF0sIGluZGV4KVxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIGJyZWFrXG5cbiAgICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZXZlcnkoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuZXZlcnkoY29uZGl0aW9uKVxuICB9XG5cbiAgZ2V0SXRlcmF0b3IoKSB7XG4gICAgaWYgKCF0aGlzLmxhc3RFYWNoKSB0aGlzLmxhc3RFYWNoID0gMFxuICAgIGlmICghdGhpcy5pbmRleGVzKSB0aGlzLmluZGV4ZXMgPSB7fVxuXG4gICAgdGhpcy5sYXN0RWFjaCArPSAxXG4gICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5sYXN0RWFjaFxuICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPSAwXG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGdldFByb3h5UHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQobm9kZSwgcHJvcCkge1xuICAgICAgICBpZiAocHJvcCA9PT0gJ3Byb3h5T2YnKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgfSBlbHNlIGlmICghbm9kZVtwcm9wXSkge1xuICAgICAgICAgIHJldHVybiBub2RlW3Byb3BdXG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgcHJvcCA9PT0gJ2VhY2gnIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiBwcm9wLnN0YXJ0c1dpdGgoJ3dhbGsnKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtwcm9wXShcbiAgICAgICAgICAgICAgLi4uYXJncy5tYXAoaSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKGNoaWxkLCBpbmRleCkgPT4gaShjaGlsZC50b1Byb3h5KCksIGluZGV4KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2V2ZXJ5JyB8fCBwcm9wID09PSAnc29tZScpIHtcbiAgICAgICAgICByZXR1cm4gY2IgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVbcHJvcF0oKGNoaWxkLCAuLi5vdGhlcikgPT5cbiAgICAgICAgICAgICAgY2IoY2hpbGQudG9Qcm94eSgpLCAuLi5vdGhlcilcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IG5vZGUucm9vdCgpLnRvUHJveHkoKVxuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdub2RlcycpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5ub2Rlcy5tYXAoaSA9PiBpLnRvUHJveHkoKSlcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnZmlyc3QnIHx8IHByb3AgPT09ICdsYXN0Jykge1xuICAgICAgICAgIHJldHVybiBub2RlW3Byb3BdLnRvUHJveHkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub2RlW3Byb3BdXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNldChub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZVtwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlXG4gICAgICAgIG5vZGVbcHJvcF0gPSB2YWx1ZVxuICAgICAgICBpZiAocHJvcCA9PT0gJ25hbWUnIHx8IHByb3AgPT09ICdwYXJhbXMnIHx8IHByb3AgPT09ICdzZWxlY3RvcicpIHtcbiAgICAgICAgICBub2RlLm1hcmtEaXJ0eSgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbmRleChjaGlsZCkge1xuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSByZXR1cm4gY2hpbGRcbiAgICBpZiAoY2hpbGQucHJveHlPZikgY2hpbGQgPSBjaGlsZC5wcm94eU9mXG4gICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlcy5pbmRleE9mKGNoaWxkKVxuICB9XG5cbiAgaW5zZXJ0QWZ0ZXIoZXhpc3QsIGFkZCkge1xuICAgIGxldCBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdClcbiAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSkucmV2ZXJzZSgpXG4gICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpXG4gICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4ICsgMSwgMCwgbm9kZSlcblxuICAgIGxldCBpbmRleFxuICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXggPSB0aGlzLmluZGV4ZXNbaWRdXG4gICAgICBpZiAoZXhpc3RJbmRleCA8IGluZGV4KSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleCArIG5vZGVzLmxlbmd0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWFya0RpcnR5KClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpbnNlcnRCZWZvcmUoZXhpc3QsIGFkZCkge1xuICAgIGxldCBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdClcbiAgICBsZXQgdHlwZSA9IGV4aXN0SW5kZXggPT09IDAgPyAncHJlcGVuZCcgOiBmYWxzZVxuICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKFxuICAgICAgYWRkLFxuICAgICAgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdLFxuICAgICAgdHlwZVxuICAgICkucmV2ZXJzZSgpXG4gICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpXG4gICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4LCAwLCBub2RlKVxuXG4gICAgbGV0IGluZGV4XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF1cbiAgICAgIGlmIChleGlzdEluZGV4IDw9IGluZGV4KSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleCArIG5vZGVzLmxlbmd0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWFya0RpcnR5KClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBub3JtYWxpemUobm9kZXMsIHNhbXBsZSkge1xuICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBub2RlcyA9IGNsZWFuU291cmNlKHBhcnNlKG5vZGVzKS5ub2RlcylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5vZGVzID0gW11cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICBub2RlcyA9IG5vZGVzLnNsaWNlKDApXG4gICAgICBmb3IgKGxldCBpIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChpLnBhcmVudCkgaS5wYXJlbnQucmVtb3ZlQ2hpbGQoaSwgJ2lnbm9yZScpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2Rlcy50eXBlID09PSAncm9vdCcgJiYgdGhpcy50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICBub2RlcyA9IG5vZGVzLm5vZGVzLnNsaWNlKDApXG4gICAgICBmb3IgKGxldCBpIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChpLnBhcmVudCkgaS5wYXJlbnQucmVtb3ZlQ2hpbGQoaSwgJ2lnbm9yZScpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2Rlcy50eXBlKSB7XG4gICAgICBub2RlcyA9IFtub2Rlc11cbiAgICB9IGVsc2UgaWYgKG5vZGVzLnByb3ApIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgZmllbGQgaXMgbWlzc2VkIGluIG5vZGUgY3JlYXRpb24nKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5vZGVzLnZhbHVlID0gU3RyaW5nKG5vZGVzLnZhbHVlKVxuICAgICAgfVxuICAgICAgbm9kZXMgPSBbbmV3IERlY2xhcmF0aW9uKG5vZGVzKV1cbiAgICB9IGVsc2UgaWYgKG5vZGVzLnNlbGVjdG9yIHx8IG5vZGVzLnNlbGVjdG9ycykge1xuICAgICAgbm9kZXMgPSBbbmV3IFJ1bGUobm9kZXMpXVxuICAgIH0gZWxzZSBpZiAobm9kZXMubmFtZSkge1xuICAgICAgbm9kZXMgPSBbbmV3IEF0UnVsZShub2RlcyldXG4gICAgfSBlbHNlIGlmIChub2Rlcy50ZXh0KSB7XG4gICAgICBub2RlcyA9IFtuZXcgQ29tbWVudChub2RlcyldXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGUgaW4gbm9kZSBjcmVhdGlvbicpXG4gICAgfVxuXG4gICAgbGV0IHByb2Nlc3NlZCA9IG5vZGVzLm1hcChpID0+IHtcbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoIWlbbXldKSBDb250YWluZXIucmVidWlsZChpKVxuICAgICAgaSA9IGkucHJveHlPZlxuICAgICAgaWYgKGkucGFyZW50KSBpLnBhcmVudC5yZW1vdmVDaGlsZChpKVxuICAgICAgaWYgKGlbaXNDbGVhbl0pIG1hcmtUcmVlRGlydHkoaSlcbiAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJlZm9yZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHNhbXBsZSAmJiB0eXBlb2Ygc2FtcGxlLnJhd3MuYmVmb3JlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGkucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmUucmVwbGFjZSgvXFxTL2csICcnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpLnBhcmVudCA9IHRoaXMucHJveHlPZlxuICAgICAgcmV0dXJuIGlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZFxuICB9XG5cbiAgcHJlcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ucmV2ZXJzZSgpXG4gICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmZpcnN0LCAncHJlcGVuZCcpLnJldmVyc2UoKVxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnVuc2hpZnQobm9kZSlcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gdGhpcy5pbmRleGVzW2lkXSArIG5vZGVzLmxlbmd0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWFya0RpcnR5KClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdXNoKGNoaWxkKSB7XG4gICAgY2hpbGQucGFyZW50ID0gdGhpc1xuICAgIHRoaXMucHJveHlPZi5ub2Rlcy5wdXNoKGNoaWxkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZW1vdmVBbGwoKSB7XG4gICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLnByb3h5T2Yubm9kZXMpIG5vZGUucGFyZW50ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5wcm94eU9mLm5vZGVzID0gW11cblxuICAgIHRoaXMubWFya0RpcnR5KClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgIGNoaWxkID0gdGhpcy5pbmRleChjaGlsZClcbiAgICB0aGlzLnByb3h5T2Yubm9kZXNbY2hpbGRdLnBhcmVudCA9IHVuZGVmaW5lZFxuICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpXG5cbiAgICBsZXQgaW5kZXhcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXVxuICAgICAgaWYgKGluZGV4ID49IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleCAtIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1hcmtEaXJ0eSgpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVwbGFjZVZhbHVlcyhwYXR0ZXJuLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0c1xuICAgICAgb3B0cyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy53YWxrRGVjbHMoZGVjbCA9PiB7XG4gICAgICBpZiAob3B0cy5wcm9wcyAmJiAhb3B0cy5wcm9wcy5pbmNsdWRlcyhkZWNsLnByb3ApKSByZXR1cm5cbiAgICAgIGlmIChvcHRzLmZhc3QgJiYgIWRlY2wudmFsdWUuaW5jbHVkZXMob3B0cy5mYXN0KSkgcmV0dXJuXG5cbiAgICAgIGRlY2wudmFsdWUgPSBkZWNsLnZhbHVlLnJlcGxhY2UocGF0dGVybiwgY2FsbGJhY2spXG4gICAgfSlcblxuICAgIHRoaXMubWFya0RpcnR5KClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzb21lKGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY29uZGl0aW9uKVxuICB9XG5cbiAgd2FsayhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgY2hpbGQuYWRkVG9FcnJvcihlKVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UgJiYgY2hpbGQud2Fsaykge1xuICAgICAgICByZXN1bHQgPSBjaGlsZC53YWxrKGNhbGxiYWNrKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSlcbiAgfVxuXG4gIHdhbGtBdFJ1bGVzKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBuYW1lXG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2F0cnVsZScpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChuYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2F0cnVsZScgJiYgbmFtZS50ZXN0KGNoaWxkLm5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdhdHJ1bGUnICYmIGNoaWxkLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB3YWxrQ29tbWVudHMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdjb21tZW50Jykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHdhbGtEZWNscyhwcm9wLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gcHJvcFxuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdkZWNsJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHByb3AgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZGVjbCcgJiYgcHJvcC50ZXN0KGNoaWxkLnByb3ApKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdkZWNsJyAmJiBjaGlsZC5wcm9wID09PSBwcm9wKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd2Fsa1J1bGVzKHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3JcblxuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdydWxlJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3J1bGUnICYmIHNlbGVjdG9yLnRlc3QoY2hpbGQuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdydWxlJyAmJiBjaGlsZC5zZWxlY3RvciA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBnZXQgZmlyc3QoKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzWzBdXG4gIH1cblxuICBnZXQgbGFzdCgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCAtIDFdXG4gIH1cbn1cblxuQ29udGFpbmVyLnJlZ2lzdGVyUGFyc2UgPSBkZXBlbmRhbnQgPT4ge1xuICBwYXJzZSA9IGRlcGVuZGFudFxufVxuXG5Db250YWluZXIucmVnaXN0ZXJSdWxlID0gZGVwZW5kYW50ID0+IHtcbiAgUnVsZSA9IGRlcGVuZGFudFxufVxuXG5Db250YWluZXIucmVnaXN0ZXJBdFJ1bGUgPSBkZXBlbmRhbnQgPT4ge1xuICBBdFJ1bGUgPSBkZXBlbmRhbnRcbn1cblxuQ29udGFpbmVyLnJlZ2lzdGVyUm9vdCA9IGRlcGVuZGFudCA9PiB7XG4gIFJvb3QgPSBkZXBlbmRhbnRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluZXJcbkNvbnRhaW5lci5kZWZhdWx0ID0gQ29udGFpbmVyXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuQ29udGFpbmVyLnJlYnVpbGQgPSBub2RlID0+IHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2F0cnVsZScpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZSwgQXRSdWxlLnByb3RvdHlwZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdydWxlJykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlLCBSdWxlLnByb3RvdHlwZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdkZWNsJykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlLCBEZWNsYXJhdGlvbi5wcm90b3R5cGUpXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnY29tbWVudCcpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZSwgQ29tbWVudC5wcm90b3R5cGUpXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAncm9vdCcpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZSwgUm9vdC5wcm90b3R5cGUpXG4gIH1cblxuICBub2RlW215XSA9IHRydWVcblxuICBpZiAobm9kZS5ub2Rlcykge1xuICAgIG5vZGUubm9kZXMuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBDb250YWluZXIucmVidWlsZChjaGlsZClcbiAgICB9KVxuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBwaWNvID0gcmVxdWlyZSgncGljb2NvbG9ycycpXG5cbmxldCB0ZXJtaW5hbEhpZ2hsaWdodCA9IHJlcXVpcmUoJy4vdGVybWluYWwtaGlnaGxpZ2h0JylcblxuY2xhc3MgQ3NzU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgc291cmNlLCBmaWxlLCBwbHVnaW4pIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdDc3NTeW50YXhFcnJvcidcbiAgICB0aGlzLnJlYXNvbiA9IG1lc3NhZ2VcblxuICAgIGlmIChmaWxlKSB7XG4gICAgICB0aGlzLmZpbGUgPSBmaWxlXG4gICAgfVxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlXG4gICAgfVxuICAgIGlmIChwbHVnaW4pIHtcbiAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luXG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbHVtbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZVxuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZS5saW5lXG4gICAgICAgIHRoaXMuY29sdW1uID0gbGluZS5jb2x1bW5cbiAgICAgICAgdGhpcy5lbmRMaW5lID0gY29sdW1uLmxpbmVcbiAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSBjb2x1bW4uY29sdW1uXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRNZXNzYWdlKClcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3NzU3ludGF4RXJyb3IpXG4gICAgfVxuICB9XG5cbiAgc2V0TWVzc2FnZSgpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBsdWdpbiA/IHRoaXMucGx1Z2luICsgJzogJyA6ICcnXG4gICAgdGhpcy5tZXNzYWdlICs9IHRoaXMuZmlsZSA/IHRoaXMuZmlsZSA6ICc8Y3NzIGlucHV0PidcbiAgICBpZiAodHlwZW9mIHRoaXMubGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMubWVzc2FnZSArPSAnOicgKyB0aGlzLmxpbmUgKyAnOicgKyB0aGlzLmNvbHVtblxuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgKz0gJzogJyArIHRoaXMucmVhc29uXG4gIH1cblxuICBzaG93U291cmNlQ29kZShjb2xvcikge1xuICAgIGlmICghdGhpcy5zb3VyY2UpIHJldHVybiAnJ1xuXG4gICAgbGV0IGNzcyA9IHRoaXMuc291cmNlXG4gICAgaWYgKGNvbG9yID09IG51bGwpIGNvbG9yID0gcGljby5pc0NvbG9yU3VwcG9ydGVkXG5cbiAgICBsZXQgYXNpZGUgPSB0ZXh0ID0+IHRleHRcbiAgICBsZXQgbWFyayA9IHRleHQgPT4gdGV4dFxuICAgIGxldCBoaWdobGlnaHQgPSB0ZXh0ID0+IHRleHRcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGxldCB7IGJvbGQsIGdyYXksIHJlZCB9ID0gcGljby5jcmVhdGVDb2xvcnModHJ1ZSlcbiAgICAgIG1hcmsgPSB0ZXh0ID0+IGJvbGQocmVkKHRleHQpKVxuICAgICAgYXNpZGUgPSB0ZXh0ID0+IGdyYXkodGV4dClcbiAgICAgIGlmICh0ZXJtaW5hbEhpZ2hsaWdodCkge1xuICAgICAgICBoaWdobGlnaHQgPSB0ZXh0ID0+IHRlcm1pbmFsSGlnaGxpZ2h0KHRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGxpbmVzID0gY3NzLnNwbGl0KC9cXHI/XFxuLylcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCh0aGlzLmxpbmUgLSAzLCAwKVxuICAgIGxldCBlbmQgPSBNYXRoLm1pbih0aGlzLmxpbmUgKyAyLCBsaW5lcy5sZW5ndGgpXG4gICAgbGV0IG1heFdpZHRoID0gU3RyaW5nKGVuZCkubGVuZ3RoXG5cbiAgICByZXR1cm4gbGluZXNcbiAgICAgIC5zbGljZShzdGFydCwgZW5kKVxuICAgICAgLm1hcCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IG51bWJlciA9IHN0YXJ0ICsgMSArIGluZGV4XG4gICAgICAgIGxldCBndXR0ZXIgPSAnICcgKyAoJyAnICsgbnVtYmVyKS5zbGljZSgtbWF4V2lkdGgpICsgJyB8ICdcbiAgICAgICAgaWYgKG51bWJlciA9PT0gdGhpcy5saW5lKSB7XG4gICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMTYwKSB7XG4gICAgICAgICAgICBsZXQgcGFkZGluZyA9IDIwXG4gICAgICAgICAgICBsZXQgc3ViTGluZVN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5jb2x1bW4gLSBwYWRkaW5nKVxuICAgICAgICAgICAgbGV0IHN1YkxpbmVFbmQgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgdGhpcy5jb2x1bW4gKyBwYWRkaW5nLFxuICAgICAgICAgICAgICB0aGlzLmVuZENvbHVtbiArIHBhZGRpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGxldCBzdWJMaW5lID0gbGluZS5zbGljZShzdWJMaW5lU3RhcnQsIHN1YkxpbmVFbmQpXG5cbiAgICAgICAgICAgIGxldCBzcGFjaW5nID1cbiAgICAgICAgICAgICAgYXNpZGUoZ3V0dGVyLnJlcGxhY2UoL1xcZC9nLCAnICcpKSArXG4gICAgICAgICAgICAgIGxpbmVcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgTWF0aC5taW4odGhpcy5jb2x1bW4gLSAxLCBwYWRkaW5nIC0gMSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1teXFx0XS9nLCAnICcpXG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIG1hcmsoJz4nKSArXG4gICAgICAgICAgICAgIGFzaWRlKGd1dHRlcikgK1xuICAgICAgICAgICAgICBoaWdobGlnaHQoc3ViTGluZSkgK1xuICAgICAgICAgICAgICAnXFxuICcgK1xuICAgICAgICAgICAgICBzcGFjaW5nICtcbiAgICAgICAgICAgICAgbWFyaygnXicpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHNwYWNpbmcgPVxuICAgICAgICAgICAgYXNpZGUoZ3V0dGVyLnJlcGxhY2UoL1xcZC9nLCAnICcpKSArXG4gICAgICAgICAgICBsaW5lLnNsaWNlKDAsIHRoaXMuY29sdW1uIC0gMSkucmVwbGFjZSgvW15cXHRdL2csICcgJylcblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBtYXJrKCc+JykgK1xuICAgICAgICAgICAgYXNpZGUoZ3V0dGVyKSArXG4gICAgICAgICAgICBoaWdobGlnaHQobGluZSkgK1xuICAgICAgICAgICAgJ1xcbiAnICtcbiAgICAgICAgICAgIHNwYWNpbmcgK1xuICAgICAgICAgICAgbWFyaygnXicpXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcgJyArIGFzaWRlKGd1dHRlcikgKyBoaWdobGlnaHQobGluZSlcbiAgICAgIH0pXG4gICAgICAuam9pbignXFxuJylcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBjb2RlID0gdGhpcy5zaG93U291cmNlQ29kZSgpXG4gICAgaWYgKGNvZGUpIHtcbiAgICAgIGNvZGUgPSAnXFxuXFxuJyArIGNvZGUgKyAnXFxuJ1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIHRoaXMubWVzc2FnZSArIGNvZGVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENzc1N5bnRheEVycm9yXG5Dc3NTeW50YXhFcnJvci5kZWZhdWx0ID0gQ3NzU3ludGF4RXJyb3JcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpXG5cbmNsYXNzIERlY2xhcmF0aW9uIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgaWYgKFxuICAgICAgZGVmYXVsdHMgJiZcbiAgICAgIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIGRlZmF1bHRzID0geyAuLi5kZWZhdWx0cywgdmFsdWU6IFN0cmluZyhkZWZhdWx0cy52YWx1ZSkgfVxuICAgIH1cbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAnZGVjbCdcbiAgfVxuXG4gIGdldCB2YXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLnN0YXJ0c1dpdGgoJy0tJykgfHwgdGhpcy5wcm9wWzBdID09PSAnJCdcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERlY2xhcmF0aW9uXG5EZWNsYXJhdGlvbi5kZWZhdWx0ID0gRGVjbGFyYXRpb25cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXInKVxuXG5sZXQgTGF6eVJlc3VsdCwgUHJvY2Vzc29yXG5cbmNsYXNzIERvY3VtZW50IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICAvLyB0eXBlIG5lZWRzIHRvIGJlIHBhc3NlZCB0byBzdXBlciwgb3RoZXJ3aXNlIGNoaWxkIHJvb3RzIHdvbid0IGJlIG5vcm1hbGl6ZWQgY29ycmVjdGx5XG4gICAgc3VwZXIoeyB0eXBlOiAnZG9jdW1lbnQnLCAuLi5kZWZhdWx0cyB9KVxuXG4gICAgaWYgKCF0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLm5vZGVzID0gW11cbiAgICB9XG4gIH1cblxuICB0b1Jlc3VsdChvcHRzID0ge30pIHtcbiAgICBsZXQgbGF6eSA9IG5ldyBMYXp5UmVzdWx0KG5ldyBQcm9jZXNzb3IoKSwgdGhpcywgb3B0cylcblxuICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpXG4gIH1cbn1cblxuRG9jdW1lbnQucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZGVwZW5kYW50ID0+IHtcbiAgTGF6eVJlc3VsdCA9IGRlcGVuZGFudFxufVxuXG5Eb2N1bWVudC5yZWdpc3RlclByb2Nlc3NvciA9IGRlcGVuZGFudCA9PiB7XG4gIFByb2Nlc3NvciA9IGRlcGVuZGFudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50XG5Eb2N1bWVudC5kZWZhdWx0ID0gRG9jdW1lbnRcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgQXRSdWxlID0gcmVxdWlyZSgnLi9hdC1ydWxlJylcbmxldCBDb21tZW50ID0gcmVxdWlyZSgnLi9jb21tZW50JylcbmxldCBEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vZGVjbGFyYXRpb24nKVxubGV0IElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpXG5sZXQgUHJldmlvdXNNYXAgPSByZXF1aXJlKCcuL3ByZXZpb3VzLW1hcCcpXG5sZXQgUm9vdCA9IHJlcXVpcmUoJy4vcm9vdCcpXG5sZXQgUnVsZSA9IHJlcXVpcmUoJy4vcnVsZScpXG5cbmZ1bmN0aW9uIGZyb21KU09OKGpzb24sIGlucHV0cykge1xuICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkgcmV0dXJuIGpzb24ubWFwKG4gPT4gZnJvbUpTT04obikpXG5cbiAgbGV0IHsgaW5wdXRzOiBvd25JbnB1dHMsIC4uLmRlZmF1bHRzIH0gPSBqc29uXG4gIGlmIChvd25JbnB1dHMpIHtcbiAgICBpbnB1dHMgPSBbXVxuICAgIGZvciAobGV0IGlucHV0IG9mIG93bklucHV0cykge1xuICAgICAgbGV0IGlucHV0SHlkcmF0ZWQgPSB7IC4uLmlucHV0LCBfX3Byb3RvX186IElucHV0LnByb3RvdHlwZSB9XG4gICAgICBpZiAoaW5wdXRIeWRyYXRlZC5tYXApIHtcbiAgICAgICAgaW5wdXRIeWRyYXRlZC5tYXAgPSB7XG4gICAgICAgICAgLi4uaW5wdXRIeWRyYXRlZC5tYXAsXG4gICAgICAgICAgX19wcm90b19fOiBQcmV2aW91c01hcC5wcm90b3R5cGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5wdXRzLnB1c2goaW5wdXRIeWRyYXRlZClcbiAgICB9XG4gIH1cbiAgaWYgKGRlZmF1bHRzLm5vZGVzKSB7XG4gICAgZGVmYXVsdHMubm9kZXMgPSBqc29uLm5vZGVzLm1hcChuID0+IGZyb21KU09OKG4sIGlucHV0cykpXG4gIH1cbiAgaWYgKGRlZmF1bHRzLnNvdXJjZSkge1xuICAgIGxldCB7IGlucHV0SWQsIC4uLnNvdXJjZSB9ID0gZGVmYXVsdHMuc291cmNlXG4gICAgZGVmYXVsdHMuc291cmNlID0gc291cmNlXG4gICAgaWYgKGlucHV0SWQgIT0gbnVsbCkge1xuICAgICAgZGVmYXVsdHMuc291cmNlLmlucHV0ID0gaW5wdXRzW2lucHV0SWRdXG4gICAgfVxuICB9XG4gIGlmIChkZWZhdWx0cy50eXBlID09PSAncm9vdCcpIHtcbiAgICByZXR1cm4gbmV3IFJvb3QoZGVmYXVsdHMpXG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gJ2RlY2wnKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihkZWZhdWx0cylcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSAncnVsZScpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUoZGVmYXVsdHMpXG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgcmV0dXJuIG5ldyBDb21tZW50KGRlZmF1bHRzKVxuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09ICdhdHJ1bGUnKSB7XG4gICAgcmV0dXJuIG5ldyBBdFJ1bGUoZGVmYXVsdHMpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZTogJyArIGpzb24udHlwZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZyb21KU09OXG5mcm9tSlNPTi5kZWZhdWx0ID0gZnJvbUpTT05cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgeyBuYW5vaWQgfSA9IHJlcXVpcmUoJ25hbm9pZC9ub24tc2VjdXJlJylcbmxldCB7IGlzQWJzb2x1dGUsIHJlc29sdmUgfSA9IHJlcXVpcmUoJ3BhdGgnKVxubGV0IHsgU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciB9ID0gcmVxdWlyZSgnc291cmNlLW1hcC1qcycpXG5sZXQgeyBmaWxlVVJMVG9QYXRoLCBwYXRoVG9GaWxlVVJMIH0gPSByZXF1aXJlKCd1cmwnKVxuXG5sZXQgQ3NzU3ludGF4RXJyb3IgPSByZXF1aXJlKCcuL2Nzcy1zeW50YXgtZXJyb3InKVxubGV0IFByZXZpb3VzTWFwID0gcmVxdWlyZSgnLi9wcmV2aW91cy1tYXAnKVxubGV0IHRlcm1pbmFsSGlnaGxpZ2h0ID0gcmVxdWlyZSgnLi90ZXJtaW5hbC1oaWdobGlnaHQnKVxuXG5sZXQgZnJvbU9mZnNldENhY2hlID0gU3ltYm9sKCdmcm9tT2Zmc2V0Q2FjaGUnKVxuXG5sZXQgc291cmNlTWFwQXZhaWxhYmxlID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciAmJiBTb3VyY2VNYXBHZW5lcmF0b3IpXG5sZXQgcGF0aEF2YWlsYWJsZSA9IEJvb2xlYW4ocmVzb2x2ZSAmJiBpc0Fic29sdXRlKVxuXG5jbGFzcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKGNzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKFxuICAgICAgY3NzID09PSBudWxsIHx8XG4gICAgICB0eXBlb2YgY3NzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgKHR5cGVvZiBjc3MgPT09ICdvYmplY3QnICYmICFjc3MudG9TdHJpbmcpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc3RDU1MgcmVjZWl2ZWQgJHtjc3N9IGluc3RlYWQgb2YgQ1NTIHN0cmluZ2ApXG4gICAgfVxuXG4gICAgdGhpcy5jc3MgPSBjc3MudG9TdHJpbmcoKVxuXG4gICAgaWYgKHRoaXMuY3NzWzBdID09PSAnXFx1RkVGRicgfHwgdGhpcy5jc3NbMF0gPT09ICdcXHVGRkZFJykge1xuICAgICAgdGhpcy5oYXNCT00gPSB0cnVlXG4gICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnNsaWNlKDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAob3B0cy5mcm9tKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFwYXRoQXZhaWxhYmxlIHx8XG4gICAgICAgIC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKSB8fFxuICAgICAgICBpc0Fic29sdXRlKG9wdHMuZnJvbSlcbiAgICAgICkge1xuICAgICAgICB0aGlzLmZpbGUgPSBvcHRzLmZyb21cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IHJlc29sdmUob3B0cy5mcm9tKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXRoQXZhaWxhYmxlICYmIHNvdXJjZU1hcEF2YWlsYWJsZSkge1xuICAgICAgbGV0IG1hcCA9IG5ldyBQcmV2aW91c01hcCh0aGlzLmNzcywgb3B0cylcbiAgICAgIGlmIChtYXAudGV4dCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcFxuICAgICAgICBsZXQgZmlsZSA9IG1hcC5jb25zdW1lcigpLmZpbGVcbiAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgZmlsZSkgdGhpcy5maWxlID0gdGhpcy5tYXBSZXNvbHZlKGZpbGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZpbGUpIHtcbiAgICAgIHRoaXMuaWQgPSAnPGlucHV0IGNzcyAnICsgbmFub2lkKDYpICsgJz4nXG4gICAgfVxuICAgIGlmICh0aGlzLm1hcCkgdGhpcy5tYXAuZmlsZSA9IHRoaXMuZnJvbVxuICB9XG5cbiAgZXJyb3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBvcHRzID0ge30pIHtcbiAgICBsZXQgZW5kQ29sdW1uLCBlbmRMaW5lLCByZXN1bHRcblxuICAgIGlmIChsaW5lICYmIHR5cGVvZiBsaW5lID09PSAnb2JqZWN0Jykge1xuICAgICAgbGV0IHN0YXJ0ID0gbGluZVxuICAgICAgbGV0IGVuZCA9IGNvbHVtblxuICAgICAgaWYgKHR5cGVvZiBzdGFydC5vZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQoc3RhcnQub2Zmc2V0KVxuICAgICAgICBsaW5lID0gcG9zLmxpbmVcbiAgICAgICAgY29sdW1uID0gcG9zLmNvbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZSA9IHN0YXJ0LmxpbmVcbiAgICAgICAgY29sdW1uID0gc3RhcnQuY29sdW1uXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZC5vZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQoZW5kLm9mZnNldClcbiAgICAgICAgZW5kTGluZSA9IHBvcy5saW5lXG4gICAgICAgIGVuZENvbHVtbiA9IHBvcy5jb2xcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZExpbmUgPSBlbmQubGluZVxuICAgICAgICBlbmRDb2x1bW4gPSBlbmQuY29sdW1uXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghY29sdW1uKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KGxpbmUpXG4gICAgICBsaW5lID0gcG9zLmxpbmVcbiAgICAgIGNvbHVtbiA9IHBvcy5jb2xcbiAgICB9XG5cbiAgICBsZXQgb3JpZ2luID0gdGhpcy5vcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pXG4gICAgaWYgKG9yaWdpbikge1xuICAgICAgcmVzdWx0ID0gbmV3IENzc1N5bnRheEVycm9yKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBvcmlnaW4uZW5kTGluZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBvcmlnaW4ubGluZVxuICAgICAgICAgIDogeyBjb2x1bW46IG9yaWdpbi5jb2x1bW4sIGxpbmU6IG9yaWdpbi5saW5lIH0sXG4gICAgICAgIG9yaWdpbi5lbmRMaW5lID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IG9yaWdpbi5jb2x1bW5cbiAgICAgICAgICA6IHsgY29sdW1uOiBvcmlnaW4uZW5kQ29sdW1uLCBsaW5lOiBvcmlnaW4uZW5kTGluZSB9LFxuICAgICAgICBvcmlnaW4uc291cmNlLFxuICAgICAgICBvcmlnaW4uZmlsZSxcbiAgICAgICAgb3B0cy5wbHVnaW5cbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gbmV3IENzc1N5bnRheEVycm9yKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBlbmRMaW5lID09PSB1bmRlZmluZWQgPyBsaW5lIDogeyBjb2x1bW4sIGxpbmUgfSxcbiAgICAgICAgZW5kTGluZSA9PT0gdW5kZWZpbmVkID8gY29sdW1uIDogeyBjb2x1bW46IGVuZENvbHVtbiwgbGluZTogZW5kTGluZSB9LFxuICAgICAgICB0aGlzLmNzcyxcbiAgICAgICAgdGhpcy5maWxlLFxuICAgICAgICBvcHRzLnBsdWdpblxuICAgICAgKVxuICAgIH1cblxuICAgIHJlc3VsdC5pbnB1dCA9IHsgY29sdW1uLCBlbmRDb2x1bW4sIGVuZExpbmUsIGxpbmUsIHNvdXJjZTogdGhpcy5jc3MgfVxuICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgIGlmIChwYXRoVG9GaWxlVVJMKSB7XG4gICAgICAgIHJlc3VsdC5pbnB1dC51cmwgPSBwYXRoVG9GaWxlVVJMKHRoaXMuZmlsZSkudG9TdHJpbmcoKVxuICAgICAgfVxuICAgICAgcmVzdWx0LmlucHV0LmZpbGUgPSB0aGlzLmZpbGVcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmcm9tT2Zmc2V0KG9mZnNldCkge1xuICAgIGxldCBsYXN0TGluZSwgbGluZVRvSW5kZXhcbiAgICBpZiAoIXRoaXNbZnJvbU9mZnNldENhY2hlXSkge1xuICAgICAgbGV0IGxpbmVzID0gdGhpcy5jc3Muc3BsaXQoJ1xcbicpXG4gICAgICBsaW5lVG9JbmRleCA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpXG4gICAgICBsZXQgcHJldkluZGV4ID0gMFxuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBsaW5lVG9JbmRleFtpXSA9IHByZXZJbmRleFxuICAgICAgICBwcmV2SW5kZXggKz0gbGluZXNbaV0ubGVuZ3RoICsgMVxuICAgICAgfVxuXG4gICAgICB0aGlzW2Zyb21PZmZzZXRDYWNoZV0gPSBsaW5lVG9JbmRleFxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lVG9JbmRleCA9IHRoaXNbZnJvbU9mZnNldENhY2hlXVxuICAgIH1cbiAgICBsYXN0TGluZSA9IGxpbmVUb0luZGV4W2xpbmVUb0luZGV4Lmxlbmd0aCAtIDFdXG5cbiAgICBsZXQgbWluID0gMFxuICAgIGlmIChvZmZzZXQgPj0gbGFzdExpbmUpIHtcbiAgICAgIG1pbiA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDFcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1heCA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDJcbiAgICAgIGxldCBtaWRcbiAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICAgICAgbWlkID0gbWluICsgKChtYXggLSBtaW4pID4+IDEpXG4gICAgICAgIGlmIChvZmZzZXQgPCBsaW5lVG9JbmRleFttaWRdKSB7XG4gICAgICAgICAgbWF4ID0gbWlkIC0gMVxuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA+PSBsaW5lVG9JbmRleFttaWQgKyAxXSkge1xuICAgICAgICAgIG1pbiA9IG1pZCArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW4gPSBtaWRcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb2w6IG9mZnNldCAtIGxpbmVUb0luZGV4W21pbl0gKyAxLFxuICAgICAgbGluZTogbWluICsgMVxuICAgIH1cbiAgfVxuXG4gIG1hcFJlc29sdmUoZmlsZSkge1xuICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSB7XG4gICAgICByZXR1cm4gZmlsZVxuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLm1hcC5jb25zdW1lcigpLnNvdXJjZVJvb3QgfHwgdGhpcy5tYXAucm9vdCB8fCAnLicsIGZpbGUpXG4gIH1cblxuICBvcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pIHtcbiAgICBpZiAoIXRoaXMubWFwKSByZXR1cm4gZmFsc2VcbiAgICBsZXQgY29uc3VtZXIgPSB0aGlzLm1hcC5jb25zdW1lcigpXG5cbiAgICBsZXQgZnJvbSA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IoeyBjb2x1bW4sIGxpbmUgfSlcbiAgICBpZiAoIWZyb20uc291cmNlKSByZXR1cm4gZmFsc2VcblxuICAgIGxldCB0b1xuICAgIGlmICh0eXBlb2YgZW5kTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRvID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7IGNvbHVtbjogZW5kQ29sdW1uLCBsaW5lOiBlbmRMaW5lIH0pXG4gICAgfVxuXG4gICAgbGV0IGZyb21VcmxcblxuICAgIGlmIChpc0Fic29sdXRlKGZyb20uc291cmNlKSkge1xuICAgICAgZnJvbVVybCA9IHBhdGhUb0ZpbGVVUkwoZnJvbS5zb3VyY2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21VcmwgPSBuZXcgVVJMKFxuICAgICAgICBmcm9tLnNvdXJjZSxcbiAgICAgICAgdGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHBhdGhUb0ZpbGVVUkwodGhpcy5tYXAubWFwRmlsZSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgY29sdW1uOiBmcm9tLmNvbHVtbixcbiAgICAgIGVuZENvbHVtbjogdG8gJiYgdG8uY29sdW1uLFxuICAgICAgZW5kTGluZTogdG8gJiYgdG8ubGluZSxcbiAgICAgIGxpbmU6IGZyb20ubGluZSxcbiAgICAgIHVybDogZnJvbVVybC50b1N0cmluZygpXG4gICAgfVxuXG4gICAgaWYgKGZyb21VcmwucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgIGlmIChmaWxlVVJMVG9QYXRoKSB7XG4gICAgICAgIHJlc3VsdC5maWxlID0gZmlsZVVSTFRvUGF0aChmcm9tVXJsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGU6IHByb3RvY29sIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc291cmNlID0gY29uc3VtZXIuc291cmNlQ29udGVudEZvcihmcm9tLnNvdXJjZSlcbiAgICBpZiAoc291cmNlKSByZXN1bHQuc291cmNlID0gc291cmNlXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgbGV0IGpzb24gPSB7fVxuICAgIGZvciAobGV0IG5hbWUgb2YgWydoYXNCT00nLCAnY3NzJywgJ2ZpbGUnLCAnaWQnXSkge1xuICAgICAgaWYgKHRoaXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBqc29uW25hbWVdID0gdGhpc1tuYW1lXVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgIGpzb24ubWFwID0geyAuLi50aGlzLm1hcCB9XG4gICAgICBpZiAoanNvbi5tYXAuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICBqc29uLm1hcC5jb25zdW1lckNhY2hlID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uXG4gIH1cblxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlIHx8IHRoaXMuaWRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0XG5JbnB1dC5kZWZhdWx0ID0gSW5wdXRcblxuaWYgKHRlcm1pbmFsSGlnaGxpZ2h0ICYmIHRlcm1pbmFsSGlnaGxpZ2h0LnJlZ2lzdGVySW5wdXQpIHtcbiAgdGVybWluYWxIaWdobGlnaHQucmVnaXN0ZXJJbnB1dChJbnB1dClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXInKVxubGV0IERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpXG5sZXQgTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9tYXAtZ2VuZXJhdG9yJylcbmxldCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxubGV0IFJlc3VsdCA9IHJlcXVpcmUoJy4vcmVzdWx0JylcbmxldCBSb290ID0gcmVxdWlyZSgnLi9yb290JylcbmxldCBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpXG5sZXQgeyBpc0NsZWFuLCBteSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmxldCB3YXJuT25jZSA9IHJlcXVpcmUoJy4vd2Fybi1vbmNlJylcblxuY29uc3QgVFlQRV9UT19DTEFTU19OQU1FID0ge1xuICBhdHJ1bGU6ICdBdFJ1bGUnLFxuICBjb21tZW50OiAnQ29tbWVudCcsXG4gIGRlY2w6ICdEZWNsYXJhdGlvbicsXG4gIGRvY3VtZW50OiAnRG9jdW1lbnQnLFxuICByb290OiAnUm9vdCcsXG4gIHJ1bGU6ICdSdWxlJ1xufVxuXG5jb25zdCBQTFVHSU5fUFJPUFMgPSB7XG4gIEF0UnVsZTogdHJ1ZSxcbiAgQXRSdWxlRXhpdDogdHJ1ZSxcbiAgQ29tbWVudDogdHJ1ZSxcbiAgQ29tbWVudEV4aXQ6IHRydWUsXG4gIERlY2xhcmF0aW9uOiB0cnVlLFxuICBEZWNsYXJhdGlvbkV4aXQ6IHRydWUsXG4gIERvY3VtZW50OiB0cnVlLFxuICBEb2N1bWVudEV4aXQ6IHRydWUsXG4gIE9uY2U6IHRydWUsXG4gIE9uY2VFeGl0OiB0cnVlLFxuICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICBwcmVwYXJlOiB0cnVlLFxuICBSb290OiB0cnVlLFxuICBSb290RXhpdDogdHJ1ZSxcbiAgUnVsZTogdHJ1ZSxcbiAgUnVsZUV4aXQ6IHRydWVcbn1cblxuY29uc3QgTk9UX1ZJU0lUT1JTID0ge1xuICBPbmNlOiB0cnVlLFxuICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICBwcmVwYXJlOiB0cnVlXG59XG5cbmNvbnN0IENISUxEUkVOID0gMFxuXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbidcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRzKG5vZGUpIHtcbiAgbGV0IGtleSA9IGZhbHNlXG4gIGxldCB0eXBlID0gVFlQRV9UT19DTEFTU19OQU1FW25vZGUudHlwZV1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2RlY2wnKSB7XG4gICAga2V5ID0gbm9kZS5wcm9wLnRvTG93ZXJDYXNlKClcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdhdHJ1bGUnKSB7XG4gICAga2V5ID0gbm9kZS5uYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGlmIChrZXkgJiYgbm9kZS5hcHBlbmQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdHlwZSxcbiAgICAgIHR5cGUgKyAnLScgKyBrZXksXG4gICAgICBDSElMRFJFTixcbiAgICAgIHR5cGUgKyAnRXhpdCcsXG4gICAgICB0eXBlICsgJ0V4aXQtJyArIGtleVxuICAgIF1cbiAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICByZXR1cm4gW3R5cGUsIHR5cGUgKyAnLScgKyBrZXksIHR5cGUgKyAnRXhpdCcsIHR5cGUgKyAnRXhpdC0nICsga2V5XVxuICB9IGVsc2UgaWYgKG5vZGUuYXBwZW5kKSB7XG4gICAgcmV0dXJuIFt0eXBlLCBDSElMRFJFTiwgdHlwZSArICdFeGl0J11cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3R5cGUsIHR5cGUgKyAnRXhpdCddXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9TdGFjayhub2RlKSB7XG4gIGxldCBldmVudHNcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgIGV2ZW50cyA9IFsnRG9jdW1lbnQnLCBDSElMRFJFTiwgJ0RvY3VtZW50RXhpdCddXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAncm9vdCcpIHtcbiAgICBldmVudHMgPSBbJ1Jvb3QnLCBDSElMRFJFTiwgJ1Jvb3RFeGl0J11cbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBnZXRFdmVudHMobm9kZSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXZlbnRJbmRleDogMCxcbiAgICBldmVudHMsXG4gICAgaXRlcmF0b3I6IDAsXG4gICAgbm9kZSxcbiAgICB2aXNpdG9ySW5kZXg6IDAsXG4gICAgdmlzaXRvcnM6IFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5NYXJrcyhub2RlKSB7XG4gIG5vZGVbaXNDbGVhbl0gPSBmYWxzZVxuICBpZiAobm9kZS5ub2Rlcykgbm9kZS5ub2Rlcy5mb3JFYWNoKGkgPT4gY2xlYW5NYXJrcyhpKSlcbiAgcmV0dXJuIG5vZGVcbn1cblxubGV0IHBvc3Rjc3MgPSB7fVxuXG5jbGFzcyBMYXp5UmVzdWx0IHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yLCBjc3MsIG9wdHMpIHtcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gZmFsc2VcbiAgICB0aGlzLnByb2Nlc3NlZCA9IGZhbHNlXG5cbiAgICBsZXQgcm9vdFxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBjc3MgPT09ICdvYmplY3QnICYmXG4gICAgICBjc3MgIT09IG51bGwgJiZcbiAgICAgIChjc3MudHlwZSA9PT0gJ3Jvb3QnIHx8IGNzcy50eXBlID09PSAnZG9jdW1lbnQnKVxuICAgICkge1xuICAgICAgcm9vdCA9IGNsZWFuTWFya3MoY3NzKVxuICAgIH0gZWxzZSBpZiAoY3NzIGluc3RhbmNlb2YgTGF6eVJlc3VsdCB8fCBjc3MgaW5zdGFuY2VvZiBSZXN1bHQpIHtcbiAgICAgIHJvb3QgPSBjbGVhbk1hcmtzKGNzcy5yb290KVxuICAgICAgaWYgKGNzcy5tYXApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1hcCA9PT0gJ3VuZGVmaW5lZCcpIG9wdHMubWFwID0ge31cbiAgICAgICAgaWYgKCFvcHRzLm1hcC5pbmxpbmUpIG9wdHMubWFwLmlubGluZSA9IGZhbHNlXG4gICAgICAgIG9wdHMubWFwLnByZXYgPSBjc3MubWFwXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXJzZXIgPSBwYXJzZVxuICAgICAgaWYgKG9wdHMuc3ludGF4KSBwYXJzZXIgPSBvcHRzLnN5bnRheC5wYXJzZVxuICAgICAgaWYgKG9wdHMucGFyc2VyKSBwYXJzZXIgPSBvcHRzLnBhcnNlclxuICAgICAgaWYgKHBhcnNlci5wYXJzZSkgcGFyc2VyID0gcGFyc2VyLnBhcnNlXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJvb3QgPSBwYXJzZXIoY3NzLCBvcHRzKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlXG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAocm9vdCAmJiAhcm9vdFtteV0pIHtcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICAgICAgICBDb250YWluZXIucmVidWlsZChyb290KVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdChwcm9jZXNzb3IsIHJvb3QsIG9wdHMpXG4gICAgdGhpcy5oZWxwZXJzID0geyAuLi5wb3N0Y3NzLCBwb3N0Y3NzLCByZXN1bHQ6IHRoaXMucmVzdWx0IH1cbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnByb2Nlc3Nvci5wbHVnaW5zLm1hcChwbHVnaW4gPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdvYmplY3QnICYmIHBsdWdpbi5wcmVwYXJlKSB7XG4gICAgICAgIHJldHVybiB7IC4uLnBsdWdpbiwgLi4ucGx1Z2luLnByZXBhcmUodGhpcy5yZXN1bHQpIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwbHVnaW5cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKVxuICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnJlc3VsdClcbiAgICBpZiAoIXRoaXMucHJvY2Vzc2luZykge1xuICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdGhpcy5ydW5Bc3luYygpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NpbmdcbiAgfVxuXG4gIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpXG4gIH1cblxuICBmaW5hbGx5KG9uRmluYWxseSkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSlcbiAgfVxuXG4gIGdldEFzeW5jRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgcHJvY2Vzcyhjc3MpLnRoZW4oY2IpIHRvIHdvcmsgd2l0aCBhc3luYyBwbHVnaW5zJylcbiAgfVxuXG4gIGhhbmRsZUVycm9yKGVycm9yLCBub2RlKSB7XG4gICAgbGV0IHBsdWdpbiA9IHRoaXMucmVzdWx0Lmxhc3RQbHVnaW5cbiAgICB0cnkge1xuICAgICAgaWYgKG5vZGUpIG5vZGUuYWRkVG9FcnJvcihlcnJvcilcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvclxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdDc3NTeW50YXhFcnJvcicgJiYgIWVycm9yLnBsdWdpbikge1xuICAgICAgICBlcnJvci5wbHVnaW4gPSBwbHVnaW4ucG9zdGNzc1BsdWdpblxuICAgICAgICBlcnJvci5zZXRNZXNzYWdlKClcbiAgICAgIH0gZWxzZSBpZiAocGx1Z2luLnBvc3Rjc3NWZXJzaW9uKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgbGV0IHBsdWdpbk5hbWUgPSBwbHVnaW4ucG9zdGNzc1BsdWdpblxuICAgICAgICAgIGxldCBwbHVnaW5WZXIgPSBwbHVnaW4ucG9zdGNzc1ZlcnNpb25cbiAgICAgICAgICBsZXQgcnVudGltZVZlciA9IHRoaXMucmVzdWx0LnByb2Nlc3Nvci52ZXJzaW9uXG4gICAgICAgICAgbGV0IGEgPSBwbHVnaW5WZXIuc3BsaXQoJy4nKVxuICAgICAgICAgIGxldCBiID0gcnVudGltZVZlci5zcGxpdCgnLicpXG5cbiAgICAgICAgICBpZiAoYVswXSAhPT0gYlswXSB8fCBwYXJzZUludChhWzFdKSA+IHBhcnNlSW50KGJbMV0pKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ1Vua25vd24gZXJyb3IgZnJvbSBQb3N0Q1NTIHBsdWdpbi4gWW91ciBjdXJyZW50IFBvc3RDU1MgJyArXG4gICAgICAgICAgICAgICAgJ3ZlcnNpb24gaXMgJyArXG4gICAgICAgICAgICAgICAgcnVudGltZVZlciArXG4gICAgICAgICAgICAgICAgJywgYnV0ICcgK1xuICAgICAgICAgICAgICAgIHBsdWdpbk5hbWUgK1xuICAgICAgICAgICAgICAgICcgdXNlcyAnICtcbiAgICAgICAgICAgICAgICBwbHVnaW5WZXIgK1xuICAgICAgICAgICAgICAgICcuIFBlcmhhcHMgdGhpcyBpcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvciBiZWxvdy4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikgY29uc29sZS5lcnJvcihlcnIpXG4gICAgfVxuICAgIHJldHVybiBlcnJvclxuICB9XG5cbiAgcHJlcGFyZVZpc2l0b3JzKCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0ge31cbiAgICBsZXQgYWRkID0gKHBsdWdpbiwgdHlwZSwgY2IpID0+IHtcbiAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW11cbiAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2goW3BsdWdpbiwgY2JdKVxuICAgIH1cbiAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gcGx1Z2luKSB7XG4gICAgICAgICAgaWYgKCFQTFVHSU5fUFJPUFNbZXZlbnRdICYmIC9eW0EtWl0vLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGV2ZW50ICR7ZXZlbnR9IGluICR7cGx1Z2luLnBvc3Rjc3NQbHVnaW59LiBgICtcbiAgICAgICAgICAgICAgICBgVHJ5IHRvIHVwZGF0ZSBQb3N0Q1NTICgke3RoaXMucHJvY2Vzc29yLnZlcnNpb259IG5vdykuYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIU5PVF9WSVNJVE9SU1tldmVudF0pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luW2V2ZW50XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgZmlsdGVyIGluIHBsdWdpbltldmVudF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4sIGV2ZW50LCBwbHVnaW5bZXZlbnRdW2ZpbHRlcl0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFkZChcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICAgICAgICBldmVudCArICctJyArIGZpbHRlci50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5bZXZlbnRdW2ZpbHRlcl1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbltldmVudF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgYWRkKHBsdWdpbiwgZXZlbnQsIHBsdWdpbltldmVudF0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaGFzTGlzdGVuZXIgPSBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVycykubGVuZ3RoID4gMFxuICB9XG5cbiAgYXN5bmMgcnVuQXN5bmMoKSB7XG4gICAgdGhpcy5wbHVnaW4gPSAwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbaV1cbiAgICAgIGxldCBwcm9taXNlID0gdGhpcy5ydW5PblJvb3QocGx1Z2luKVxuICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHByb21pc2VcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKVxuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKSB7XG4gICAgICBsZXQgcm9vdCA9IHRoaXMucmVzdWx0LnJvb3RcbiAgICAgIHdoaWxlICghcm9vdFtpc0NsZWFuXSkge1xuICAgICAgICByb290W2lzQ2xlYW5dID0gdHJ1ZVxuICAgICAgICBsZXQgc3RhY2sgPSBbdG9TdGFjayhyb290KV1cbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgcHJvbWlzZSA9IHRoaXMudmlzaXRUaWNrKHN0YWNrKVxuICAgICAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHByb21pc2VcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgbGV0IG5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5ub2RlXG4gICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZSwgbm9kZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgIGZvciAobGV0IFtwbHVnaW4sIHZpc2l0b3JdIG9mIHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocm9vdC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICAgIGxldCByb290cyA9IHJvb3Qubm9kZXMubWFwKHN1YlJvb3QgPT5cbiAgICAgICAgICAgICAgICB2aXNpdG9yKHN1YlJvb3QsIHRoaXMuaGVscGVycylcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJvb3RzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXdhaXQgdmlzaXRvcihyb290LCB0aGlzLmhlbHBlcnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpXG4gIH1cblxuICBydW5PblJvb3QocGx1Z2luKSB7XG4gICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ29iamVjdCcgJiYgcGx1Z2luLk9uY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnJvb3QudHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgIGxldCByb290cyA9IHRoaXMucmVzdWx0LnJvb3Qubm9kZXMubWFwKHJvb3QgPT5cbiAgICAgICAgICAgIHBsdWdpbi5PbmNlKHJvb3QsIHRoaXMuaGVscGVycylcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoaXNQcm9taXNlKHJvb3RzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJvb3RzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByb290c1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsdWdpbi5PbmNlKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMuaGVscGVycylcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcGx1Z2luKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0KVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIHN0cmluZ2lmeSgpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvclxuICAgIGlmICh0aGlzLnN0cmluZ2lmaWVkKSByZXR1cm4gdGhpcy5yZXN1bHRcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gdHJ1ZVxuXG4gICAgdGhpcy5zeW5jKClcblxuICAgIGxldCBvcHRzID0gdGhpcy5yZXN1bHQub3B0c1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnlcbiAgICBpZiAob3B0cy5zeW50YXgpIHN0ciA9IG9wdHMuc3ludGF4LnN0cmluZ2lmeVxuICAgIGlmIChvcHRzLnN0cmluZ2lmaWVyKSBzdHIgPSBvcHRzLnN0cmluZ2lmaWVyXG4gICAgaWYgKHN0ci5zdHJpbmdpZnkpIHN0ciA9IHN0ci5zdHJpbmdpZnlcblxuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yKHN0ciwgdGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQub3B0cylcbiAgICBsZXQgZGF0YSA9IG1hcC5nZW5lcmF0ZSgpXG4gICAgdGhpcy5yZXN1bHQuY3NzID0gZGF0YVswXVxuICAgIHRoaXMucmVzdWx0Lm1hcCA9IGRhdGFbMV1cblxuICAgIHJldHVybiB0aGlzLnJlc3VsdFxuICB9XG5cbiAgc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvclxuICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIHRoaXMucmVzdWx0XG4gICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlXG5cbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKVxuICAgIH1cblxuICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGxldCBwcm9taXNlID0gdGhpcy5ydW5PblJvb3QocGx1Z2luKVxuICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHJlcGFyZVZpc2l0b3JzKClcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcikge1xuICAgICAgbGV0IHJvb3QgPSB0aGlzLnJlc3VsdC5yb290XG4gICAgICB3aGlsZSAoIXJvb3RbaXNDbGVhbl0pIHtcbiAgICAgICAgcm9vdFtpc0NsZWFuXSA9IHRydWVcbiAgICAgICAgdGhpcy53YWxrU3luYyhyb290KVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgIGlmIChyb290LnR5cGUgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICBmb3IgKGxldCBzdWJSb290IG9mIHJvb3Qubm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCBzdWJSb290KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpc2l0U3luYyh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCwgcm9vdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlc3VsdFxuICB9XG5cbiAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoISgnZnJvbScgaW4gdGhpcy5vcHRzKSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAnV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCAnICtcbiAgICAgICAgICAgICdhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCAnICtcbiAgICAgICAgICAgICdvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy4nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzXG4gIH1cblxuICB2aXNpdFN5bmModmlzaXRvcnMsIG5vZGUpIHtcbiAgICBmb3IgKGxldCBbcGx1Z2luLCB2aXNpdG9yXSBvZiB2aXNpdG9ycykge1xuICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpblxuICAgICAgbGV0IHByb21pc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb21pc2UgPSB2aXNpdG9yKG5vZGUsIHRoaXMuaGVscGVycylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlLCBub2RlLnByb3h5T2YpXG4gICAgICB9XG4gICAgICBpZiAobm9kZS50eXBlICE9PSAncm9vdCcgJiYgbm9kZS50eXBlICE9PSAnZG9jdW1lbnQnICYmICFub2RlLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZpc2l0VGljayhzdGFjaykge1xuICAgIGxldCB2aXNpdCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gICAgbGV0IHsgbm9kZSwgdmlzaXRvcnMgfSA9IHZpc2l0XG5cbiAgICBpZiAobm9kZS50eXBlICE9PSAncm9vdCcgJiYgbm9kZS50eXBlICE9PSAnZG9jdW1lbnQnICYmICFub2RlLnBhcmVudCkge1xuICAgICAgc3RhY2sucG9wKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh2aXNpdG9ycy5sZW5ndGggPiAwICYmIHZpc2l0LnZpc2l0b3JJbmRleCA8IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgbGV0IFtwbHVnaW4sIHZpc2l0b3JdID0gdmlzaXRvcnNbdmlzaXQudmlzaXRvckluZGV4XVxuICAgICAgdmlzaXQudmlzaXRvckluZGV4ICs9IDFcbiAgICAgIGlmICh2aXNpdC52aXNpdG9ySW5kZXggPT09IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgICB2aXNpdC52aXNpdG9ycyA9IFtdXG4gICAgICAgIHZpc2l0LnZpc2l0b3JJbmRleCA9IDBcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yKG5vZGUudG9Qcm94eSgpLCB0aGlzLmhlbHBlcnMpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZSwgbm9kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlzaXQuaXRlcmF0b3IgIT09IDApIHtcbiAgICAgIGxldCBpdGVyYXRvciA9IHZpc2l0Lml0ZXJhdG9yXG4gICAgICBsZXQgY2hpbGRcbiAgICAgIHdoaWxlICgoY2hpbGQgPSBub2RlLm5vZGVzW25vZGUuaW5kZXhlc1tpdGVyYXRvcl1dKSkge1xuICAgICAgICBub2RlLmluZGV4ZXNbaXRlcmF0b3JdICs9IDFcbiAgICAgICAgaWYgKCFjaGlsZFtpc0NsZWFuXSkge1xuICAgICAgICAgIGNoaWxkW2lzQ2xlYW5dID0gdHJ1ZVxuICAgICAgICAgIHN0YWNrLnB1c2godG9TdGFjayhjaGlsZCkpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZpc2l0Lml0ZXJhdG9yID0gMFxuICAgICAgZGVsZXRlIG5vZGUuaW5kZXhlc1tpdGVyYXRvcl1cbiAgICB9XG5cbiAgICBsZXQgZXZlbnRzID0gdmlzaXQuZXZlbnRzXG4gICAgd2hpbGUgKHZpc2l0LmV2ZW50SW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICBsZXQgZXZlbnQgPSBldmVudHNbdmlzaXQuZXZlbnRJbmRleF1cbiAgICAgIHZpc2l0LmV2ZW50SW5kZXggKz0gMVxuICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTikge1xuICAgICAgICBpZiAobm9kZS5ub2RlcyAmJiBub2RlLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGVbaXNDbGVhbl0gPSB0cnVlXG4gICAgICAgICAgdmlzaXQuaXRlcmF0b3IgPSBub2RlLmdldEl0ZXJhdG9yKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHZpc2l0LnZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG5cbiAgd2Fsa1N5bmMobm9kZSkge1xuICAgIG5vZGVbaXNDbGVhbl0gPSB0cnVlXG4gICAgbGV0IGV2ZW50cyA9IGdldEV2ZW50cyhub2RlKVxuICAgIGZvciAobGV0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTikge1xuICAgICAgICBpZiAobm9kZS5ub2Rlcykge1xuICAgICAgICAgIG5vZGUuZWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSB0aGlzLndhbGtTeW5jKGNoaWxkKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB2aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XVxuICAgICAgICBpZiAodmlzaXRvcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy52aXNpdFN5bmModmlzaXRvcnMsIG5vZGUudG9Qcm94eSgpKSkgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkud2FybmluZ3MoKVxuICB9XG5cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY29udGVudFxuICB9XG5cbiAgZ2V0IGNzcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jc3NcbiAgfVxuXG4gIGdldCBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkubWFwXG4gIH1cblxuICBnZXQgbWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYygpLm1lc3NhZ2VzXG4gIH1cblxuICBnZXQgb3B0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0c1xuICB9XG5cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yXG4gIH1cblxuICBnZXQgcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkucm9vdFxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnTGF6eVJlc3VsdCdcbiAgfVxufVxuXG5MYXp5UmVzdWx0LnJlZ2lzdGVyUG9zdGNzcyA9IGRlcGVuZGFudCA9PiB7XG4gIHBvc3Rjc3MgPSBkZXBlbmRhbnRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMYXp5UmVzdWx0XG5MYXp5UmVzdWx0LmRlZmF1bHQgPSBMYXp5UmVzdWx0XG5cblJvb3QucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQpXG5Eb2N1bWVudC5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdClcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgbGlzdCA9IHtcbiAgY29tbWEoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGxpc3Quc3BsaXQoc3RyaW5nLCBbJywnXSwgdHJ1ZSlcbiAgfSxcblxuICBzcGFjZShzdHJpbmcpIHtcbiAgICBsZXQgc3BhY2VzID0gWycgJywgJ1xcbicsICdcXHQnXVxuICAgIHJldHVybiBsaXN0LnNwbGl0KHN0cmluZywgc3BhY2VzKVxuICB9LFxuXG4gIHNwbGl0KHN0cmluZywgc2VwYXJhdG9ycywgbGFzdCkge1xuICAgIGxldCBhcnJheSA9IFtdXG4gICAgbGV0IGN1cnJlbnQgPSAnJ1xuICAgIGxldCBzcGxpdCA9IGZhbHNlXG5cbiAgICBsZXQgZnVuYyA9IDBcbiAgICBsZXQgaW5RdW90ZSA9IGZhbHNlXG4gICAgbGV0IHByZXZRdW90ZSA9ICcnXG4gICAgbGV0IGVzY2FwZSA9IGZhbHNlXG5cbiAgICBmb3IgKGxldCBsZXR0ZXIgb2Ygc3RyaW5nKSB7XG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIGVzY2FwZSA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGVzY2FwZSA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZSkge1xuICAgICAgICBpZiAobGV0dGVyID09PSBwcmV2UXVvdGUpIHtcbiAgICAgICAgICBpblF1b3RlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICdcIicgfHwgbGV0dGVyID09PSBcIidcIikge1xuICAgICAgICBpblF1b3RlID0gdHJ1ZVxuICAgICAgICBwcmV2UXVvdGUgPSBsZXR0ZXJcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnKCcpIHtcbiAgICAgICAgZnVuYyArPSAxXG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gJyknKSB7XG4gICAgICAgIGlmIChmdW5jID4gMCkgZnVuYyAtPSAxXG4gICAgICB9IGVsc2UgaWYgKGZ1bmMgPT09IDApIHtcbiAgICAgICAgaWYgKHNlcGFyYXRvcnMuaW5jbHVkZXMobGV0dGVyKSkgc3BsaXQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gJycpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpXG4gICAgICAgIGN1cnJlbnQgPSAnJ1xuICAgICAgICBzcGxpdCA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ICs9IGxldHRlclxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYXN0IHx8IGN1cnJlbnQgIT09ICcnKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKVxuICAgIHJldHVybiBhcnJheVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdFxubGlzdC5kZWZhdWx0ID0gbGlzdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCB7IGRpcm5hbWUsIHJlbGF0aXZlLCByZXNvbHZlLCBzZXAgfSA9IHJlcXVpcmUoJ3BhdGgnKVxubGV0IHsgU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciB9ID0gcmVxdWlyZSgnc291cmNlLW1hcC1qcycpXG5sZXQgeyBwYXRoVG9GaWxlVVJMIH0gPSByZXF1aXJlKCd1cmwnKVxuXG5sZXQgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0JylcblxubGV0IHNvdXJjZU1hcEF2YWlsYWJsZSA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIgJiYgU291cmNlTWFwR2VuZXJhdG9yKVxubGV0IHBhdGhBdmFpbGFibGUgPSBCb29sZWFuKGRpcm5hbWUgJiYgcmVzb2x2ZSAmJiByZWxhdGl2ZSAmJiBzZXApXG5cbmNsYXNzIE1hcEdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ2lmeSwgcm9vdCwgb3B0cywgY3NzU3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcbiAgICB0aGlzLm1hcE9wdHMgPSBvcHRzLm1hcCB8fCB7fVxuICAgIHRoaXMucm9vdCA9IHJvb3RcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5jc3MgPSBjc3NTdHJpbmdcbiAgICB0aGlzLm9yaWdpbmFsQ1NTID0gY3NzU3RyaW5nXG4gICAgdGhpcy51c2VzRmlsZVVybHMgPSAhdGhpcy5tYXBPcHRzLmZyb20gJiYgdGhpcy5tYXBPcHRzLmFic29sdXRlXG5cbiAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMgPSBuZXcgTWFwKClcbiAgICB0aGlzLm1lbW9pemVkUGF0aHMgPSBuZXcgTWFwKClcbiAgICB0aGlzLm1lbW9pemVkVVJMcyA9IG5ldyBNYXAoKVxuICB9XG5cbiAgYWRkQW5ub3RhdGlvbigpIHtcbiAgICBsZXQgY29udGVudFxuXG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgY29udGVudCA9XG4gICAgICAgICdkYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyB0aGlzLnRvQmFzZTY0KHRoaXMubWFwLnRvU3RyaW5nKCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb25cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKHRoaXMub3B0cy50bywgdGhpcy5yb290KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5vdXRwdXRGaWxlKCkgKyAnLm1hcCdcbiAgICB9XG4gICAgbGV0IGVvbCA9ICdcXG4nXG4gICAgaWYgKHRoaXMuY3NzLmluY2x1ZGVzKCdcXHJcXG4nKSkgZW9sID0gJ1xcclxcbidcblxuICAgIHRoaXMuY3NzICs9IGVvbCArICcvKiMgc291cmNlTWFwcGluZ1VSTD0nICsgY29udGVudCArICcgKi8nXG4gIH1cblxuICBhcHBseVByZXZNYXBzKCkge1xuICAgIGZvciAobGV0IHByZXYgb2YgdGhpcy5wcmV2aW91cygpKSB7XG4gICAgICBsZXQgZnJvbSA9IHRoaXMudG9VcmwodGhpcy5wYXRoKHByZXYuZmlsZSkpXG4gICAgICBsZXQgcm9vdCA9IHByZXYucm9vdCB8fCBkaXJuYW1lKHByZXYuZmlsZSlcbiAgICAgIGxldCBtYXBcblxuICAgICAgaWYgKHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgbWFwID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyKHByZXYudGV4dClcbiAgICAgICAgaWYgKG1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwID0gcHJldi5jb25zdW1lcigpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFwLmFwcGx5U291cmNlTWFwKG1hcCwgZnJvbSwgdGhpcy50b1VybCh0aGlzLnBhdGgocm9vdCkpKVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IGZhbHNlKSByZXR1cm5cblxuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIGxldCBub2RlXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5yb290Lm5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLnJvb3Qubm9kZXNbaV1cbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ2NvbW1lbnQnKSBjb250aW51ZVxuICAgICAgICBpZiAobm9kZS50ZXh0LnN0YXJ0c1dpdGgoJyMgc291cmNlTWFwcGluZ1VSTD0nKSkge1xuICAgICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZChpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgdGhpcy5jc3MgPSB0aGlzLmNzcy5yZXBsYWNlKC9cXG4qXFwvXFwqI1tcXFNcXHNdKj9cXCpcXC8kL2dtLCAnJylcbiAgICB9XG4gIH1cblxuICBnZW5lcmF0ZSgpIHtcbiAgICB0aGlzLmNsZWFyQW5ub3RhdGlvbigpXG4gICAgaWYgKHBhdGhBdmFpbGFibGUgJiYgc291cmNlTWFwQXZhaWxhYmxlICYmIHRoaXMuaXNNYXAoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVNYXAoKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0ID0gJydcbiAgICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgaSA9PiB7XG4gICAgICAgIHJlc3VsdCArPSBpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIFtyZXN1bHRdXG4gICAgfVxuICB9XG5cbiAgZ2VuZXJhdGVNYXAoKSB7XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZVN0cmluZygpXG4gICAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICBsZXQgcHJldiA9IHRoaXMucHJldmlvdXMoKVswXS5jb25zdW1lcigpXG4gICAgICBwcmV2LmZpbGUgPSB0aGlzLm91dHB1dEZpbGUoKVxuICAgICAgdGhpcy5tYXAgPSBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcChwcmV2LCB7XG4gICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgIH0pXG4gICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7IGNvbHVtbjogMCwgbGluZTogMSB9LFxuICAgICAgICBvcmlnaW5hbDogeyBjb2x1bW46IDAsIGxpbmU6IDEgfSxcbiAgICAgICAgc291cmNlOiB0aGlzLm9wdHMuZnJvbVxuICAgICAgICAgID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKVxuICAgICAgICAgIDogJzxubyBzb3VyY2U+J1xuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1NvdXJjZXNDb250ZW50KCkpIHRoaXMuc2V0U291cmNlc0NvbnRlbnQoKVxuICAgIGlmICh0aGlzLnJvb3QgJiYgdGhpcy5wcmV2aW91cygpLmxlbmd0aCA+IDApIHRoaXMuYXBwbHlQcmV2TWFwcygpXG4gICAgaWYgKHRoaXMuaXNBbm5vdGF0aW9uKCkpIHRoaXMuYWRkQW5ub3RhdGlvbigpXG5cbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY3NzXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3RoaXMuY3NzLCB0aGlzLm1hcF1cbiAgICB9XG4gIH1cblxuICBnZW5lcmF0ZVN0cmluZygpIHtcbiAgICB0aGlzLmNzcyA9ICcnXG4gICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICB9KVxuXG4gICAgbGV0IGxpbmUgPSAxXG4gICAgbGV0IGNvbHVtbiA9IDFcblxuICAgIGxldCBub1NvdXJjZSA9ICc8bm8gc291cmNlPidcbiAgICBsZXQgbWFwcGluZyA9IHtcbiAgICAgIGdlbmVyYXRlZDogeyBjb2x1bW46IDAsIGxpbmU6IDAgfSxcbiAgICAgIG9yaWdpbmFsOiB7IGNvbHVtbjogMCwgbGluZTogMCB9LFxuICAgICAgc291cmNlOiAnJ1xuICAgIH1cblxuICAgIGxldCBsYXN0LCBsaW5lc1xuICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgKHN0ciwgbm9kZSwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5jc3MgKz0gc3RyXG5cbiAgICAgIGlmIChub2RlICYmIHR5cGUgIT09ICdlbmQnKSB7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDFcbiAgICAgICAgaWYgKG5vZGUuc291cmNlICYmIG5vZGUuc291cmNlLnN0YXJ0KSB7XG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB0aGlzLnNvdXJjZVBhdGgobm9kZSlcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlLnNvdXJjZS5zdGFydC5saW5lXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlLnNvdXJjZS5zdGFydC5jb2x1bW4gLSAxXG4gICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2VcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwXG4gICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vZylcbiAgICAgIGlmIChsaW5lcykge1xuICAgICAgICBsaW5lICs9IGxpbmVzLmxlbmd0aFxuICAgICAgICBsYXN0ID0gc3RyLmxhc3RJbmRleE9mKCdcXG4nKVxuICAgICAgICBjb2x1bW4gPSBzdHIubGVuZ3RoIC0gbGFzdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uICs9IHN0ci5sZW5ndGhcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgJiYgdHlwZSAhPT0gJ3N0YXJ0Jykge1xuICAgICAgICBsZXQgcCA9IG5vZGUucGFyZW50IHx8IHsgcmF3czoge30gfVxuICAgICAgICBsZXQgY2hpbGRsZXNzID1cbiAgICAgICAgICBub2RlLnR5cGUgPT09ICdkZWNsJyB8fCAobm9kZS50eXBlID09PSAnYXRydWxlJyAmJiAhbm9kZS5ub2RlcylcbiAgICAgICAgaWYgKCFjaGlsZGxlc3MgfHwgbm9kZSAhPT0gcC5sYXN0IHx8IHAucmF3cy5zZW1pY29sb24pIHtcbiAgICAgICAgICBpZiAobm9kZS5zb3VyY2UgJiYgbm9kZS5zb3VyY2UuZW5kKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuc291cmNlUGF0aChub2RlKVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZS5zb3VyY2UuZW5kLmxpbmVcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZS5zb3VyY2UuZW5kLmNvbHVtbiAtIDFcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lXG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAyXG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2VcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDFcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMFxuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmVcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDFcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaXNBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmFubm90YXRpb25cbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShpID0+IGkuYW5ub3RhdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlzSW5saW5lKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmlubGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuaW5saW5lXG4gICAgfVxuXG4gICAgbGV0IGFubm90YXRpb24gPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvblxuICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgYW5ub3RhdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShpID0+IGkuaW5saW5lKVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaXNNYXAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubWFwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuICEhdGhpcy5vcHRzLm1hcFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIGlzU291cmNlc0NvbnRlbnQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50XG4gICAgfVxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoaSA9PiBpLndpdGhDb250ZW50KCkpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBvdXRwdXRGaWxlKCkge1xuICAgIGlmICh0aGlzLm9wdHMudG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLnRvKVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmZyb20pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAndG8uY3NzJ1xuICAgIH1cbiAgfVxuXG4gIHBhdGgoZmlsZSkge1xuICAgIGlmICh0aGlzLm1hcE9wdHMuYWJzb2x1dGUpIHJldHVybiBmaWxlXG4gICAgaWYgKGZpbGUuY2hhckNvZGVBdCgwKSA9PT0gNjAgLyogYDxgICovKSByZXR1cm4gZmlsZVxuICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSByZXR1cm4gZmlsZVxuICAgIGxldCBjYWNoZWQgPSB0aGlzLm1lbW9pemVkUGF0aHMuZ2V0KGZpbGUpXG4gICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZFxuXG4gICAgbGV0IGZyb20gPSB0aGlzLm9wdHMudG8gPyBkaXJuYW1lKHRoaXMub3B0cy50bykgOiAnLidcblxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBmcm9tID0gZGlybmFtZShyZXNvbHZlKGZyb20sIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKSlcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IHJlbGF0aXZlKGZyb20sIGZpbGUpXG4gICAgdGhpcy5tZW1vaXplZFBhdGhzLnNldChmaWxlLCBwYXRoKVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIHByZXZpb3VzKCkge1xuICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMpIHtcbiAgICAgIHRoaXMucHJldmlvdXNNYXBzID0gW11cbiAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290LndhbGsobm9kZSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUuc291cmNlICYmIG5vZGUuc291cmNlLmlucHV0Lm1hcCkge1xuICAgICAgICAgICAgbGV0IG1hcCA9IG5vZGUuc291cmNlLmlucHV0Lm1hcFxuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcy5pbmNsdWRlcyhtYXApKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJldmlvdXNNYXBzLnB1c2gobWFwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBpbnB1dCA9IG5ldyBJbnB1dCh0aGlzLm9yaWdpbmFsQ1NTLCB0aGlzLm9wdHMpXG4gICAgICAgIGlmIChpbnB1dC5tYXApIHRoaXMucHJldmlvdXNNYXBzLnB1c2goaW5wdXQubWFwKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByZXZpb3VzTWFwc1xuICB9XG5cbiAgc2V0U291cmNlc0NvbnRlbnQoKSB7XG4gICAgbGV0IGFscmVhZHkgPSB7fVxuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIHRoaXMucm9vdC53YWxrKG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5zb3VyY2UpIHtcbiAgICAgICAgICBsZXQgZnJvbSA9IG5vZGUuc291cmNlLmlucHV0LmZyb21cbiAgICAgICAgICBpZiAoZnJvbSAmJiAhYWxyZWFkeVtmcm9tXSkge1xuICAgICAgICAgICAgYWxyZWFkeVtmcm9tXSA9IHRydWVcbiAgICAgICAgICAgIGxldCBmcm9tVXJsID0gdGhpcy51c2VzRmlsZVVybHNcbiAgICAgICAgICAgICAgPyB0aGlzLnRvRmlsZVVybChmcm9tKVxuICAgICAgICAgICAgICA6IHRoaXMudG9VcmwodGhpcy5wYXRoKGZyb20pKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tVXJsLCBub2RlLnNvdXJjZS5pbnB1dC5jc3MpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgIGxldCBmcm9tID0gdGhpcy5vcHRzLmZyb21cbiAgICAgICAgPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpXG4gICAgICAgIDogJzxubyBzb3VyY2U+J1xuICAgICAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tLCB0aGlzLmNzcylcbiAgICB9XG4gIH1cblxuICBzb3VyY2VQYXRoKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXBPcHRzLmZyb20pIHtcbiAgICAgIHJldHVybiB0aGlzLnRvVXJsKHRoaXMubWFwT3B0cy5mcm9tKVxuICAgIH0gZWxzZSBpZiAodGhpcy51c2VzRmlsZVVybHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvRmlsZVVybChub2RlLnNvdXJjZS5pbnB1dC5mcm9tKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLnBhdGgobm9kZS5zb3VyY2UuaW5wdXQuZnJvbSkpXG4gICAgfVxuICB9XG5cbiAgdG9CYXNlNjQoc3RyKSB7XG4gICAgaWYgKEJ1ZmZlcikge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3cuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpXG4gICAgfVxuICB9XG5cbiAgdG9GaWxlVXJsKHBhdGgpIHtcbiAgICBsZXQgY2FjaGVkID0gdGhpcy5tZW1vaXplZEZpbGVVUkxzLmdldChwYXRoKVxuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWRcblxuICAgIGlmIChwYXRoVG9GaWxlVVJMKSB7XG4gICAgICBsZXQgZmlsZVVSTCA9IHBhdGhUb0ZpbGVVUkwocGF0aCkudG9TdHJpbmcoKVxuICAgICAgdGhpcy5tZW1vaXplZEZpbGVVUkxzLnNldChwYXRoLCBmaWxlVVJMKVxuXG4gICAgICByZXR1cm4gZmlsZVVSTFxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgbWFwLmFic29sdXRlYCBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGQnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgdG9VcmwocGF0aCkge1xuICAgIGxldCBjYWNoZWQgPSB0aGlzLm1lbW9pemVkVVJMcy5nZXQocGF0aClcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkXG5cbiAgICBpZiAoc2VwID09PSAnXFxcXCcpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuICAgIH1cblxuICAgIGxldCB1cmwgPSBlbmNvZGVVUkkocGF0aCkucmVwbGFjZSgvWyM/XS9nLCBlbmNvZGVVUklDb21wb25lbnQpXG4gICAgdGhpcy5tZW1vaXplZFVSTHMuc2V0KHBhdGgsIHVybClcblxuICAgIHJldHVybiB1cmxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcEdlbmVyYXRvclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL21hcC1nZW5lcmF0b3InKVxubGV0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBSZXN1bHQgPSByZXF1aXJlKCcuL3Jlc3VsdCcpXG5sZXQgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKVxubGV0IHdhcm5PbmNlID0gcmVxdWlyZSgnLi93YXJuLW9uY2UnKVxuXG5jbGFzcyBOb1dvcmtSZXN1bHQge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IsIGNzcywgb3B0cykge1xuICAgIGNzcyA9IGNzcy50b1N0cmluZygpXG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9wcm9jZXNzb3IgPSBwcm9jZXNzb3JcbiAgICB0aGlzLl9jc3MgPSBjc3NcbiAgICB0aGlzLl9vcHRzID0gb3B0c1xuICAgIHRoaXMuX21hcCA9IHVuZGVmaW5lZFxuICAgIGxldCByb290XG5cbiAgICBsZXQgc3RyID0gc3RyaW5naWZ5XG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0KHRoaXMuX3Byb2Nlc3Nvciwgcm9vdCwgdGhpcy5fb3B0cylcbiAgICB0aGlzLnJlc3VsdC5jc3MgPSBjc3NcblxuICAgIGxldCBzZWxmID0gdGhpc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnJlc3VsdCwgJ3Jvb3QnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJvb3RcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgbGV0IG1hcCA9IG5ldyBNYXBHZW5lcmF0b3Ioc3RyLCByb290LCB0aGlzLl9vcHRzLCBjc3MpXG4gICAgaWYgKG1hcC5pc01hcCgpKSB7XG4gICAgICBsZXQgW2dlbmVyYXRlZENTUywgZ2VuZXJhdGVkTWFwXSA9IG1hcC5nZW5lcmF0ZSgpXG4gICAgICBpZiAoZ2VuZXJhdGVkQ1NTKSB7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGdlbmVyYXRlZENTU1xuICAgICAgfVxuICAgICAgaWYgKGdlbmVyYXRlZE1hcCkge1xuICAgICAgICB0aGlzLnJlc3VsdC5tYXAgPSBnZW5lcmF0ZWRNYXBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFwLmNsZWFyQW5ub3RhdGlvbigpXG4gICAgICB0aGlzLnJlc3VsdC5jc3MgPSBtYXAuY3NzXG4gICAgfVxuICB9XG5cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpXG4gIH1cblxuICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKVxuICB9XG5cbiAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpXG4gIH1cblxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yXG4gICAgcmV0dXJuIHRoaXMucmVzdWx0XG4gIH1cblxuICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghKCdmcm9tJyBpbiB0aGlzLl9vcHRzKSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAnV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCAnICtcbiAgICAgICAgICAgICdhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCAnICtcbiAgICAgICAgICAgICdvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy4nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3NzXG4gIH1cblxuICB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3NcbiAgfVxuXG4gIGdldCBjc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzc1xuICB9XG5cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQubWFwXG4gIH1cblxuICBnZXQgbWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBnZXQgb3B0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0c1xuICB9XG5cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yXG4gIH1cblxuICBnZXQgcm9vdCgpIHtcbiAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RcbiAgICB9XG5cbiAgICBsZXQgcm9vdFxuICAgIGxldCBwYXJzZXIgPSBwYXJzZVxuXG4gICAgdHJ5IHtcbiAgICAgIHJvb3QgPSBwYXJzZXIodGhpcy5fY3NzLCB0aGlzLl9vcHRzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9yID0gZXJyb3JcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvclxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yb290ID0gcm9vdFxuICAgICAgcmV0dXJuIHJvb3RcbiAgICB9XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdOb1dvcmtSZXN1bHQnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb1dvcmtSZXN1bHRcbk5vV29ya1Jlc3VsdC5kZWZhdWx0ID0gTm9Xb3JrUmVzdWx0XG4iLCIndXNlIHN0cmljdCdcblxubGV0IENzc1N5bnRheEVycm9yID0gcmVxdWlyZSgnLi9jc3Mtc3ludGF4LWVycm9yJylcbmxldCBTdHJpbmdpZmllciA9IHJlcXVpcmUoJy4vc3RyaW5naWZpZXInKVxubGV0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5JylcbmxldCB7IGlzQ2xlYW4sIG15IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuXG5mdW5jdGlvbiBjbG9uZU5vZGUob2JqLCBwYXJlbnQpIHtcbiAgbGV0IGNsb25lZCA9IG5ldyBvYmouY29uc3RydWN0b3IoKVxuXG4gIGZvciAobGV0IGkgaW4gb2JqKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkge1xuICAgICAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGkgPT09ICdwcm94eUNhY2hlJykgY29udGludWVcbiAgICBsZXQgdmFsdWUgPSBvYmpbaV1cbiAgICBsZXQgdHlwZSA9IHR5cGVvZiB2YWx1ZVxuXG4gICAgaWYgKGkgPT09ICdwYXJlbnQnICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocGFyZW50KSBjbG9uZWRbaV0gPSBwYXJlbnRcbiAgICB9IGVsc2UgaWYgKGkgPT09ICdzb3VyY2UnKSB7XG4gICAgICBjbG9uZWRbaV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNsb25lZFtpXSA9IHZhbHVlLm1hcChqID0+IGNsb25lTm9kZShqLCBjbG9uZWQpKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHZhbHVlID0gY2xvbmVOb2RlKHZhbHVlKVxuICAgICAgY2xvbmVkW2ldID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvbmVkXG59XG5cbmNsYXNzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cyA9IHt9KSB7XG4gICAgdGhpcy5yYXdzID0ge31cbiAgICB0aGlzW2lzQ2xlYW5dID0gZmFsc2VcbiAgICB0aGlzW215XSA9IHRydWVcblxuICAgIGZvciAobGV0IG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgIGlmIChuYW1lID09PSAnbm9kZXMnKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXVxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIGRlZmF1bHRzW25hbWVdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmNsb25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlLmNsb25lKCkpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW25hbWVdID0gZGVmYXVsdHNbbmFtZV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhZGRUb0Vycm9yKGVycm9yKSB7XG4gICAgZXJyb3IucG9zdGNzc05vZGUgPSB0aGlzXG4gICAgaWYgKGVycm9yLnN0YWNrICYmIHRoaXMuc291cmNlICYmIC9cXG5cXHN7NH1hdCAvLnRlc3QoZXJyb3Iuc3RhY2spKSB7XG4gICAgICBsZXQgcyA9IHRoaXMuc291cmNlXG4gICAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoXG4gICAgICAgIC9cXG5cXHN7NH1hdCAvLFxuICAgICAgICBgJCYke3MuaW5wdXQuZnJvbX06JHtzLnN0YXJ0LmxpbmV9OiR7cy5zdGFydC5jb2x1bW59JCZgXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBlcnJvclxuICB9XG5cbiAgYWZ0ZXIoYWRkKSB7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgYWRkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhc3NpZ24ob3ZlcnJpZGVzID0ge30pIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIG92ZXJyaWRlcykge1xuICAgICAgdGhpc1tuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYmVmb3JlKGFkZCkge1xuICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBhZGQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgIGRlbGV0ZSB0aGlzLnJhd3MuYmVmb3JlXG4gICAgZGVsZXRlIHRoaXMucmF3cy5hZnRlclxuICAgIGlmICgha2VlcEJldHdlZW4pIGRlbGV0ZSB0aGlzLnJhd3MuYmV0d2VlblxuICB9XG5cbiAgY2xvbmUob3ZlcnJpZGVzID0ge30pIHtcbiAgICBsZXQgY2xvbmVkID0gY2xvbmVOb2RlKHRoaXMpXG4gICAgZm9yIChsZXQgbmFtZSBpbiBvdmVycmlkZXMpIHtcbiAgICAgIGNsb25lZFtuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICBjbG9uZUFmdGVyKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgbGV0IGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKVxuICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGNsb25lZClcbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICBjbG9uZUJlZm9yZShvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcylcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgY2xvbmVkKVxuICAgIHJldHVybiBjbG9uZWRcbiAgfVxuXG4gIGVycm9yKG1lc3NhZ2UsIG9wdHMgPSB7fSkge1xuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgbGV0IHsgZW5kLCBzdGFydCB9ID0gdGhpcy5yYW5nZUJ5KG9wdHMpXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UuaW5wdXQuZXJyb3IoXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHsgY29sdW1uOiBzdGFydC5jb2x1bW4sIGxpbmU6IHN0YXJ0LmxpbmUgfSxcbiAgICAgICAgeyBjb2x1bW46IGVuZC5jb2x1bW4sIGxpbmU6IGVuZC5saW5lIH0sXG4gICAgICAgIG9wdHNcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDc3NTeW50YXhFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldChub2RlLCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAncHJveHlPZicpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdyb290Jykge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBub2RlLnJvb3QoKS50b1Byb3h5KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVtwcm9wXVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZXQobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGVbcHJvcF0gPT09IHZhbHVlKSByZXR1cm4gdHJ1ZVxuICAgICAgICBub2RlW3Byb3BdID0gdmFsdWVcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AgPT09ICdwcm9wJyB8fFxuICAgICAgICAgIHByb3AgPT09ICd2YWx1ZScgfHxcbiAgICAgICAgICBwcm9wID09PSAnbmFtZScgfHxcbiAgICAgICAgICBwcm9wID09PSAncGFyYW1zJyB8fFxuICAgICAgICAgIHByb3AgPT09ICdpbXBvcnRhbnQnIHx8XG4gICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBwcm9wID09PSAndGV4dCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgbm9kZS5tYXJrRGlydHkoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBtYXJrQ2xlYW4oKSB7XG4gICAgdGhpc1tpc0NsZWFuXSA9IHRydWVcbiAgfVxuXG4gIG1hcmtEaXJ0eSgpIHtcbiAgICBpZiAodGhpc1tpc0NsZWFuXSkge1xuICAgICAgdGhpc1tpc0NsZWFuXSA9IGZhbHNlXG4gICAgICBsZXQgbmV4dCA9IHRoaXNcbiAgICAgIHdoaWxlICgobmV4dCA9IG5leHQucGFyZW50KSkge1xuICAgICAgICBuZXh0W2lzQ2xlYW5dID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0KCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB1bmRlZmluZWRcbiAgICBsZXQgaW5kZXggPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKVxuICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCArIDFdXG4gIH1cblxuICBwb3NpdGlvbkJ5KG9wdHMsIHN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gICAgbGV0IHBvcyA9IHRoaXMuc291cmNlLnN0YXJ0XG4gICAgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCwgc3RyaW5nUmVwcmVzZW50YXRpb24pXG4gICAgfSBlbHNlIGlmIChvcHRzLndvcmQpIHtcbiAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpXG4gICAgICBsZXQgaW5kZXggPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZClcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICBwb3NpdGlvbkluc2lkZShpbmRleCwgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICBsZXQgc3RyaW5nID0gc3RyaW5nUmVwcmVzZW50YXRpb24gfHwgdGhpcy50b1N0cmluZygpXG4gICAgbGV0IGNvbHVtbiA9IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtblxuICAgIGxldCBsaW5lID0gdGhpcy5zb3VyY2Uuc3RhcnQubGluZVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09PSAnXFxuJykge1xuICAgICAgICBjb2x1bW4gPSAxXG4gICAgICAgIGxpbmUgKz0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUgfVxuICB9XG5cbiAgcHJldigpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdW5kZWZpbmVkXG4gICAgbGV0IGluZGV4ID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcylcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXggLSAxXVxuICB9XG5cbiAgcmFuZ2VCeShvcHRzKSB7XG4gICAgbGV0IHN0YXJ0ID0ge1xuICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4sXG4gICAgICBsaW5lOiB0aGlzLnNvdXJjZS5zdGFydC5saW5lXG4gICAgfVxuICAgIGxldCBlbmQgPSB0aGlzLnNvdXJjZS5lbmRcbiAgICAgID8ge1xuICAgICAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2UuZW5kLmNvbHVtbiArIDEsXG4gICAgICAgICAgbGluZTogdGhpcy5zb3VyY2UuZW5kLmxpbmVcbiAgICAgICAgfVxuICAgICAgOiB7XG4gICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgfVxuXG4gICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgbGV0IHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpXG4gICAgICBsZXQgaW5kZXggPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZClcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4LCBzdHJpbmdSZXByZXNlbnRhdGlvbilcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShcbiAgICAgICAgICBpbmRleCArIG9wdHMud29yZC5sZW5ndGgsXG4gICAgICAgICAgc3RyaW5nUmVwcmVzZW50YXRpb25cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0cy5zdGFydCkge1xuICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICBjb2x1bW46IG9wdHMuc3RhcnQuY29sdW1uLFxuICAgICAgICAgIGxpbmU6IG9wdHMuc3RhcnQubGluZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmVuZCkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgY29sdW1uOiBvcHRzLmVuZC5jb2x1bW4sXG4gICAgICAgICAgbGluZTogb3B0cy5lbmQubGluZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmVuZEluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuZW5kSW5kZXgpXG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4ICsgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBlbmQubGluZSA8IHN0YXJ0LmxpbmUgfHxcbiAgICAgIChlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBlbmQuY29sdW1uIDw9IHN0YXJ0LmNvbHVtbilcbiAgICApIHtcbiAgICAgIGVuZCA9IHsgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLCBsaW5lOiBzdGFydC5saW5lIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBlbmQsIHN0YXJ0IH1cbiAgfVxuXG4gIHJhdyhwcm9wLCBkZWZhdWx0VHlwZSkge1xuICAgIGxldCBzdHIgPSBuZXcgU3RyaW5naWZpZXIoKVxuICAgIHJldHVybiBzdHIucmF3KHRoaXMsIHByb3AsIGRlZmF1bHRUeXBlKVxuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcylcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVwbGFjZVdpdGgoLi4ubm9kZXMpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGxldCBib29rbWFyayA9IHRoaXNcbiAgICAgIGxldCBmb3VuZFNlbGYgPSBmYWxzZVxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcykge1xuICAgICAgICAgIGZvdW5kU2VsZiA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZFNlbGYpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcihib29rbWFyaywgbm9kZSlcbiAgICAgICAgICBib29rbWFyayA9IG5vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYm9va21hcmssIG5vZGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZFNlbGYpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByb290KCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzXG4gICAgd2hpbGUgKHJlc3VsdC5wYXJlbnQgJiYgcmVzdWx0LnBhcmVudC50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQucGFyZW50XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHRvSlNPTihfLCBpbnB1dHMpIHtcbiAgICBsZXQgZml4ZWQgPSB7fVxuICAgIGxldCBlbWl0SW5wdXRzID0gaW5wdXRzID09IG51bGxcbiAgICBpbnB1dHMgPSBpbnB1dHMgfHwgbmV3IE1hcCgpXG4gICAgbGV0IGlucHV0c05leHRJbmRleCA9IDBcblxuICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgbmFtZSkpIHtcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09ICdwYXJlbnQnIHx8IG5hbWUgPT09ICdwcm94eUNhY2hlJykgY29udGludWVcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXNbbmFtZV1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUubWFwKGkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ29iamVjdCcgJiYgaS50b0pTT04pIHtcbiAgICAgICAgICAgIHJldHVybiBpLnRvSlNPTihudWxsLCBpbnB1dHMpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLnRvSlNPTikge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLnRvSlNPTihudWxsLCBpbnB1dHMpXG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgIGxldCBpbnB1dElkID0gaW5wdXRzLmdldCh2YWx1ZS5pbnB1dClcbiAgICAgICAgaWYgKGlucHV0SWQgPT0gbnVsbCkge1xuICAgICAgICAgIGlucHV0SWQgPSBpbnB1dHNOZXh0SW5kZXhcbiAgICAgICAgICBpbnB1dHMuc2V0KHZhbHVlLmlucHV0LCBpbnB1dHNOZXh0SW5kZXgpXG4gICAgICAgICAgaW5wdXRzTmV4dEluZGV4KytcbiAgICAgICAgfVxuICAgICAgICBmaXhlZFtuYW1lXSA9IHtcbiAgICAgICAgICBlbmQ6IHZhbHVlLmVuZCxcbiAgICAgICAgICBpbnB1dElkLFxuICAgICAgICAgIHN0YXJ0OiB2YWx1ZS5zdGFydFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVtaXRJbnB1dHMpIHtcbiAgICAgIGZpeGVkLmlucHV0cyA9IFsuLi5pbnB1dHMua2V5cygpXS5tYXAoaW5wdXQgPT4gaW5wdXQudG9KU09OKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZpeGVkXG4gIH1cblxuICB0b1Byb3h5KCkge1xuICAgIGlmICghdGhpcy5wcm94eUNhY2hlKSB7XG4gICAgICB0aGlzLnByb3h5Q2FjaGUgPSBuZXcgUHJveHkodGhpcywgdGhpcy5nZXRQcm94eVByb2Nlc3NvcigpKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm94eUNhY2hlXG4gIH1cblxuICB0b1N0cmluZyhzdHJpbmdpZmllciA9IHN0cmluZ2lmeSkge1xuICAgIGlmIChzdHJpbmdpZmllci5zdHJpbmdpZnkpIHN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXIuc3RyaW5naWZ5XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgc3RyaW5naWZpZXIodGhpcywgaSA9PiB7XG4gICAgICByZXN1bHQgKz0gaVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgd2FybihyZXN1bHQsIHRleHQsIG9wdHMpIHtcbiAgICBsZXQgZGF0YSA9IHsgbm9kZTogdGhpcyB9XG4gICAgZm9yIChsZXQgaSBpbiBvcHRzKSBkYXRhW2ldID0gb3B0c1tpXVxuICAgIHJldHVybiByZXN1bHQud2Fybih0ZXh0LCBkYXRhKVxuICB9XG5cbiAgZ2V0IHByb3h5T2YoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVcbk5vZGUuZGVmYXVsdCA9IE5vZGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXInKVxubGV0IElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpXG5sZXQgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKVxuXG5mdW5jdGlvbiBwYXJzZShjc3MsIG9wdHMpIHtcbiAgbGV0IGlucHV0ID0gbmV3IElucHV0KGNzcywgb3B0cylcbiAgbGV0IHBhcnNlciA9IG5ldyBQYXJzZXIoaW5wdXQpXG4gIHRyeSB7XG4gICAgcGFyc2VyLnBhcnNlKClcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZS5uYW1lID09PSAnQ3NzU3ludGF4RXJyb3InICYmIG9wdHMgJiYgb3B0cy5mcm9tKSB7XG4gICAgICAgIGlmICgvXFwuc2NzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICBlLm1lc3NhZ2UgKz1cbiAgICAgICAgICAgICdcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgU0NTUyB3aXRoICcgK1xuICAgICAgICAgICAgJ3RoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyAnICtcbiAgICAgICAgICAgICd0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1zY3NzIHBhcnNlcidcbiAgICAgICAgfSBlbHNlIGlmICgvXFwuc2Fzcy9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUubWVzc2FnZSArPVxuICAgICAgICAgICAgJ1xcbllvdSB0cmllZCB0byBwYXJzZSBTYXNzIHdpdGggJyArXG4gICAgICAgICAgICAndGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7ICcgK1xuICAgICAgICAgICAgJ3RyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNhc3MgcGFyc2VyJ1xuICAgICAgICB9IGVsc2UgaWYgKC9cXC5sZXNzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUubWVzc2FnZSArPVxuICAgICAgICAgICAgJ1xcbllvdSB0cmllZCB0byBwYXJzZSBMZXNzIHdpdGggJyArXG4gICAgICAgICAgICAndGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7ICcgK1xuICAgICAgICAgICAgJ3RyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLWxlc3MgcGFyc2VyJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGVcbiAgfVxuXG4gIHJldHVybiBwYXJzZXIucm9vdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG5wYXJzZS5kZWZhdWx0ID0gcGFyc2VcblxuQ29udGFpbmVyLnJlZ2lzdGVyUGFyc2UocGFyc2UpXG4iLCIndXNlIHN0cmljdCdcblxubGV0IEF0UnVsZSA9IHJlcXVpcmUoJy4vYXQtcnVsZScpXG5sZXQgQ29tbWVudCA9IHJlcXVpcmUoJy4vY29tbWVudCcpXG5sZXQgRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL2RlY2xhcmF0aW9uJylcbmxldCBSb290ID0gcmVxdWlyZSgnLi9yb290JylcbmxldCBSdWxlID0gcmVxdWlyZSgnLi9ydWxlJylcbmxldCB0b2tlbml6ZXIgPSByZXF1aXJlKCcuL3Rva2VuaXplJylcblxuY29uc3QgU0FGRV9DT01NRU5UX05FSUdIQk9SID0ge1xuICBlbXB0eTogdHJ1ZSxcbiAgc3BhY2U6IHRydWVcbn1cblxuZnVuY3Rpb24gZmluZExhc3RXaXRoUG9zaXRpb24odG9rZW5zKSB7XG4gIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICBsZXQgcG9zID0gdG9rZW5bM10gfHwgdG9rZW5bMl1cbiAgICBpZiAocG9zKSByZXR1cm4gcG9zXG4gIH1cbn1cblxuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXRcblxuICAgIHRoaXMucm9vdCA9IG5ldyBSb290KClcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJvb3RcbiAgICB0aGlzLnNwYWNlcyA9ICcnXG4gICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZVxuXG4gICAgdGhpcy5jcmVhdGVUb2tlbml6ZXIoKVxuICAgIHRoaXMucm9vdC5zb3VyY2UgPSB7IGlucHV0LCBzdGFydDogeyBjb2x1bW46IDEsIGxpbmU6IDEsIG9mZnNldDogMCB9IH1cbiAgfVxuXG4gIGF0cnVsZSh0b2tlbikge1xuICAgIGxldCBub2RlID0gbmV3IEF0UnVsZSgpXG4gICAgbm9kZS5uYW1lID0gdG9rZW5bMV0uc2xpY2UoMSlcbiAgICBpZiAobm9kZS5uYW1lID09PSAnJykge1xuICAgICAgdGhpcy51bm5hbWVkQXRydWxlKG5vZGUsIHRva2VuKVxuICAgIH1cbiAgICB0aGlzLmluaXQobm9kZSwgdG9rZW5bMl0pXG5cbiAgICBsZXQgdHlwZVxuICAgIGxldCBwcmV2XG4gICAgbGV0IHNoaWZ0XG4gICAgbGV0IGxhc3QgPSBmYWxzZVxuICAgIGxldCBvcGVuID0gZmFsc2VcbiAgICBsZXQgcGFyYW1zID0gW11cbiAgICBsZXQgYnJhY2tldHMgPSBbXVxuXG4gICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKVxuICAgICAgdHlwZSA9IHRva2VuWzBdXG5cbiAgICAgIGlmICh0eXBlID09PSAnKCcgfHwgdHlwZSA9PT0gJ1snKSB7XG4gICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gJygnID8gJyknIDogJ10nKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAneycgJiYgYnJhY2tldHMubGVuZ3RoID4gMCkge1xuICAgICAgICBicmFja2V0cy5wdXNoKCd9JylcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgYnJhY2tldHMucG9wKClcbiAgICAgIH1cblxuICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJzsnKSB7XG4gICAgICAgICAgbm9kZS5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSlcbiAgICAgICAgICBub2RlLnNvdXJjZS5lbmQub2Zmc2V0KytcbiAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICAgIG9wZW4gPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnfScpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gcGFyYW1zLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdXG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBwcmV2WzBdID09PSAnc3BhY2UnKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbLS1zaGlmdF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgIG5vZGUuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24ocHJldlszXSB8fCBwcmV2WzJdKVxuICAgICAgICAgICAgICBub2RlLnNvdXJjZS5lbmQub2Zmc2V0KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmQodG9rZW4pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXMucHVzaCh0b2tlbilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgICBsYXN0ID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQocGFyYW1zKVxuICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICBub2RlLnJhd3MuYWZ0ZXJOYW1lID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydChwYXJhbXMpXG4gICAgICB0aGlzLnJhdyhub2RlLCAncGFyYW1zJywgcGFyYW1zKVxuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgdG9rZW4gPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdXG4gICAgICAgIG5vZGUuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pXG4gICAgICAgIG5vZGUuc291cmNlLmVuZC5vZmZzZXQrK1xuICAgICAgICB0aGlzLnNwYWNlcyA9IG5vZGUucmF3cy5iZXR3ZWVuXG4gICAgICAgIG5vZGUucmF3cy5iZXR3ZWVuID0gJydcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5yYXdzLmFmdGVyTmFtZSA9ICcnXG4gICAgICBub2RlLnBhcmFtcyA9ICcnXG4gICAgfVxuXG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIG5vZGUubm9kZXMgPSBbXVxuICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZVxuICAgIH1cbiAgfVxuXG4gIGNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucykge1xuICAgIGxldCBjb2xvbiA9IHRoaXMuY29sb24odG9rZW5zKVxuICAgIGlmIChjb2xvbiA9PT0gZmFsc2UpIHJldHVyblxuXG4gICAgbGV0IGZvdW5kZWQgPSAwXG4gICAgbGV0IHRva2VuXG4gICAgZm9yIChsZXQgaiA9IGNvbG9uIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2pdXG4gICAgICBpZiAodG9rZW5bMF0gIT09ICdzcGFjZScpIHtcbiAgICAgICAgZm91bmRlZCArPSAxXG4gICAgICAgIGlmIChmb3VuZGVkID09PSAyKSBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgdG9rZW4gaXMgYSB3b3JkLCBlLmcuIGAhaW1wb3J0YW50YCwgYHJlZGAgb3IgYW55IG90aGVyIHZhbGlkIHByb3BlcnR5J3MgdmFsdWUuXG4gICAgLy8gVGhlbiB3ZSBuZWVkIHRvIHJldHVybiB0aGUgY29sb24gYWZ0ZXIgdGhhdCB3b3JkIHRva2VuLiBbM10gaXMgdGhlIFwiZW5kXCIgY29sb24gb2YgdGhhdCB3b3JkLlxuICAgIC8vIEFuZCBiZWNhdXNlIHdlIG5lZWQgaXQgYWZ0ZXIgdGhhdCBvbmUgd2UgZG8gKzEgdG8gZ2V0IHRoZSBuZXh0IG9uZS5cbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgJ01pc3NlZCBzZW1pY29sb24nLFxuICAgICAgdG9rZW5bMF0gPT09ICd3b3JkJyA/IHRva2VuWzNdICsgMSA6IHRva2VuWzJdXG4gICAgKVxuICB9XG5cbiAgY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGJyYWNrZXRzID0gMFxuICAgIGxldCBwcmV2LCB0b2tlbiwgdHlwZVxuICAgIGZvciAobGV0IFtpLCBlbGVtZW50XSBvZiB0b2tlbnMuZW50cmllcygpKSB7XG4gICAgICB0b2tlbiA9IGVsZW1lbnRcbiAgICAgIHR5cGUgPSB0b2tlblswXVxuXG4gICAgICBpZiAodHlwZSA9PT0gJygnKSB7XG4gICAgICAgIGJyYWNrZXRzICs9IDFcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnKScpIHtcbiAgICAgICAgYnJhY2tldHMgLT0gMVxuICAgICAgfVxuICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09ICc6Jykge1xuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICB0aGlzLmRvdWJsZUNvbG9uKHRva2VuKVxuICAgICAgICB9IGVsc2UgaWYgKHByZXZbMF0gPT09ICd3b3JkJyAmJiBwcmV2WzFdID09PSAncHJvZ2lkJykge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2ID0gdG9rZW5cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb21tZW50KHRva2VuKSB7XG4gICAgbGV0IG5vZGUgPSBuZXcgQ29tbWVudCgpXG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2VuWzJdKVxuICAgIG5vZGUuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pXG4gICAgbm9kZS5zb3VyY2UuZW5kLm9mZnNldCsrXG5cbiAgICBsZXQgdGV4dCA9IHRva2VuWzFdLnNsaWNlKDIsIC0yKVxuICAgIGlmICgvXlxccyokLy50ZXN0KHRleHQpKSB7XG4gICAgICBub2RlLnRleHQgPSAnJ1xuICAgICAgbm9kZS5yYXdzLmxlZnQgPSB0ZXh0XG4gICAgICBub2RlLnJhd3MucmlnaHQgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpcXFMpKFxccyopJC8pXG4gICAgICBub2RlLnRleHQgPSBtYXRjaFsyXVxuICAgICAgbm9kZS5yYXdzLmxlZnQgPSBtYXRjaFsxXVxuICAgICAgbm9kZS5yYXdzLnJpZ2h0ID0gbWF0Y2hbM11cbiAgICB9XG4gIH1cblxuICBjcmVhdGVUb2tlbml6ZXIoKSB7XG4gICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXIodGhpcy5pbnB1dClcbiAgfVxuXG4gIGRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgIGxldCBub2RlID0gbmV3IERlY2xhcmF0aW9uKClcbiAgICB0aGlzLmluaXQobm9kZSwgdG9rZW5zWzBdWzJdKVxuXG4gICAgbGV0IGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdXG4gICAgaWYgKGxhc3RbMF0gPT09ICc7Jykge1xuICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlXG4gICAgICB0b2tlbnMucG9wKClcbiAgICB9XG5cbiAgICBub2RlLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKFxuICAgICAgbGFzdFszXSB8fCBsYXN0WzJdIHx8IGZpbmRMYXN0V2l0aFBvc2l0aW9uKHRva2VucylcbiAgICApXG4gICAgbm9kZS5zb3VyY2UuZW5kLm9mZnNldCsrXG5cbiAgICB3aGlsZSAodG9rZW5zWzBdWzBdICE9PSAnd29yZCcpIHtcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB0aGlzLnVua25vd25Xb3JkKHRva2VucylcbiAgICAgIG5vZGUucmF3cy5iZWZvcmUgKz0gdG9rZW5zLnNoaWZ0KClbMV1cbiAgICB9XG4gICAgbm9kZS5zb3VyY2Uuc3RhcnQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2Vuc1swXVsyXSlcblxuICAgIG5vZGUucHJvcCA9ICcnXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxldCB0eXBlID0gdG9rZW5zWzBdWzBdXG4gICAgICBpZiAodHlwZSA9PT0gJzonIHx8IHR5cGUgPT09ICdzcGFjZScgfHwgdHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBub2RlLnByb3AgKz0gdG9rZW5zLnNoaWZ0KClbMV1cbiAgICB9XG5cbiAgICBub2RlLnJhd3MuYmV0d2VlbiA9ICcnXG5cbiAgICBsZXQgdG9rZW5cbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKVxuXG4gICAgICBpZiAodG9rZW5bMF0gPT09ICc6Jykge1xuICAgICAgICBub2RlLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSAnd29yZCcgJiYgL1xcdy8udGVzdCh0b2tlblsxXSkpIHtcbiAgICAgICAgICB0aGlzLnVua25vd25Xb3JkKFt0b2tlbl0pXG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5wcm9wWzBdID09PSAnXycgfHwgbm9kZS5wcm9wWzBdID09PSAnKicpIHtcbiAgICAgIG5vZGUucmF3cy5iZWZvcmUgKz0gbm9kZS5wcm9wWzBdXG4gICAgICBub2RlLnByb3AgPSBub2RlLnByb3Auc2xpY2UoMSlcbiAgICB9XG5cbiAgICBsZXQgZmlyc3RTcGFjZXMgPSBbXVxuICAgIGxldCBuZXh0XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF1cbiAgICAgIGlmIChuZXh0ICE9PSAnc3BhY2UnICYmIG5leHQgIT09ICdjb21tZW50JykgYnJlYWtcbiAgICAgIGZpcnN0U3BhY2VzLnB1c2godG9rZW5zLnNoaWZ0KCkpXG4gICAgfVxuXG4gICAgdGhpcy5wcmVjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpXG5cbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXVxuICAgICAgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09ICchaW1wb3J0YW50Jykge1xuICAgICAgICBub2RlLmltcG9ydGFudCA9IHRydWVcbiAgICAgICAgbGV0IHN0cmluZyA9IHRoaXMuc3RyaW5nRnJvbSh0b2tlbnMsIGkpXG4gICAgICAgIHN0cmluZyA9IHRoaXMuc3BhY2VzRnJvbUVuZCh0b2tlbnMpICsgc3RyaW5nXG4gICAgICAgIGlmIChzdHJpbmcgIT09ICcgIWltcG9ydGFudCcpIG5vZGUucmF3cy5pbXBvcnRhbnQgPSBzdHJpbmdcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2ltcG9ydGFudCcpIHtcbiAgICAgICAgbGV0IGNhY2hlID0gdG9rZW5zLnNsaWNlKDApXG4gICAgICAgIGxldCBzdHIgPSAnJ1xuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgIGxldCB0eXBlID0gY2FjaGVbal1bMF1cbiAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5zdGFydHNXaXRoKCchJykgJiYgdHlwZSAhPT0gJ3NwYWNlJykge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyID0gY2FjaGUucG9wKClbMV0gKyBzdHJcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnRyaW0oKS5zdGFydHNXaXRoKCchJykpIHtcbiAgICAgICAgICBub2RlLmltcG9ydGFudCA9IHRydWVcbiAgICAgICAgICBub2RlLnJhd3MuaW1wb3J0YW50ID0gc3RyXG4gICAgICAgICAgdG9rZW5zID0gY2FjaGVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW5bMF0gIT09ICdzcGFjZScgJiYgdG9rZW5bMF0gIT09ICdjb21tZW50Jykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBoYXNXb3JkID0gdG9rZW5zLnNvbWUoaSA9PiBpWzBdICE9PSAnc3BhY2UnICYmIGlbMF0gIT09ICdjb21tZW50JylcblxuICAgIGlmIChoYXNXb3JkKSB7XG4gICAgICBub2RlLnJhd3MuYmV0d2VlbiArPSBmaXJzdFNwYWNlcy5tYXAoaSA9PiBpWzFdKS5qb2luKCcnKVxuICAgICAgZmlyc3RTcGFjZXMgPSBbXVxuICAgIH1cbiAgICB0aGlzLnJhdyhub2RlLCAndmFsdWUnLCBmaXJzdFNwYWNlcy5jb25jYXQodG9rZW5zKSwgY3VzdG9tUHJvcGVydHkpXG5cbiAgICBpZiAobm9kZS52YWx1ZS5pbmNsdWRlcygnOicpICYmICFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgdGhpcy5jaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpXG4gICAgfVxuICB9XG5cbiAgZG91YmxlQ29sb24odG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgJ0RvdWJsZSBjb2xvbicsXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aCB9XG4gICAgKVxuICB9XG5cbiAgZW1wdHlSdWxlKHRva2VuKSB7XG4gICAgbGV0IG5vZGUgPSBuZXcgUnVsZSgpXG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2VuWzJdKVxuICAgIG5vZGUuc2VsZWN0b3IgPSAnJ1xuICAgIG5vZGUucmF3cy5iZXR3ZWVuID0gJydcbiAgICB0aGlzLmN1cnJlbnQgPSBub2RlXG4gIH1cblxuICBlbmQodG9rZW4pIHtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uXG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2VcblxuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8ICcnKSArIHRoaXMuc3BhY2VzXG4gICAgdGhpcy5zcGFjZXMgPSAnJ1xuXG4gICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSlcbiAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kLm9mZnNldCsrXG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucGFyZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZENsb3NlKHRva2VuKVxuICAgIH1cbiAgfVxuXG4gIGVuZEZpbGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHRoaXMudW5jbG9zZWRCbG9jaygpXG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvblxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCAnJykgKyB0aGlzLnNwYWNlc1xuICAgIHRoaXMucm9vdC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLnRva2VuaXplci5wb3NpdGlvbigpKVxuICB9XG5cbiAgZnJlZVNlbWljb2xvbih0b2tlbikge1xuICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdXG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2Rlcykge1xuICAgICAgbGV0IHByZXYgPSB0aGlzLmN1cnJlbnQubm9kZXNbdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCAtIDFdXG4gICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICdydWxlJyAmJiAhcHJldi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgICBwcmV2LnJhd3Mub3duU2VtaWNvbG9uID0gdGhpcy5zcGFjZXNcbiAgICAgICAgdGhpcy5zcGFjZXMgPSAnJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHBlcnNcblxuICBnZXRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5mcm9tT2Zmc2V0KG9mZnNldClcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uOiBwb3MuY29sLFxuICAgICAgbGluZTogcG9zLmxpbmUsXG4gICAgICBvZmZzZXRcbiAgICB9XG4gIH1cblxuICBpbml0KG5vZGUsIG9mZnNldCkge1xuICAgIHRoaXMuY3VycmVudC5wdXNoKG5vZGUpXG4gICAgbm9kZS5zb3VyY2UgPSB7XG4gICAgICBpbnB1dDogdGhpcy5pbnB1dCxcbiAgICAgIHN0YXJ0OiB0aGlzLmdldFBvc2l0aW9uKG9mZnNldClcbiAgICB9XG4gICAgbm9kZS5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzXG4gICAgdGhpcy5zcGFjZXMgPSAnJ1xuICAgIGlmIChub2RlLnR5cGUgIT09ICdjb21tZW50JykgdGhpcy5zZW1pY29sb24gPSBmYWxzZVxuICB9XG5cbiAgb3RoZXIoc3RhcnQpIHtcbiAgICBsZXQgZW5kID0gZmFsc2VcbiAgICBsZXQgdHlwZSA9IG51bGxcbiAgICBsZXQgY29sb24gPSBmYWxzZVxuICAgIGxldCBicmFja2V0ID0gbnVsbFxuICAgIGxldCBicmFja2V0cyA9IFtdXG4gICAgbGV0IGN1c3RvbVByb3BlcnR5ID0gc3RhcnRbMV0uc3RhcnRzV2l0aCgnLS0nKVxuXG4gICAgbGV0IHRva2VucyA9IFtdXG4gICAgbGV0IHRva2VuID0gc3RhcnRcbiAgICB3aGlsZSAodG9rZW4pIHtcbiAgICAgIHR5cGUgPSB0b2tlblswXVxuICAgICAgdG9rZW5zLnB1c2godG9rZW4pXG5cbiAgICAgIGlmICh0eXBlID09PSAnKCcgfHwgdHlwZSA9PT0gJ1snKSB7XG4gICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuXG4gICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gJygnID8gJyknIDogJ10nKVxuICAgICAgfSBlbHNlIGlmIChjdXN0b21Qcm9wZXJ0eSAmJiBjb2xvbiAmJiB0eXBlID09PSAneycpIHtcbiAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW5cbiAgICAgICAgYnJhY2tldHMucHVzaCgnfScpXG4gICAgICB9IGVsc2UgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJzsnKSB7XG4gICAgICAgICAgaWYgKGNvbG9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAneycpIHtcbiAgICAgICAgICB0aGlzLnJ1bGUodG9rZW5zKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd9Jykge1xuICAgICAgICAgIHRoaXMudG9rZW5pemVyLmJhY2sodG9rZW5zLnBvcCgpKVxuICAgICAgICAgIGVuZCA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICc6Jykge1xuICAgICAgICAgIGNvbG9uID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGJyYWNrZXRzLnBvcCgpXG4gICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIGJyYWNrZXQgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIGVuZCA9IHRydWVcbiAgICBpZiAoYnJhY2tldHMubGVuZ3RoID4gMCkgdGhpcy51bmNsb3NlZEJyYWNrZXQoYnJhY2tldClcblxuICAgIGlmIChlbmQgJiYgY29sb24pIHtcbiAgICAgIGlmICghY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF1cbiAgICAgICAgICBpZiAodG9rZW4gIT09ICdzcGFjZScgJiYgdG9rZW4gIT09ICdjb21tZW50JykgYnJlYWtcbiAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5rbm93bldvcmQodG9rZW5zKVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlKCkge1xuICAgIGxldCB0b2tlblxuICAgIHdoaWxlICghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKClcblxuICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV1cbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJzsnOlxuICAgICAgICAgIHRoaXMuZnJlZVNlbWljb2xvbih0b2tlbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgIHRoaXMuZW5kKHRva2VuKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgdGhpcy5jb21tZW50KHRva2VuKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnYXQtd29yZCc6XG4gICAgICAgICAgdGhpcy5hdHJ1bGUodG9rZW4pXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICB0aGlzLmVtcHR5UnVsZSh0b2tlbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5vdGhlcih0b2tlbilcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVuZEZpbGUoKVxuICB9XG5cbiAgcHJlY2hlY2tNaXNzZWRTZW1pY29sb24oLyogdG9rZW5zICovKSB7XG4gICAgLy8gSG9vayBmb3IgU2FmZSBQYXJzZXJcbiAgfVxuXG4gIHJhdyhub2RlLCBwcm9wLCB0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgbGV0IHRva2VuLCB0eXBlXG4gICAgbGV0IGxlbmd0aCA9IHRva2Vucy5sZW5ndGhcbiAgICBsZXQgdmFsdWUgPSAnJ1xuICAgIGxldCBjbGVhbiA9IHRydWVcbiAgICBsZXQgbmV4dCwgcHJldlxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICAgIHR5cGUgPSB0b2tlblswXVxuICAgICAgaWYgKHR5cGUgPT09ICdzcGFjZScgJiYgaSA9PT0gbGVuZ3RoIC0gMSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgY2xlYW4gPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29tbWVudCcpIHtcbiAgICAgICAgcHJldiA9IHRva2Vuc1tpIC0gMV0gPyB0b2tlbnNbaSAtIDFdWzBdIDogJ2VtcHR5J1xuICAgICAgICBuZXh0ID0gdG9rZW5zW2kgKyAxXSA/IHRva2Vuc1tpICsgMV1bMF0gOiAnZW1wdHknXG4gICAgICAgIGlmICghU0FGRV9DT01NRU5UX05FSUdIQk9SW3ByZXZdICYmICFTQUZFX0NPTU1FTlRfTkVJR0hCT1JbbmV4dF0pIHtcbiAgICAgICAgICBpZiAodmFsdWUuc2xpY2UoLTEpID09PSAnLCcpIHtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW4gPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSB0b2tlblsxXVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsZWFuKSB7XG4gICAgICBsZXQgcmF3ID0gdG9rZW5zLnJlZHVjZSgoYWxsLCBpKSA9PiBhbGwgKyBpWzFdLCAnJylcbiAgICAgIG5vZGUucmF3c1twcm9wXSA9IHsgcmF3LCB2YWx1ZSB9XG4gICAgfVxuICAgIG5vZGVbcHJvcF0gPSB2YWx1ZVxuICB9XG5cbiAgcnVsZSh0b2tlbnMpIHtcbiAgICB0b2tlbnMucG9wKClcblxuICAgIGxldCBub2RlID0gbmV3IFJ1bGUoKVxuICAgIHRoaXMuaW5pdChub2RlLCB0b2tlbnNbMF1bMl0pXG5cbiAgICBub2RlLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2VucylcbiAgICB0aGlzLnJhdyhub2RlLCAnc2VsZWN0b3InLCB0b2tlbnMpXG4gICAgdGhpcy5jdXJyZW50ID0gbm9kZVxuICB9XG5cbiAgc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucykge1xuICAgIGxldCBsYXN0VG9rZW5UeXBlXG4gICAgbGV0IHNwYWNlcyA9ICcnXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdXG4gICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gJ3NwYWNlJyAmJiBsYXN0VG9rZW5UeXBlICE9PSAnY29tbWVudCcpIGJyZWFrXG4gICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXNcbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlc1xuICB9XG5cbiAgLy8gRXJyb3JzXG5cbiAgc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQodG9rZW5zKSB7XG4gICAgbGV0IG5leHRcbiAgICBsZXQgc3BhY2VzID0gJydcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbmV4dCA9IHRva2Vuc1swXVswXVxuICAgICAgaWYgKG5leHQgIT09ICdzcGFjZScgJiYgbmV4dCAhPT0gJ2NvbW1lbnQnKSBicmVha1xuICAgICAgc3BhY2VzICs9IHRva2Vucy5zaGlmdCgpWzFdXG4gICAgfVxuICAgIHJldHVybiBzcGFjZXNcbiAgfVxuXG4gIHNwYWNlc0Zyb21FbmQodG9rZW5zKSB7XG4gICAgbGV0IGxhc3RUb2tlblR5cGVcbiAgICBsZXQgc3BhY2VzID0gJydcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF1cbiAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSAnc3BhY2UnKSBicmVha1xuICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzXG4gICAgfVxuICAgIHJldHVybiBzcGFjZXNcbiAgfVxuXG4gIHN0cmluZ0Zyb20odG9rZW5zLCBmcm9tKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbnNbaV1bMV1cbiAgICB9XG4gICAgdG9rZW5zLnNwbGljZShmcm9tLCB0b2tlbnMubGVuZ3RoIC0gZnJvbSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB1bmNsb3NlZEJsb2NrKCkge1xuICAgIGxldCBwb3MgPSB0aGlzLmN1cnJlbnQuc291cmNlLnN0YXJ0XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcignVW5jbG9zZWQgYmxvY2snLCBwb3MubGluZSwgcG9zLmNvbHVtbilcbiAgfVxuXG4gIHVuY2xvc2VkQnJhY2tldChicmFja2V0KSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgICdVbmNsb3NlZCBicmFja2V0JyxcbiAgICAgIHsgb2Zmc2V0OiBicmFja2V0WzJdIH0sXG4gICAgICB7IG9mZnNldDogYnJhY2tldFsyXSArIDEgfVxuICAgIClcbiAgfVxuXG4gIHVuZXhwZWN0ZWRDbG9zZSh0b2tlbikge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICAnVW5leHBlY3RlZCB9JyxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgMSB9XG4gICAgKVxuICB9XG5cbiAgdW5rbm93bldvcmQodG9rZW5zKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgICdVbmtub3duIHdvcmQnLFxuICAgICAgeyBvZmZzZXQ6IHRva2Vuc1swXVsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2Vuc1swXVsyXSArIHRva2Vuc1swXVsxXS5sZW5ndGggfVxuICAgIClcbiAgfVxuXG4gIHVubmFtZWRBdHJ1bGUobm9kZSwgdG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgJ0F0LXJ1bGUgd2l0aG91dCBuYW1lJyxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoIH1cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgQXRSdWxlID0gcmVxdWlyZSgnLi9hdC1ydWxlJylcbmxldCBDb21tZW50ID0gcmVxdWlyZSgnLi9jb21tZW50JylcbmxldCBDb250YWluZXIgPSByZXF1aXJlKCcuL2NvbnRhaW5lcicpXG5sZXQgQ3NzU3ludGF4RXJyb3IgPSByZXF1aXJlKCcuL2Nzcy1zeW50YXgtZXJyb3InKVxubGV0IERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9kZWNsYXJhdGlvbicpXG5sZXQgRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50JylcbmxldCBmcm9tSlNPTiA9IHJlcXVpcmUoJy4vZnJvbUpTT04nKVxubGV0IElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpXG5sZXQgTGF6eVJlc3VsdCA9IHJlcXVpcmUoJy4vbGF6eS1yZXN1bHQnKVxubGV0IGxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKVxubGV0IE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKVxubGV0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5sZXQgUHJvY2Vzc29yID0gcmVxdWlyZSgnLi9wcm9jZXNzb3InKVxubGV0IFJlc3VsdCA9IHJlcXVpcmUoJy4vcmVzdWx0LmpzJylcbmxldCBSb290ID0gcmVxdWlyZSgnLi9yb290JylcbmxldCBSdWxlID0gcmVxdWlyZSgnLi9ydWxlJylcbmxldCBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpXG5sZXQgV2FybmluZyA9IHJlcXVpcmUoJy4vd2FybmluZycpXG5cbmZ1bmN0aW9uIHBvc3Rjc3MoLi4ucGx1Z2lucykge1xuICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9jZXNzb3IocGx1Z2lucylcbn1cblxucG9zdGNzcy5wbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4obmFtZSwgaW5pdGlhbGl6ZXIpIHtcbiAgbGV0IHdhcm5pbmdQcmludGVkID0gZmFsc2VcbiAgZnVuY3Rpb24gY3JlYXRvciguLi5hcmdzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgIXdhcm5pbmdQcmludGVkKSB7XG4gICAgICB3YXJuaW5nUHJpbnRlZCA9IHRydWVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIG5hbWUgK1xuICAgICAgICAgICc6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZXZpbG1hcnRpYW5zLmNvbS9jaHJvbmljbGVzL3Bvc3Rjc3MtOC1wbHVnaW4tbWlncmF0aW9uJ1xuICAgICAgKVxuICAgICAgaWYgKHByb2Nlc3MuZW52LkxBTkcgJiYgcHJvY2Vzcy5lbnYuTEFORy5zdGFydHNXaXRoKCdjbicpKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDcgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgJzog6YeM6Z2iIHBvc3Rjc3MucGx1Z2luIOiiq+W8g+eUqC4g6L+B56e75oyH5Y2XOlxcbicgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LnczY3RlY2guY29tL3RvcGljLzIyMjYnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRyYW5zZm9ybWVyID0gaW5pdGlhbGl6ZXIoLi4uYXJncylcbiAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzUGx1Z2luID0gbmFtZVxuICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NWZXJzaW9uID0gbmV3IFByb2Nlc3NvcigpLnZlcnNpb25cbiAgICByZXR1cm4gdHJhbnNmb3JtZXJcbiAgfVxuXG4gIGxldCBjYWNoZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgJ3Bvc3Rjc3MnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgaWYgKCFjYWNoZSkgY2FjaGUgPSBjcmVhdG9yKClcbiAgICAgIHJldHVybiBjYWNoZVxuICAgIH1cbiAgfSlcblxuICBjcmVhdG9yLnByb2Nlc3MgPSBmdW5jdGlvbiAoY3NzLCBwcm9jZXNzT3B0cywgcGx1Z2luT3B0cykge1xuICAgIHJldHVybiBwb3N0Y3NzKFtjcmVhdG9yKHBsdWdpbk9wdHMpXSkucHJvY2Vzcyhjc3MsIHByb2Nlc3NPcHRzKVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0b3Jcbn1cblxucG9zdGNzcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcbnBvc3Rjc3MucGFyc2UgPSBwYXJzZVxucG9zdGNzcy5mcm9tSlNPTiA9IGZyb21KU09OXG5wb3N0Y3NzLmxpc3QgPSBsaXN0XG5cbnBvc3Rjc3MuY29tbWVudCA9IGRlZmF1bHRzID0+IG5ldyBDb21tZW50KGRlZmF1bHRzKVxucG9zdGNzcy5hdFJ1bGUgPSBkZWZhdWx0cyA9PiBuZXcgQXRSdWxlKGRlZmF1bHRzKVxucG9zdGNzcy5kZWNsID0gZGVmYXVsdHMgPT4gbmV3IERlY2xhcmF0aW9uKGRlZmF1bHRzKVxucG9zdGNzcy5ydWxlID0gZGVmYXVsdHMgPT4gbmV3IFJ1bGUoZGVmYXVsdHMpXG5wb3N0Y3NzLnJvb3QgPSBkZWZhdWx0cyA9PiBuZXcgUm9vdChkZWZhdWx0cylcbnBvc3Rjc3MuZG9jdW1lbnQgPSBkZWZhdWx0cyA9PiBuZXcgRG9jdW1lbnQoZGVmYXVsdHMpXG5cbnBvc3Rjc3MuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvclxucG9zdGNzcy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uXG5wb3N0Y3NzLkNvbnRhaW5lciA9IENvbnRhaW5lclxucG9zdGNzcy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3JcbnBvc3Rjc3MuRG9jdW1lbnQgPSBEb2N1bWVudFxucG9zdGNzcy5Db21tZW50ID0gQ29tbWVudFxucG9zdGNzcy5XYXJuaW5nID0gV2FybmluZ1xucG9zdGNzcy5BdFJ1bGUgPSBBdFJ1bGVcbnBvc3Rjc3MuUmVzdWx0ID0gUmVzdWx0XG5wb3N0Y3NzLklucHV0ID0gSW5wdXRcbnBvc3Rjc3MuUnVsZSA9IFJ1bGVcbnBvc3Rjc3MuUm9vdCA9IFJvb3RcbnBvc3Rjc3MuTm9kZSA9IE5vZGVcblxuTGF6eVJlc3VsdC5yZWdpc3RlclBvc3Rjc3MocG9zdGNzcylcblxubW9kdWxlLmV4cG9ydHMgPSBwb3N0Y3NzXG5wb3N0Y3NzLmRlZmF1bHQgPSBwb3N0Y3NzXG4iLCIndXNlIHN0cmljdCdcblxubGV0IHsgZXhpc3RzU3luYywgcmVhZEZpbGVTeW5jIH0gPSByZXF1aXJlKCdmcycpXG5sZXQgeyBkaXJuYW1lLCBqb2luIH0gPSByZXF1aXJlKCdwYXRoJylcbmxldCB7IFNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAtanMnKVxuXG5mdW5jdGlvbiBmcm9tQmFzZTY0KHN0cikge1xuICBpZiAoQnVmZmVyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKClcbiAgfSBlbHNlIHtcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iKHN0cilcbiAgfVxufVxuXG5jbGFzcyBQcmV2aW91c01hcCB7XG4gIGNvbnN0cnVjdG9yKGNzcywgb3B0cykge1xuICAgIGlmIChvcHRzLm1hcCA9PT0gZmFsc2UpIHJldHVyblxuICAgIHRoaXMubG9hZEFubm90YXRpb24oY3NzKVxuICAgIHRoaXMuaW5saW5lID0gdGhpcy5zdGFydFdpdGgodGhpcy5hbm5vdGF0aW9uLCAnZGF0YTonKVxuXG4gICAgbGV0IHByZXYgPSBvcHRzLm1hcCA/IG9wdHMubWFwLnByZXYgOiB1bmRlZmluZWRcbiAgICBsZXQgdGV4dCA9IHRoaXMubG9hZE1hcChvcHRzLmZyb20sIHByZXYpXG4gICAgaWYgKCF0aGlzLm1hcEZpbGUgJiYgb3B0cy5mcm9tKSB7XG4gICAgICB0aGlzLm1hcEZpbGUgPSBvcHRzLmZyb21cbiAgICB9XG4gICAgaWYgKHRoaXMubWFwRmlsZSkgdGhpcy5yb290ID0gZGlybmFtZSh0aGlzLm1hcEZpbGUpXG4gICAgaWYgKHRleHQpIHRoaXMudGV4dCA9IHRleHRcbiAgfVxuXG4gIGNvbnN1bWVyKCkge1xuICAgIGlmICghdGhpcy5jb25zdW1lckNhY2hlKSB7XG4gICAgICB0aGlzLmNvbnN1bWVyQ2FjaGUgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIodGhpcy50ZXh0KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25zdW1lckNhY2hlXG4gIH1cblxuICBkZWNvZGVJbmxpbmUodGV4dCkge1xuICAgIGxldCBiYXNlQ2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzg7YmFzZTY0LC9cbiAgICBsZXQgYmFzZVVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247YmFzZTY0LC9cbiAgICBsZXQgY2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzgsL1xuICAgIGxldCB1cmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uLC9cblxuICAgIGxldCB1cmlNYXRjaCA9IHRleHQubWF0Y2goY2hhcnNldFVyaSkgfHwgdGV4dC5tYXRjaCh1cmkpXG4gICAgaWYgKHVyaU1hdGNoKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHRleHQuc3Vic3RyKHVyaU1hdGNoWzBdLmxlbmd0aCkpXG4gICAgfVxuXG4gICAgbGV0IGJhc2VVcmlNYXRjaCA9IHRleHQubWF0Y2goYmFzZUNoYXJzZXRVcmkpIHx8IHRleHQubWF0Y2goYmFzZVVyaSlcbiAgICBpZiAoYmFzZVVyaU1hdGNoKSB7XG4gICAgICByZXR1cm4gZnJvbUJhc2U2NCh0ZXh0LnN1YnN0cihiYXNlVXJpTWF0Y2hbMF0ubGVuZ3RoKSlcbiAgICB9XG5cbiAgICBsZXQgZW5jb2RpbmcgPSB0ZXh0Lm1hdGNoKC9kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW14sXSspLC8pWzFdXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzb3VyY2UgbWFwIGVuY29kaW5nICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGdldEFubm90YXRpb25VUkwoc291cmNlTWFwU3RyaW5nKSB7XG4gICAgcmV0dXJuIHNvdXJjZU1hcFN0cmluZy5yZXBsYWNlKC9eXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vLCAnJykudHJpbSgpXG4gIH1cblxuICBpc01hcChtYXApIHtcbiAgICBpZiAodHlwZW9mIG1hcCAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgbWFwLm1hcHBpbmdzID09PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIG1hcC5fbWFwcGluZ3MgPT09ICdzdHJpbmcnIHx8XG4gICAgICBBcnJheS5pc0FycmF5KG1hcC5zZWN0aW9ucylcbiAgICApXG4gIH1cblxuICBsb2FkQW5ub3RhdGlvbihjc3MpIHtcbiAgICBsZXQgY29tbWVudHMgPSBjc3MubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9L2cpXG4gICAgaWYgKCFjb21tZW50cykgcmV0dXJuXG5cbiAgICAvLyBzb3VyY2VNYXBwaW5nVVJMcyBmcm9tIGNvbW1lbnRzLCBzdHJpbmdzLCBldGMuXG4gICAgbGV0IHN0YXJ0ID0gY3NzLmxhc3RJbmRleE9mKGNvbW1lbnRzLnBvcCgpKVxuICAgIGxldCBlbmQgPSBjc3MuaW5kZXhPZignKi8nLCBzdGFydClcblxuICAgIGlmIChzdGFydCA+IC0xICYmIGVuZCA+IC0xKSB7XG4gICAgICAvLyBMb2NhdGUgdGhlIGxhc3Qgc291cmNlTWFwcGluZ1VSTCB0byBhdm9pZCBwaWNraW5cbiAgICAgIHRoaXMuYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvblVSTChjc3Muc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKVxuICAgIH1cbiAgfVxuXG4gIGxvYWRGaWxlKHBhdGgpIHtcbiAgICB0aGlzLnJvb3QgPSBkaXJuYW1lKHBhdGgpXG4gICAgaWYgKGV4aXN0c1N5bmMocGF0aCkpIHtcbiAgICAgIHRoaXMubWFwRmlsZSA9IHBhdGhcbiAgICAgIHJldHVybiByZWFkRmlsZVN5bmMocGF0aCwgJ3V0Zi04JykudG9TdHJpbmcoKS50cmltKClcbiAgICB9XG4gIH1cblxuICBsb2FkTWFwKGZpbGUsIHByZXYpIHtcbiAgICBpZiAocHJldiA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgaWYgKHByZXYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJldiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHByZXZcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByZXYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbGV0IHByZXZQYXRoID0gcHJldihmaWxlKVxuICAgICAgICBpZiAocHJldlBhdGgpIHtcbiAgICAgICAgICBsZXQgbWFwID0gdGhpcy5sb2FkRmlsZShwcmV2UGF0aClcbiAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnVW5hYmxlIHRvIGxvYWQgcHJldmlvdXMgc291cmNlIG1hcDogJyArIHByZXZQYXRoLnRvU3RyaW5nKClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hcFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXYgaW5zdGFuY2VvZiBTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAocHJldikudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmIChwcmV2IGluc3RhbmNlb2YgU291cmNlTWFwR2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBwcmV2LnRvU3RyaW5nKClcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc01hcChwcmV2KSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJldilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVW5zdXBwb3J0ZWQgcHJldmlvdXMgc291cmNlIG1hcCBmb3JtYXQ6ICcgKyBwcmV2LnRvU3RyaW5nKClcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZUlubGluZSh0aGlzLmFubm90YXRpb24pXG4gICAgfSBlbHNlIGlmICh0aGlzLmFubm90YXRpb24pIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFubm90YXRpb25cbiAgICAgIGlmIChmaWxlKSBtYXAgPSBqb2luKGRpcm5hbWUoZmlsZSksIG1hcClcbiAgICAgIHJldHVybiB0aGlzLmxvYWRGaWxlKG1hcClcbiAgICB9XG4gIH1cblxuICBzdGFydFdpdGgoc3RyaW5nLCBzdGFydCkge1xuICAgIGlmICghc3RyaW5nKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzdGFydC5sZW5ndGgpID09PSBzdGFydFxuICB9XG5cbiAgd2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgdGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50ICYmXG4gICAgICB0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQubGVuZ3RoID4gMFxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXZpb3VzTWFwXG5QcmV2aW91c01hcC5kZWZhdWx0ID0gUHJldmlvdXNNYXBcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50JylcbmxldCBMYXp5UmVzdWx0ID0gcmVxdWlyZSgnLi9sYXp5LXJlc3VsdCcpXG5sZXQgTm9Xb3JrUmVzdWx0ID0gcmVxdWlyZSgnLi9uby13b3JrLXJlc3VsdCcpXG5sZXQgUm9vdCA9IHJlcXVpcmUoJy4vcm9vdCcpXG5cbmNsYXNzIFByb2Nlc3NvciB7XG4gIGNvbnN0cnVjdG9yKHBsdWdpbnMgPSBbXSkge1xuICAgIHRoaXMudmVyc2lvbiA9ICc4LjQuNDUnXG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5ub3JtYWxpemUocGx1Z2lucylcbiAgfVxuXG4gIG5vcm1hbGl6ZShwbHVnaW5zKSB7XG4gICAgbGV0IG5vcm1hbGl6ZWQgPSBbXVxuICAgIGZvciAobGV0IGkgb2YgcGx1Z2lucykge1xuICAgICAgaWYgKGkucG9zdGNzcyA9PT0gdHJ1ZSkge1xuICAgICAgICBpID0gaSgpXG4gICAgICB9IGVsc2UgaWYgKGkucG9zdGNzcykge1xuICAgICAgICBpID0gaS5wb3N0Y3NzXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheShpLnBsdWdpbnMpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLmNvbmNhdChpLnBsdWdpbnMpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpID09PSAnb2JqZWN0JyAmJiBpLnBvc3Rjc3NQbHVnaW4pIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQucHVzaChpKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaSA9PT0gJ29iamVjdCcgJiYgKGkucGFyc2UgfHwgaS5zdHJpbmdpZnkpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1Bvc3RDU1Mgc3ludGF4ZXMgY2Fubm90IGJlIHVzZWQgYXMgcGx1Z2lucy4gSW5zdGVhZCwgcGxlYXNlIHVzZSAnICtcbiAgICAgICAgICAgICAgJ29uZSBvZiB0aGUgc3ludGF4L3BhcnNlci9zdHJpbmdpZmllciBvcHRpb25zIGFzIG91dGxpbmVkICcgK1xuICAgICAgICAgICAgICAnaW4geW91ciBQb3N0Q1NTIHJ1bm5lciBkb2N1bWVudGF0aW9uLidcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihpICsgJyBpcyBub3QgYSBQb3N0Q1NTIHBsdWdpbicpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkXG4gIH1cblxuICBwcm9jZXNzKGNzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMucGx1Z2lucy5sZW5ndGggJiZcbiAgICAgICFvcHRzLnBhcnNlciAmJlxuICAgICAgIW9wdHMuc3RyaW5naWZpZXIgJiZcbiAgICAgICFvcHRzLnN5bnRheFxuICAgICkge1xuICAgICAgcmV0dXJuIG5ldyBOb1dvcmtSZXN1bHQodGhpcywgY3NzLCBvcHRzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IExhenlSZXN1bHQodGhpcywgY3NzLCBvcHRzKVxuICAgIH1cbiAgfVxuXG4gIHVzZShwbHVnaW4pIHtcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuY29uY2F0KHRoaXMubm9ybWFsaXplKFtwbHVnaW5dKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc29yXG5Qcm9jZXNzb3IuZGVmYXVsdCA9IFByb2Nlc3NvclxuXG5Sb290LnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvcilcbkRvY3VtZW50LnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvcilcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgV2FybmluZyA9IHJlcXVpcmUoJy4vd2FybmluZycpXG5cbmNsYXNzIFJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yKHByb2Nlc3Nvciwgcm9vdCwgb3B0cykge1xuICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yXG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdXG4gICAgdGhpcy5yb290ID0gcm9vdFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLmNzcyA9IHVuZGVmaW5lZFxuICAgIHRoaXMubWFwID0gdW5kZWZpbmVkXG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NcbiAgfVxuXG4gIHdhcm4odGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCFvcHRzLnBsdWdpbikge1xuICAgICAgaWYgKHRoaXMubGFzdFBsdWdpbiAmJiB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbikge1xuICAgICAgICBvcHRzLnBsdWdpbiA9IHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHdhcm5pbmcgPSBuZXcgV2FybmluZyh0ZXh0LCBvcHRzKVxuICAgIHRoaXMubWVzc2FnZXMucHVzaCh3YXJuaW5nKVxuXG4gICAgcmV0dXJuIHdhcm5pbmdcbiAgfVxuXG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmZpbHRlcihpID0+IGkudHlwZSA9PT0gJ3dhcm5pbmcnKVxuICB9XG5cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXN1bHRcblJlc3VsdC5kZWZhdWx0ID0gUmVzdWx0XG4iLCIndXNlIHN0cmljdCdcblxubGV0IENvbnRhaW5lciA9IHJlcXVpcmUoJy4vY29udGFpbmVyJylcblxubGV0IExhenlSZXN1bHQsIFByb2Nlc3NvclxuXG5jbGFzcyBSb290IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAncm9vdCdcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICB9XG5cbiAgbm9ybWFsaXplKGNoaWxkLCBzYW1wbGUsIHR5cGUpIHtcbiAgICBsZXQgbm9kZXMgPSBzdXBlci5ub3JtYWxpemUoY2hpbGQpXG5cbiAgICBpZiAoc2FtcGxlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3ByZXBlbmQnKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzYW1wbGUucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHNhbXBsZS5yYXdzLmJlZm9yZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3QgIT09IHNhbXBsZSkge1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgbm9kZS5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cblxuICByZW1vdmVDaGlsZChjaGlsZCwgaWdub3JlKSB7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleChjaGlsZClcblxuICAgIGlmICghaWdub3JlICYmIGluZGV4ID09PSAwICYmIHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbaW5kZXhdLnJhd3MuYmVmb3JlXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnJlbW92ZUNoaWxkKGNoaWxkKVxuICB9XG5cbiAgdG9SZXN1bHQob3B0cyA9IHt9KSB7XG4gICAgbGV0IGxhenkgPSBuZXcgTGF6eVJlc3VsdChuZXcgUHJvY2Vzc29yKCksIHRoaXMsIG9wdHMpXG4gICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KClcbiAgfVxufVxuXG5Sb290LnJlZ2lzdGVyTGF6eVJlc3VsdCA9IGRlcGVuZGFudCA9PiB7XG4gIExhenlSZXN1bHQgPSBkZXBlbmRhbnRcbn1cblxuUm9vdC5yZWdpc3RlclByb2Nlc3NvciA9IGRlcGVuZGFudCA9PiB7XG4gIFByb2Nlc3NvciA9IGRlcGVuZGFudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvb3RcblJvb3QuZGVmYXVsdCA9IFJvb3RcblxuQ29udGFpbmVyLnJlZ2lzdGVyUm9vdChSb290KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBDb250YWluZXIgPSByZXF1aXJlKCcuL2NvbnRhaW5lcicpXG5sZXQgbGlzdCA9IHJlcXVpcmUoJy4vbGlzdCcpXG5cbmNsYXNzIFJ1bGUgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKVxuICAgIHRoaXMudHlwZSA9ICdydWxlJ1xuICAgIGlmICghdGhpcy5ub2RlcykgdGhpcy5ub2RlcyA9IFtdXG4gIH1cblxuICBnZXQgc2VsZWN0b3JzKCkge1xuICAgIHJldHVybiBsaXN0LmNvbW1hKHRoaXMuc2VsZWN0b3IpXG4gIH1cblxuICBzZXQgc2VsZWN0b3JzKHZhbHVlcykge1xuICAgIGxldCBtYXRjaCA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yLm1hdGNoKC8sXFxzKi8pIDogbnVsbFxuICAgIGxldCBzZXAgPSBtYXRjaCA/IG1hdGNoWzBdIDogJywnICsgdGhpcy5yYXcoJ2JldHdlZW4nLCAnYmVmb3JlT3BlbicpXG4gICAgdGhpcy5zZWxlY3RvciA9IHZhbHVlcy5qb2luKHNlcClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bGVcblJ1bGUuZGVmYXVsdCA9IFJ1bGVcblxuQ29udGFpbmVyLnJlZ2lzdGVyUnVsZShSdWxlKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERFRkFVTFRfUkFXID0ge1xuICBhZnRlcjogJ1xcbicsXG4gIGJlZm9yZUNsb3NlOiAnXFxuJyxcbiAgYmVmb3JlQ29tbWVudDogJ1xcbicsXG4gIGJlZm9yZURlY2w6ICdcXG4nLFxuICBiZWZvcmVPcGVuOiAnICcsXG4gIGJlZm9yZVJ1bGU6ICdcXG4nLFxuICBjb2xvbjogJzogJyxcbiAgY29tbWVudExlZnQ6ICcgJyxcbiAgY29tbWVudFJpZ2h0OiAnICcsXG4gIGVtcHR5Qm9keTogJycsXG4gIGluZGVudDogJyAgICAnLFxuICBzZW1pY29sb246IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufVxuXG5jbGFzcyBTdHJpbmdpZmllciB7XG4gIGNvbnN0cnVjdG9yKGJ1aWxkZXIpIHtcbiAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyXG4gIH1cblxuICBhdHJ1bGUobm9kZSwgc2VtaWNvbG9uKSB7XG4gICAgbGV0IG5hbWUgPSAnQCcgKyBub2RlLm5hbWVcbiAgICBsZXQgcGFyYW1zID0gbm9kZS5wYXJhbXMgPyB0aGlzLnJhd1ZhbHVlKG5vZGUsICdwYXJhbXMnKSA6ICcnXG5cbiAgICBpZiAodHlwZW9mIG5vZGUucmF3cy5hZnRlck5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBuYW1lICs9IG5vZGUucmF3cy5hZnRlck5hbWVcbiAgICB9IGVsc2UgaWYgKHBhcmFtcykge1xuICAgICAgbmFtZSArPSAnICdcbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2Rlcykge1xuICAgICAgdGhpcy5ibG9jayhub2RlLCBuYW1lICsgcGFyYW1zKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZW5kID0gKG5vZGUucmF3cy5iZXR3ZWVuIHx8ICcnKSArIChzZW1pY29sb24gPyAnOycgOiAnJylcbiAgICAgIHRoaXMuYnVpbGRlcihuYW1lICsgcGFyYW1zICsgZW5kLCBub2RlKVxuICAgIH1cbiAgfVxuXG4gIGJlZm9yZUFmdGVyKG5vZGUsIGRldGVjdCkge1xuICAgIGxldCB2YWx1ZVxuICAgIGlmIChub2RlLnR5cGUgPT09ICdkZWNsJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlLCBudWxsLCAnYmVmb3JlRGVjbCcpXG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdjb21tZW50Jykge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlLCBudWxsLCAnYmVmb3JlQ29tbWVudCcpXG4gICAgfSBlbHNlIGlmIChkZXRlY3QgPT09ICdiZWZvcmUnKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUsIG51bGwsICdiZWZvcmVSdWxlJylcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlLCBudWxsLCAnYmVmb3JlQ2xvc2UnKVxuICAgIH1cblxuICAgIGxldCBidWYgPSBub2RlLnBhcmVudFxuICAgIGxldCBkZXB0aCA9IDBcbiAgICB3aGlsZSAoYnVmICYmIGJ1Zi50eXBlICE9PSAncm9vdCcpIHtcbiAgICAgIGRlcHRoICs9IDFcbiAgICAgIGJ1ZiA9IGJ1Zi5wYXJlbnRcbiAgICB9XG5cbiAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICBsZXQgaW5kZW50ID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2luZGVudCcpXG4gICAgICBpZiAoaW5kZW50Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBzdGVwID0gMDsgc3RlcCA8IGRlcHRoOyBzdGVwKyspIHZhbHVlICs9IGluZGVudFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgYmxvY2sobm9kZSwgc3RhcnQpIHtcbiAgICBsZXQgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUsICdiZXR3ZWVuJywgJ2JlZm9yZU9wZW4nKVxuICAgIHRoaXMuYnVpbGRlcihzdGFydCArIGJldHdlZW4gKyAneycsIG5vZGUsICdzdGFydCcpXG5cbiAgICBsZXQgYWZ0ZXJcbiAgICBpZiAobm9kZS5ub2RlcyAmJiBub2RlLm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5ib2R5KG5vZGUpXG4gICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUsICdhZnRlcicpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZSwgJ2FmdGVyJywgJ2VtcHR5Qm9keScpXG4gICAgfVxuXG4gICAgaWYgKGFmdGVyKSB0aGlzLmJ1aWxkZXIoYWZ0ZXIpXG4gICAgdGhpcy5idWlsZGVyKCd9Jywgbm9kZSwgJ2VuZCcpXG4gIH1cblxuICBib2R5KG5vZGUpIHtcbiAgICBsZXQgbGFzdCA9IG5vZGUubm9kZXMubGVuZ3RoIC0gMVxuICAgIHdoaWxlIChsYXN0ID4gMCkge1xuICAgICAgaWYgKG5vZGUubm9kZXNbbGFzdF0udHlwZSAhPT0gJ2NvbW1lbnQnKSBicmVha1xuICAgICAgbGFzdCAtPSAxXG4gICAgfVxuXG4gICAgbGV0IHNlbWljb2xvbiA9IHRoaXMucmF3KG5vZGUsICdzZW1pY29sb24nKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNoaWxkID0gbm9kZS5ub2Rlc1tpXVxuICAgICAgbGV0IGJlZm9yZSA9IHRoaXMucmF3KGNoaWxkLCAnYmVmb3JlJylcbiAgICAgIGlmIChiZWZvcmUpIHRoaXMuYnVpbGRlcihiZWZvcmUpXG4gICAgICB0aGlzLnN0cmluZ2lmeShjaGlsZCwgbGFzdCAhPT0gaSB8fCBzZW1pY29sb24pXG4gICAgfVxuICB9XG5cbiAgY29tbWVudChub2RlKSB7XG4gICAgbGV0IGxlZnQgPSB0aGlzLnJhdyhub2RlLCAnbGVmdCcsICdjb21tZW50TGVmdCcpXG4gICAgbGV0IHJpZ2h0ID0gdGhpcy5yYXcobm9kZSwgJ3JpZ2h0JywgJ2NvbW1lbnRSaWdodCcpXG4gICAgdGhpcy5idWlsZGVyKCcvKicgKyBsZWZ0ICsgbm9kZS50ZXh0ICsgcmlnaHQgKyAnKi8nLCBub2RlKVxuICB9XG5cbiAgZGVjbChub2RlLCBzZW1pY29sb24pIHtcbiAgICBsZXQgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUsICdiZXR3ZWVuJywgJ2NvbG9uJylcbiAgICBsZXQgc3RyaW5nID0gbm9kZS5wcm9wICsgYmV0d2VlbiArIHRoaXMucmF3VmFsdWUobm9kZSwgJ3ZhbHVlJylcblxuICAgIGlmIChub2RlLmltcG9ydGFudCkge1xuICAgICAgc3RyaW5nICs9IG5vZGUucmF3cy5pbXBvcnRhbnQgfHwgJyAhaW1wb3J0YW50J1xuICAgIH1cblxuICAgIGlmIChzZW1pY29sb24pIHN0cmluZyArPSAnOydcbiAgICB0aGlzLmJ1aWxkZXIoc3RyaW5nLCBub2RlKVxuICB9XG5cbiAgZG9jdW1lbnQobm9kZSkge1xuICAgIHRoaXMuYm9keShub2RlKVxuICB9XG5cbiAgcmF3KG5vZGUsIG93biwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgaWYgKCFkZXRlY3QpIGRldGVjdCA9IG93blxuXG4gICAgLy8gQWxyZWFkeSBoYWRcbiAgICBpZiAob3duKSB7XG4gICAgICB2YWx1ZSA9IG5vZGUucmF3c1tvd25dXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50XG5cbiAgICBpZiAoZGV0ZWN0ID09PSAnYmVmb3JlJykge1xuICAgICAgLy8gSGFjayBmb3IgZmlyc3QgcnVsZSBpbiBDU1NcbiAgICAgIGlmICghcGFyZW50IHx8IChwYXJlbnQudHlwZSA9PT0gJ3Jvb3QnICYmIHBhcmVudC5maXJzdCA9PT0gbm9kZSkpIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG5cbiAgICAgIC8vIGByb290YCBub2RlcyBpbiBgZG9jdW1lbnRgIHNob3VsZCB1c2Ugb25seSB0aGVpciBvd24gcmF3c1xuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGbG9hdGluZyBjaGlsZCB3aXRob3V0IHBhcmVudFxuICAgIGlmICghcGFyZW50KSByZXR1cm4gREVGQVVMVF9SQVdbZGV0ZWN0XVxuXG4gICAgLy8gRGV0ZWN0IHN0eWxlIGJ5IG90aGVyIG5vZGVzXG4gICAgbGV0IHJvb3QgPSBub2RlLnJvb3QoKVxuICAgIGlmICghcm9vdC5yYXdDYWNoZSkgcm9vdC5yYXdDYWNoZSA9IHt9XG4gICAgaWYgKHR5cGVvZiByb290LnJhd0NhY2hlW2RldGVjdF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gcm9vdC5yYXdDYWNoZVtkZXRlY3RdXG4gICAgfVxuXG4gICAgaWYgKGRldGVjdCA9PT0gJ2JlZm9yZScgfHwgZGV0ZWN0ID09PSAnYWZ0ZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlLCBkZXRlY3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtZXRob2QgPSAncmF3JyArIGNhcGl0YWxpemUoZGV0ZWN0KVxuICAgICAgaWYgKHRoaXNbbWV0aG9kXSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXNbbWV0aG9kXShyb290LCBub2RlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgICAgIHZhbHVlID0gaS5yYXdzW293bl1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHZhbHVlID0gREVGQVVMVF9SQVdbZGV0ZWN0XVxuXG4gICAgcm9vdC5yYXdDYWNoZVtkZXRlY3RdID0gdmFsdWVcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0JlZm9yZUNsb3NlKHJvb3QpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGsoaSA9PiB7XG4gICAgICBpZiAoaS5ub2RlcyAmJiBpLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpLnJhd3MuYWZ0ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFsdWUgPSBpLnJhd3MuYWZ0ZXJcbiAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgJycpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csICcnKVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3QmVmb3JlQ29tbWVudChyb290LCBub2RlKSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrQ29tbWVudHMoaSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkucmF3cy5iZWZvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlID0gaS5yYXdzLmJlZm9yZVxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sICcnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2JlZm9yZURlY2wnKVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csICcnKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0JlZm9yZURlY2wocm9vdCwgbm9kZSkge1xuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2Fsa0RlY2xzKGkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpLnJhd3MuYmVmb3JlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWx1ZSA9IGkucmF3cy5iZWZvcmVcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCAnJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUsIG51bGwsICdiZWZvcmVSdWxlJylcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCAnJylcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdCZWZvcmVPcGVuKHJvb3QpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGsoaSA9PiB7XG4gICAgICBpZiAoaS50eXBlICE9PSAnZGVjbCcpIHtcbiAgICAgICAgdmFsdWUgPSBpLnJhd3MuYmV0d2VlblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0JlZm9yZVJ1bGUocm9vdCkge1xuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2FsayhpID0+IHtcbiAgICAgIGlmIChpLm5vZGVzICYmIChpLnBhcmVudCAhPT0gcm9vdCB8fCByb290LmZpcnN0ICE9PSBpKSkge1xuICAgICAgICBpZiAodHlwZW9mIGkucmF3cy5iZWZvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFsdWUgPSBpLnJhd3MuYmVmb3JlXG4gICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sICcnKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCAnJylcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0NvbG9uKHJvb3QpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGtEZWNscyhpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJldHdlZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlID0gaS5yYXdzLmJldHdlZW4ucmVwbGFjZSgvW15cXHM6XS9nLCAnJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0VtcHR5Qm9keShyb290KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgaWYgKGkubm9kZXMgJiYgaS5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBpLnJhd3MuYWZ0ZXJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdJbmRlbnQocm9vdCkge1xuICAgIGlmIChyb290LnJhd3MuaW5kZW50KSByZXR1cm4gcm9vdC5yYXdzLmluZGVudFxuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2FsayhpID0+IHtcbiAgICAgIGxldCBwID0gaS5wYXJlbnRcbiAgICAgIGlmIChwICYmIHAgIT09IHJvb3QgJiYgcC5wYXJlbnQgJiYgcC5wYXJlbnQgPT09IHJvb3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpLnJhd3MuYmVmb3JlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxldCBwYXJ0cyA9IGkucmF3cy5iZWZvcmUuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgdmFsdWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csICcnKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd1NlbWljb2xvbihyb290KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgaWYgKGkubm9kZXMgJiYgaS5ub2Rlcy5sZW5ndGggJiYgaS5sYXN0LnR5cGUgPT09ICdkZWNsJykge1xuICAgICAgICB2YWx1ZSA9IGkucmF3cy5zZW1pY29sb25cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdWYWx1ZShub2RlLCBwcm9wKSB7XG4gICAgbGV0IHZhbHVlID0gbm9kZVtwcm9wXVxuICAgIGxldCByYXcgPSBub2RlLnJhd3NbcHJvcF1cbiAgICBpZiAocmF3ICYmIHJhdy52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiByYXcucmF3XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByb290KG5vZGUpIHtcbiAgICB0aGlzLmJvZHkobm9kZSlcbiAgICBpZiAobm9kZS5yYXdzLmFmdGVyKSB0aGlzLmJ1aWxkZXIobm9kZS5yYXdzLmFmdGVyKVxuICB9XG5cbiAgcnVsZShub2RlKSB7XG4gICAgdGhpcy5ibG9jayhub2RlLCB0aGlzLnJhd1ZhbHVlKG5vZGUsICdzZWxlY3RvcicpKVxuICAgIGlmIChub2RlLnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICB0aGlzLmJ1aWxkZXIobm9kZS5yYXdzLm93blNlbWljb2xvbiwgbm9kZSwgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgc3RyaW5naWZ5KG5vZGUsIHNlbWljb2xvbikge1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmICghdGhpc1tub2RlLnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmtub3duIEFTVCBub2RlIHR5cGUgJyArXG4gICAgICAgICAgbm9kZS50eXBlICtcbiAgICAgICAgICAnLiAnICtcbiAgICAgICAgICAnTWF5YmUgeW91IG5lZWQgdG8gY2hhbmdlIFBvc3RDU1Mgc3RyaW5naWZpZXIuJ1xuICAgICAgKVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIHRoaXNbbm9kZS50eXBlXShub2RlLCBzZW1pY29sb24pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdpZmllclxuU3RyaW5naWZpZXIuZGVmYXVsdCA9IFN0cmluZ2lmaWVyXG4iLCIndXNlIHN0cmljdCdcblxubGV0IFN0cmluZ2lmaWVyID0gcmVxdWlyZSgnLi9zdHJpbmdpZmllcicpXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShub2RlLCBidWlsZGVyKSB7XG4gIGxldCBzdHIgPSBuZXcgU3RyaW5naWZpZXIoYnVpbGRlcilcbiAgc3RyLnN0cmluZ2lmeShub2RlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeVxuc3RyaW5naWZ5LmRlZmF1bHQgPSBzdHJpbmdpZnlcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cy5pc0NsZWFuID0gU3ltYm9sKCdpc0NsZWFuJylcblxubW9kdWxlLmV4cG9ydHMubXkgPSBTeW1ib2woJ215JylcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTSU5HTEVfUVVPVEUgPSBcIidcIi5jaGFyQ29kZUF0KDApXG5jb25zdCBET1VCTEVfUVVPVEUgPSAnXCInLmNoYXJDb2RlQXQoMClcbmNvbnN0IEJBQ0tTTEFTSCA9ICdcXFxcJy5jaGFyQ29kZUF0KDApXG5jb25zdCBTTEFTSCA9ICcvJy5jaGFyQ29kZUF0KDApXG5jb25zdCBORVdMSU5FID0gJ1xcbicuY2hhckNvZGVBdCgwKVxuY29uc3QgU1BBQ0UgPSAnICcuY2hhckNvZGVBdCgwKVxuY29uc3QgRkVFRCA9ICdcXGYnLmNoYXJDb2RlQXQoMClcbmNvbnN0IFRBQiA9ICdcXHQnLmNoYXJDb2RlQXQoMClcbmNvbnN0IENSID0gJ1xccicuY2hhckNvZGVBdCgwKVxuY29uc3QgT1BFTl9TUVVBUkUgPSAnWycuY2hhckNvZGVBdCgwKVxuY29uc3QgQ0xPU0VfU1FVQVJFID0gJ10nLmNoYXJDb2RlQXQoMClcbmNvbnN0IE9QRU5fUEFSRU5USEVTRVMgPSAnKCcuY2hhckNvZGVBdCgwKVxuY29uc3QgQ0xPU0VfUEFSRU5USEVTRVMgPSAnKScuY2hhckNvZGVBdCgwKVxuY29uc3QgT1BFTl9DVVJMWSA9ICd7Jy5jaGFyQ29kZUF0KDApXG5jb25zdCBDTE9TRV9DVVJMWSA9ICd9Jy5jaGFyQ29kZUF0KDApXG5jb25zdCBTRU1JQ09MT04gPSAnOycuY2hhckNvZGVBdCgwKVxuY29uc3QgQVNURVJJU0sgPSAnKicuY2hhckNvZGVBdCgwKVxuY29uc3QgQ09MT04gPSAnOicuY2hhckNvZGVBdCgwKVxuY29uc3QgQVQgPSAnQCcuY2hhckNvZGVBdCgwKVxuXG5jb25zdCBSRV9BVF9FTkQgPSAvW1xcdFxcblxcZlxcciBcIiMnKCkvO1tcXFxcXFxde31dL2dcbmNvbnN0IFJFX1dPUkRfRU5EID0gL1tcXHRcXG5cXGZcXHIgIVwiIycoKTo7QFtcXFxcXFxde31dfFxcLyg/PVxcKikvZ1xuY29uc3QgUkVfQkFEX0JSQUNLRVQgPSAvLltcXHJcXG5cIicoL1xcXFxdL1xuY29uc3QgUkVfSEVYX0VTQ0FQRSA9IC9bXFxkYS1mXS9pXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGNzcyA9IGlucHV0LmNzcy52YWx1ZU9mKClcbiAgbGV0IGlnbm9yZSA9IG9wdGlvbnMuaWdub3JlRXJyb3JzXG5cbiAgbGV0IGNvZGUsIGNvbnRlbnQsIGVzY2FwZSwgbmV4dCwgcXVvdGVcbiAgbGV0IGN1cnJlbnRUb2tlbiwgZXNjYXBlZCwgZXNjYXBlUG9zLCBuLCBwcmV2XG5cbiAgbGV0IGxlbmd0aCA9IGNzcy5sZW5ndGhcbiAgbGV0IHBvcyA9IDBcbiAgbGV0IGJ1ZmZlciA9IFtdXG4gIGxldCByZXR1cm5lZCA9IFtdXG5cbiAgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgZnVuY3Rpb24gdW5jbG9zZWQod2hhdCkge1xuICAgIHRocm93IGlucHV0LmVycm9yKCdVbmNsb3NlZCAnICsgd2hhdCwgcG9zKVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kT2ZGaWxlKCkge1xuICAgIHJldHVybiByZXR1cm5lZC5sZW5ndGggPT09IDAgJiYgcG9zID49IGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gbmV4dFRva2VuKG9wdHMpIHtcbiAgICBpZiAocmV0dXJuZWQubGVuZ3RoKSByZXR1cm4gcmV0dXJuZWQucG9wKClcbiAgICBpZiAocG9zID49IGxlbmd0aCkgcmV0dXJuXG5cbiAgICBsZXQgaWdub3JlVW5jbG9zZWQgPSBvcHRzID8gb3B0cy5pZ25vcmVVbmNsb3NlZCA6IGZhbHNlXG5cbiAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQocG9zKVxuXG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIE5FV0xJTkU6XG4gICAgICBjYXNlIFNQQUNFOlxuICAgICAgY2FzZSBUQUI6XG4gICAgICBjYXNlIENSOlxuICAgICAgY2FzZSBGRUVEOiB7XG4gICAgICAgIG5leHQgPSBwb3NcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5leHQgKz0gMVxuICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KVxuICAgICAgICB9IHdoaWxlIChcbiAgICAgICAgICBjb2RlID09PSBTUEFDRSB8fFxuICAgICAgICAgIGNvZGUgPT09IE5FV0xJTkUgfHxcbiAgICAgICAgICBjb2RlID09PSBUQUIgfHxcbiAgICAgICAgICBjb2RlID09PSBDUiB8fFxuICAgICAgICAgIGNvZGUgPT09IEZFRURcbiAgICAgICAgKVxuXG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnc3BhY2UnLCBjc3Muc2xpY2UocG9zLCBuZXh0KV1cbiAgICAgICAgcG9zID0gbmV4dCAtIDFcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSBPUEVOX1NRVUFSRTpcbiAgICAgIGNhc2UgQ0xPU0VfU1FVQVJFOlxuICAgICAgY2FzZSBPUEVOX0NVUkxZOlxuICAgICAgY2FzZSBDTE9TRV9DVVJMWTpcbiAgICAgIGNhc2UgQ09MT046XG4gICAgICBjYXNlIFNFTUlDT0xPTjpcbiAgICAgIGNhc2UgQ0xPU0VfUEFSRU5USEVTRVM6IHtcbiAgICAgICAgbGV0IGNvbnRyb2xDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbY29udHJvbENoYXIsIGNvbnRyb2xDaGFyLCBwb3NdXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgT1BFTl9QQVJFTlRIRVNFUzoge1xuICAgICAgICBwcmV2ID0gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5wb3AoKVsxXSA6ICcnXG4gICAgICAgIG4gPSBjc3MuY2hhckNvZGVBdChwb3MgKyAxKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJldiA9PT0gJ3VybCcgJiZcbiAgICAgICAgICBuICE9PSBTSU5HTEVfUVVPVEUgJiZcbiAgICAgICAgICBuICE9PSBET1VCTEVfUVVPVEUgJiZcbiAgICAgICAgICBuICE9PSBTUEFDRSAmJlxuICAgICAgICAgIG4gIT09IE5FV0xJTkUgJiZcbiAgICAgICAgICBuICE9PSBUQUIgJiZcbiAgICAgICAgICBuICE9PSBGRUVEICYmXG4gICAgICAgICAgbiAhPT0gQ1JcbiAgICAgICAgKSB7XG4gICAgICAgICAgbmV4dCA9IHBvc1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZVxuICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKCcpJywgbmV4dCArIDEpXG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBwb3NcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuY2xvc2VkKCdicmFja2V0JylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dFxuICAgICAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gpIHtcbiAgICAgICAgICAgICAgZXNjYXBlUG9zIC09IDFcbiAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoZXNjYXBlZClcblxuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnYnJhY2tldHMnLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF1cblxuICAgICAgICAgIHBvcyA9IG5leHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoJyknLCBwb3MgKyAxKVxuICAgICAgICAgIGNvbnRlbnQgPSBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSlcblxuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSB8fCBSRV9CQURfQlJBQ0tFVC50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbJygnLCAnKCcsIHBvc11cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFRva2VuID0gWydicmFja2V0cycsIGNvbnRlbnQsIHBvcywgbmV4dF1cbiAgICAgICAgICAgIHBvcyA9IG5leHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlIFNJTkdMRV9RVU9URTpcbiAgICAgIGNhc2UgRE9VQkxFX1FVT1RFOiB7XG4gICAgICAgIHF1b3RlID0gY29kZSA9PT0gU0lOR0xFX1FVT1RFID8gXCInXCIgOiAnXCInXG4gICAgICAgIG5leHQgPSBwb3NcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZVxuICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihxdW90ZSwgbmV4dCArIDEpXG4gICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIG5leHQgPSBwb3MgKyAxXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmNsb3NlZCgnc3RyaW5nJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dFxuICAgICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMVxuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkXG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChlc2NhcGVkKVxuXG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnc3RyaW5nJywgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdXG4gICAgICAgIHBvcyA9IG5leHRcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSBBVDoge1xuICAgICAgICBSRV9BVF9FTkQubGFzdEluZGV4ID0gcG9zICsgMVxuICAgICAgICBSRV9BVF9FTkQudGVzdChjc3MpXG4gICAgICAgIGlmIChSRV9BVF9FTkQubGFzdEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IFJFX0FUX0VORC5sYXN0SW5kZXggLSAyXG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ2F0LXdvcmQnLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF1cblxuICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgQkFDS1NMQVNIOiB7XG4gICAgICAgIG5leHQgPSBwb3NcbiAgICAgICAgZXNjYXBlID0gdHJ1ZVxuICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBCQUNLU0xBU0gpIHtcbiAgICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgICBlc2NhcGUgPSAhZXNjYXBlXG4gICAgICAgIH1cbiAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZXNjYXBlICYmXG4gICAgICAgICAgY29kZSAhPT0gU0xBU0ggJiZcbiAgICAgICAgICBjb2RlICE9PSBTUEFDRSAmJlxuICAgICAgICAgIGNvZGUgIT09IE5FV0xJTkUgJiZcbiAgICAgICAgICBjb2RlICE9PSBUQUIgJiZcbiAgICAgICAgICBjb2RlICE9PSBDUiAmJlxuICAgICAgICAgIGNvZGUgIT09IEZFRURcbiAgICAgICAgKSB7XG4gICAgICAgICAgbmV4dCArPSAxXG4gICAgICAgICAgaWYgKFJFX0hFWF9FU0NBUEUudGVzdChjc3MuY2hhckF0KG5leHQpKSkge1xuICAgICAgICAgICAgd2hpbGUgKFJFX0hFWF9FU0NBUEUudGVzdChjc3MuY2hhckF0KG5leHQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgbmV4dCArPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBTUEFDRSkge1xuICAgICAgICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ3dvcmQnLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF1cblxuICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKGNvZGUgPT09IFNMQVNIICYmIGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpID09PSBBU1RFUklTSykge1xuICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZignKi8nLCBwb3MgKyAyKSArIDFcbiAgICAgICAgICBpZiAobmV4dCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5jbG9zZWQoJ2NvbW1lbnQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnY29tbWVudCcsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XVxuICAgICAgICAgIHBvcyA9IG5leHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSRV9XT1JEX0VORC5sYXN0SW5kZXggPSBwb3MgKyAxXG4gICAgICAgICAgUkVfV09SRF9FTkQudGVzdChjc3MpXG4gICAgICAgICAgaWYgKFJFX1dPUkRfRU5ELmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQgPSBSRV9XT1JEX0VORC5sYXN0SW5kZXggLSAyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFRva2VuID0gWyd3b3JkJywgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdXG4gICAgICAgICAgYnVmZmVyLnB1c2goY3VycmVudFRva2VuKVxuICAgICAgICAgIHBvcyA9IG5leHRcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9zKytcbiAgICByZXR1cm4gY3VycmVudFRva2VuXG4gIH1cblxuICBmdW5jdGlvbiBiYWNrKHRva2VuKSB7XG4gICAgcmV0dXJuZWQucHVzaCh0b2tlbilcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFjayxcbiAgICBlbmRPZkZpbGUsXG4gICAgbmV4dFRva2VuLFxuICAgIHBvc2l0aW9uXG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbid1c2Ugc3RyaWN0J1xuXG5sZXQgcHJpbnRlZCA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICBpZiAocHJpbnRlZFttZXNzYWdlXSkgcmV0dXJuXG4gIHByaW50ZWRbbWVzc2FnZV0gPSB0cnVlXG5cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIFdhcm5pbmcge1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICB0aGlzLnR5cGUgPSAnd2FybmluZydcbiAgICB0aGlzLnRleHQgPSB0ZXh0XG5cbiAgICBpZiAob3B0cy5ub2RlICYmIG9wdHMubm9kZS5zb3VyY2UpIHtcbiAgICAgIGxldCByYW5nZSA9IG9wdHMubm9kZS5yYW5nZUJ5KG9wdHMpXG4gICAgICB0aGlzLmxpbmUgPSByYW5nZS5zdGFydC5saW5lXG4gICAgICB0aGlzLmNvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtblxuICAgICAgdGhpcy5lbmRMaW5lID0gcmFuZ2UuZW5kLmxpbmVcbiAgICAgIHRoaXMuZW5kQ29sdW1uID0gcmFuZ2UuZW5kLmNvbHVtblxuICAgIH1cblxuICAgIGZvciAobGV0IG9wdCBpbiBvcHRzKSB0aGlzW29wdF0gPSBvcHRzW29wdF1cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuZXJyb3IodGhpcy50ZXh0LCB7XG4gICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICBwbHVnaW46IHRoaXMucGx1Z2luLFxuICAgICAgICB3b3JkOiB0aGlzLndvcmRcbiAgICAgIH0pLm1lc3NhZ2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbHVnaW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbiArICc6ICcgKyB0aGlzLnRleHRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50ZXh0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXYXJuaW5nXG5XYXJuaW5nLmRlZmF1bHQgPSBXYXJuaW5nXG4iLCJjb25zdCBodG1scGFyc2VyID0gcmVxdWlyZSgnaHRtbHBhcnNlcjInKTtcbmNvbnN0IGVzY2FwZVN0cmluZ1JlZ2V4cCA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XG5jb25zdCB7IGlzUGxhaW5PYmplY3QgfSA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iamVjdCcpO1xuY29uc3QgZGVlcG1lcmdlID0gcmVxdWlyZSgnZGVlcG1lcmdlJyk7XG5jb25zdCBwYXJzZVNyY3NldCA9IHJlcXVpcmUoJ3BhcnNlLXNyY3NldCcpO1xuY29uc3QgeyBwYXJzZTogcG9zdGNzc1BhcnNlIH0gPSByZXF1aXJlKCdwb3N0Y3NzJyk7XG4vLyBUYWdzIHRoYXQgY2FuIGNvbmNlaXZhYmx5IHJlcHJlc2VudCBzdGFuZC1hbG9uZSBtZWRpYS5cbmNvbnN0IG1lZGlhVGFncyA9IFtcbiAgJ2ltZycsICdhdWRpbycsICd2aWRlbycsICdwaWN0dXJlJywgJ3N2ZycsXG4gICdvYmplY3QnLCAnbWFwJywgJ2lmcmFtZScsICdlbWJlZCdcbl07XG4vLyBUYWdzIHRoYXQgYXJlIGluaGVyZW50bHkgdnVsbmVyYWJsZSB0byBiZWluZyB1c2VkIGluIFhTUyBhdHRhY2tzLlxuY29uc3QgdnVsbmVyYWJsZVRhZ3MgPSBbICdzY3JpcHQnLCAnc3R5bGUnIF07XG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBjYikge1xuICBpZiAob2JqKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGNiKG9ialtrZXldLCBrZXkpO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIEF2b2lkIGZhbHNlIHBvc2l0aXZlcyB3aXRoIC5fX3Byb3RvX18sIC5oYXNPd25Qcm9wZXJ0eSwgZXRjLlxuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiAoe30pLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vLyBSZXR1cm5zIHRob3NlIGVsZW1lbnRzIG9mIGBhYCBmb3Igd2hpY2ggYGNiKGEpYCByZXR1cm5zIHRydXRoeVxuZnVuY3Rpb24gZmlsdGVyKGEsIGNiKSB7XG4gIGNvbnN0IG4gPSBbXTtcbiAgZWFjaChhLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGNiKHYpKSB7XG4gICAgICBuLnB1c2godik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMob2JqLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTcmNzZXQocGFyc2VkU3Jjc2V0KSB7XG4gIHJldHVybiBwYXJzZWRTcmNzZXQubWFwKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICBpZiAoIXBhcnQudXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBtaXNzaW5nJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHBhcnQudXJsICtcbiAgICAgIChwYXJ0LncgPyBgICR7cGFydC53fXdgIDogJycpICtcbiAgICAgIChwYXJ0LmggPyBgICR7cGFydC5ofWhgIDogJycpICtcbiAgICAgIChwYXJ0LmQgPyBgICR7cGFydC5kfXhgIDogJycpXG4gICAgKTtcbiAgfSkuam9pbignLCAnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYW5pdGl6ZUh0bWw7XG5cbi8vIEEgdmFsaWQgYXR0cmlidXRlIG5hbWUuXG4vLyBXZSB1c2UgYSB0b2xlcmFudCBkZWZpbml0aW9uIGJhc2VkIG9uIHRoZSBzZXQgb2Ygc3RyaW5ncyBkZWZpbmVkIGJ5XG4vLyBodG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI2JlZm9yZS1hdHRyaWJ1dGUtbmFtZS1zdGF0ZVxuLy8gYW5kIGh0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjYXR0cmlidXRlLW5hbWUtc3RhdGUgLlxuLy8gVGhlIGNoYXJhY3RlcnMgYWNjZXB0ZWQgYXJlIG9uZXMgd2hpY2ggY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSBhdHRyaWJ1dGVcbi8vIG5hbWUgYnVmZmVyIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHBhcnNlIGVycm9yOlxuLy8gICAqIHVuZXhwZWN0ZWQtZXF1YWxzLXNpZ24tYmVmb3JlLWF0dHJpYnV0ZS1uYW1lXG4vLyAgICogdW5leHBlY3RlZC1udWxsLWNoYXJhY3RlclxuLy8gICAqIHVuZXhwZWN0ZWQtY2hhcmFjdGVyLWluLWF0dHJpYnV0ZS1uYW1lXG4vLyBXZSBleGNsdWRlIHRoZSBlbXB0eSBzdHJpbmcgYmVjYXVzZSBpdCdzIGltcG9zc2libGUgdG8gZ2V0IHRvIHRoZSBhZnRlclxuLy8gYXR0cmlidXRlIG5hbWUgc3RhdGUgd2l0aCBhbiBlbXB0eSBhdHRyaWJ1dGUgbmFtZSBidWZmZXIuXG5jb25zdCBWQUxJRF9IVE1MX0FUVFJJQlVURV9OQU1FID0gL15bXlxcMFxcdFxcblxcZlxcciAvPD0+XSskLztcblxuLy8gSWdub3JlIHRoZSBfcmVjdXJzaW5nIGZsYWc7IGl0J3MgdGhlcmUgZm9yIHJlY3Vyc2l2ZVxuLy8gaW52b2NhdGlvbiBhcyBhIGd1YXJkIGFnYWluc3QgdGhpcyBleHBsb2l0OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZiNTUvaHRtbHBhcnNlcjIvaXNzdWVzLzEwNVxuXG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwoaHRtbCwgb3B0aW9ucywgX3JlY3Vyc2luZykge1xuICBpZiAoaHRtbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh0eXBlb2YgaHRtbCA9PT0gJ251bWJlcicpIHtcbiAgICBodG1sID0gaHRtbC50b1N0cmluZygpO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICAvLyBVc2VkIGZvciBob3Qgc3dhcHBpbmcgdGhlIHJlc3VsdCB2YXJpYWJsZSB3aXRoIGFuIGVtcHR5IHN0cmluZyBpbiBvcmRlciB0byBcImNhcHR1cmVcIiB0aGUgdGV4dCB3cml0dGVuIHRvIGl0LlxuICBsZXQgdGVtcFJlc3VsdCA9ICcnO1xuXG4gIGZ1bmN0aW9uIEZyYW1lKHRhZywgYXR0cmlicykge1xuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMuYXR0cmlicyA9IGF0dHJpYnMgfHwge307XG4gICAgdGhpcy50YWdQb3NpdGlvbiA9IHJlc3VsdC5sZW5ndGg7XG4gICAgdGhpcy50ZXh0ID0gJyc7IC8vIE5vZGUgaW5uZXIgdGV4dFxuICAgIHRoaXMubWVkaWFDaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy51cGRhdGVQYXJlbnROb2RlVGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwYXJlbnRGcmFtZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBwYXJlbnRGcmFtZS50ZXh0ICs9IHRoYXQudGV4dDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVQYXJlbnROb2RlTWVkaWFDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHN0YWNrLmxlbmd0aCAmJiBtZWRpYVRhZ3MuaW5jbHVkZXModGhpcy50YWcpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEZyYW1lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHBhcmVudEZyYW1lLm1lZGlhQ2hpbGRyZW4ucHVzaCh0aGlzLnRhZyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzYW5pdGl6ZUh0bWwuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICBvcHRpb25zLnBhcnNlciA9IE9iamVjdC5hc3NpZ24oe30sIGh0bWxQYXJzZXJEZWZhdWx0cywgb3B0aW9ucy5wYXJzZXIpO1xuXG4gIGNvbnN0IHRhZ0FsbG93ZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBvcHRpb25zLmFsbG93ZWRUYWdzID09PSBmYWxzZSB8fCAob3B0aW9ucy5hbGxvd2VkVGFncyB8fCBbXSkuaW5kZXhPZihuYW1lKSA+IC0xO1xuICB9O1xuXG4gIC8vIHZ1bG5lcmFibGVUYWdzXG4gIHZ1bG5lcmFibGVUYWdzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgIGlmICh0YWdBbGxvd2VkKHRhZykgJiYgIW9wdGlvbnMuYWxsb3dWdWxuZXJhYmxlVGFncykge1xuICAgICAgY29uc29sZS53YXJuKGBcXG5cXG7imqDvuI8gWW91ciBcXGBhbGxvd2VkVGFnc1xcYCBvcHRpb24gaW5jbHVkZXMsIFxcYCR7dGFnfVxcYCwgd2hpY2ggaXMgaW5oZXJlbnRseVxcbnZ1bG5lcmFibGUgdG8gWFNTIGF0dGFja3MuIFBsZWFzZSByZW1vdmUgaXQgZnJvbSBcXGBhbGxvd2VkVGFnc1xcYC5cXG5PciwgdG8gZGlzYWJsZSB0aGlzIHdhcm5pbmcsIGFkZCB0aGUgXFxgYWxsb3dWdWxuZXJhYmxlVGFnc1xcYCBvcHRpb25cXG5hbmQgZW5zdXJlIHlvdSBhcmUgYWNjb3VudGluZyBmb3IgdGhpcyByaXNrLlxcblxcbmApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGFncyB0aGF0IGNvbnRhaW4gc29tZXRoaW5nIG90aGVyIHRoYW4gSFRNTCwgb3Igd2hlcmUgZGlzY2FyZGluZ1xuICAvLyB0aGUgdGV4dCB3aGVuIHRoZSB0YWcgaXMgZGlzYWxsb3dlZCBtYWtlcyBzZW5zZSBmb3Igb3RoZXIgcmVhc29ucy5cbiAgLy8gSWYgd2UgYXJlIG5vdCBhbGxvd2luZyB0aGVzZSB0YWdzLCB3ZSBzaG91bGQgZHJvcCB0aGVpciBjb250ZW50IHRvby5cbiAgLy8gRm9yIG90aGVyIHRhZ3MgeW91IHdvdWxkIGRyb3AgdGhlIHRhZyBidXQga2VlcCBpdHMgY29udGVudC5cbiAgY29uc3Qgbm9uVGV4dFRhZ3NBcnJheSA9IG9wdGlvbnMubm9uVGV4dFRhZ3MgfHwgW1xuICAgICdzY3JpcHQnLFxuICAgICdzdHlsZScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnb3B0aW9uJ1xuICBdO1xuICBsZXQgYWxsb3dlZEF0dHJpYnV0ZXNNYXA7XG4gIGxldCBhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXA7XG4gIGlmIChvcHRpb25zLmFsbG93ZWRBdHRyaWJ1dGVzKSB7XG4gICAgYWxsb3dlZEF0dHJpYnV0ZXNNYXAgPSB7fTtcbiAgICBhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXAgPSB7fTtcbiAgICBlYWNoKG9wdGlvbnMuYWxsb3dlZEF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIHRhZykge1xuICAgICAgYWxsb3dlZEF0dHJpYnV0ZXNNYXBbdGFnXSA9IFtdO1xuICAgICAgY29uc3QgZ2xvYlJlZ2V4ID0gW107XG4gICAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyAmJiBvYmouaW5kZXhPZignKicpID49IDApIHtcbiAgICAgICAgICBnbG9iUmVnZXgucHVzaChlc2NhcGVTdHJpbmdSZWdleHAob2JqKS5yZXBsYWNlKC9cXFxcXFwqL2csICcuKicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlc01hcFt0YWddLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZ2xvYlJlZ2V4Lmxlbmd0aCkge1xuICAgICAgICBhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXBbdGFnXSA9IG5ldyBSZWdFeHAoJ14oJyArIGdsb2JSZWdleC5qb2luKCd8JykgKyAnKSQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCBhbGxvd2VkQ2xhc3Nlc01hcCA9IHt9O1xuICBjb25zdCBhbGxvd2VkQ2xhc3Nlc0dsb2JNYXAgPSB7fTtcbiAgY29uc3QgYWxsb3dlZENsYXNzZXNSZWdleE1hcCA9IHt9O1xuICBlYWNoKG9wdGlvbnMuYWxsb3dlZENsYXNzZXMsIGZ1bmN0aW9uKGNsYXNzZXMsIHRhZykge1xuICAgIC8vIEltcGxpY2l0bHkgYWxsb3dzIHRoZSBjbGFzcyBhdHRyaWJ1dGVcbiAgICBpZiAoYWxsb3dlZEF0dHJpYnV0ZXNNYXApIHtcbiAgICAgIGlmICghaGFzKGFsbG93ZWRBdHRyaWJ1dGVzTWFwLCB0YWcpKSB7XG4gICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzTWFwW3RhZ10gPSBbXTtcbiAgICAgIH1cbiAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzTWFwW3RhZ10ucHVzaCgnY2xhc3MnKTtcbiAgICB9XG5cbiAgICBhbGxvd2VkQ2xhc3Nlc01hcFt0YWddID0gY2xhc3NlcztcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNsYXNzZXMpKSB7XG4gICAgICBjb25zdCBnbG9iUmVnZXggPSBbXTtcbiAgICAgIGFsbG93ZWRDbGFzc2VzTWFwW3RhZ10gPSBbXTtcbiAgICAgIGFsbG93ZWRDbGFzc2VzUmVnZXhNYXBbdGFnXSA9IFtdO1xuICAgICAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgJiYgb2JqLmluZGV4T2YoJyonKSA+PSAwKSB7XG4gICAgICAgICAgZ2xvYlJlZ2V4LnB1c2goZXNjYXBlU3RyaW5nUmVnZXhwKG9iaikucmVwbGFjZSgvXFxcXFxcKi9nLCAnLionKSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgYWxsb3dlZENsYXNzZXNSZWdleE1hcFt0YWddLnB1c2gob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGxvd2VkQ2xhc3Nlc01hcFt0YWddLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZ2xvYlJlZ2V4Lmxlbmd0aCkge1xuICAgICAgICBhbGxvd2VkQ2xhc3Nlc0dsb2JNYXBbdGFnXSA9IG5ldyBSZWdFeHAoJ14oJyArIGdsb2JSZWdleC5qb2luKCd8JykgKyAnKSQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHRyYW5zZm9ybVRhZ3NNYXAgPSB7fTtcbiAgbGV0IHRyYW5zZm9ybVRhZ3NBbGw7XG4gIGVhY2gob3B0aW9ucy50cmFuc2Zvcm1UYWdzLCBmdW5jdGlvbih0cmFuc2Zvcm0sIHRhZykge1xuICAgIGxldCB0cmFuc0Z1bjtcbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJhbnNGdW4gPSB0cmFuc2Zvcm07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnc3RyaW5nJykge1xuICAgICAgdHJhbnNGdW4gPSBzYW5pdGl6ZUh0bWwuc2ltcGxlVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICcqJykge1xuICAgICAgdHJhbnNmb3JtVGFnc0FsbCA9IHRyYW5zRnVuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1UYWdzTWFwW3RhZ10gPSB0cmFuc0Z1bjtcbiAgICB9XG4gIH0pO1xuXG4gIGxldCBkZXB0aDtcbiAgbGV0IHN0YWNrO1xuICBsZXQgc2tpcE1hcDtcbiAgbGV0IHRyYW5zZm9ybU1hcDtcbiAgbGV0IHNraXBUZXh0O1xuICBsZXQgc2tpcFRleHREZXB0aDtcbiAgbGV0IGFkZGVkVGV4dCA9IGZhbHNlO1xuXG4gIGluaXRpYWxpemVTdGF0ZSgpO1xuXG4gIGNvbnN0IHBhcnNlciA9IG5ldyBodG1scGFyc2VyLlBhcnNlcih7XG4gICAgb25vcGVudGFnOiBmdW5jdGlvbihuYW1lLCBhdHRyaWJzKSB7XG4gICAgICAvLyBJZiBgZW5mb3JjZUh0bWxCb3VuZGFyeWAgaXMgYHRydWVgIGFuZCB0aGlzIGhhcyBmb3VuZCB0aGUgb3BlbmluZ1xuICAgICAgLy8gYGh0bWxgIHRhZywgcmVzZXQgdGhlIHN0YXRlLlxuICAgICAgaWYgKG9wdGlvbnMuZW5mb3JjZUh0bWxCb3VuZGFyeSAmJiBuYW1lID09PSAnaHRtbCcpIHtcbiAgICAgICAgaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChza2lwVGV4dCkge1xuICAgICAgICBza2lwVGV4dERlcHRoKys7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYW1lID0gbmV3IEZyYW1lKG5hbWUsIGF0dHJpYnMpO1xuICAgICAgc3RhY2sucHVzaChmcmFtZSk7XG5cbiAgICAgIGxldCBza2lwID0gZmFsc2U7XG4gICAgICBjb25zdCBoYXNUZXh0ID0gISFmcmFtZS50ZXh0O1xuICAgICAgbGV0IHRyYW5zZm9ybWVkVGFnO1xuICAgICAgaWYgKGhhcyh0cmFuc2Zvcm1UYWdzTWFwLCBuYW1lKSkge1xuICAgICAgICB0cmFuc2Zvcm1lZFRhZyA9IHRyYW5zZm9ybVRhZ3NNYXBbbmFtZV0obmFtZSwgYXR0cmlicyk7XG5cbiAgICAgICAgZnJhbWUuYXR0cmlicyA9IGF0dHJpYnMgPSB0cmFuc2Zvcm1lZFRhZy5hdHRyaWJzO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZFRhZy50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmcmFtZS5pbm5lclRleHQgPSB0cmFuc2Zvcm1lZFRhZy50ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgIT09IHRyYW5zZm9ybWVkVGFnLnRhZ05hbWUpIHtcbiAgICAgICAgICBmcmFtZS5uYW1lID0gbmFtZSA9IHRyYW5zZm9ybWVkVGFnLnRhZ05hbWU7XG4gICAgICAgICAgdHJhbnNmb3JtTWFwW2RlcHRoXSA9IHRyYW5zZm9ybWVkVGFnLnRhZ05hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1UYWdzQWxsKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkVGFnID0gdHJhbnNmb3JtVGFnc0FsbChuYW1lLCBhdHRyaWJzKTtcblxuICAgICAgICBmcmFtZS5hdHRyaWJzID0gYXR0cmlicyA9IHRyYW5zZm9ybWVkVGFnLmF0dHJpYnM7XG4gICAgICAgIGlmIChuYW1lICE9PSB0cmFuc2Zvcm1lZFRhZy50YWdOYW1lKSB7XG4gICAgICAgICAgZnJhbWUubmFtZSA9IG5hbWUgPSB0cmFuc2Zvcm1lZFRhZy50YWdOYW1lO1xuICAgICAgICAgIHRyYW5zZm9ybU1hcFtkZXB0aF0gPSB0cmFuc2Zvcm1lZFRhZy50YWdOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGFnQWxsb3dlZChuYW1lKSB8fCAob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGUgPT09ICdyZWN1cnNpdmVFc2NhcGUnICYmICFpc0VtcHR5T2JqZWN0KHNraXBNYXApKSB8fCAob3B0aW9ucy5uZXN0aW5nTGltaXQgIT0gbnVsbCAmJiBkZXB0aCA+PSBvcHRpb25zLm5lc3RpbmdMaW1pdCkpIHtcbiAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgIHNraXBNYXBbZGVwdGhdID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWxsb3dlZFRhZ3NNb2RlID09PSAnZGlzY2FyZCcgfHwgb3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGUgPT09ICdjb21wbGV0ZWx5RGlzY2FyZCcpIHtcbiAgICAgICAgICBpZiAobm9uVGV4dFRhZ3NBcnJheS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgc2tpcFRleHQgPSB0cnVlO1xuICAgICAgICAgICAgc2tpcFRleHREZXB0aCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNraXBNYXBbZGVwdGhdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRlcHRoKys7XG4gICAgICBpZiAoc2tpcCkge1xuICAgICAgICBpZiAob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGUgPT09ICdkaXNjYXJkJyB8fCBvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ2NvbXBsZXRlbHlEaXNjYXJkJykge1xuICAgICAgICAgIC8vIFdlIHdhbnQgdGhlIGNvbnRlbnRzIGJ1dCBub3QgdGhpcyB0YWdcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGVtcFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJzwnICsgbmFtZTtcblxuICAgICAgaWYgKG5hbWUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93ZWRTY3JpcHRIb3N0bmFtZXMgfHwgb3B0aW9ucy5hbGxvd2VkU2NyaXB0RG9tYWlucykge1xuICAgICAgICAgIGZyYW1lLmlubmVyVGV4dCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZXNNYXAgfHwgaGFzKGFsbG93ZWRBdHRyaWJ1dGVzTWFwLCBuYW1lKSB8fCBhbGxvd2VkQXR0cmlidXRlc01hcFsnKiddKSB7XG4gICAgICAgIGVhY2goYXR0cmlicywgZnVuY3Rpb24odmFsdWUsIGEpIHtcbiAgICAgICAgICBpZiAoIVZBTElEX0hUTUxfQVRUUklCVVRFX05BTUUudGVzdChhKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBwYXJ0IG9mIGFuIGF0dHJpYnV0ZSBuYW1lIGluIHRoZSBvdXRwdXQgZnJvbSBiZWluZ1xuICAgICAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgdGhlIGVuZCBvZiBhbiBhdHRyaWJ1dGUsIG9yIGVuZCBvZiBhIHRhZy5cbiAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgZW1wdHksIGNoZWNrIGlmIHRoZSBhdHRyaWJ1dGUgaXMgaW4gdGhlIGFsbG93ZWRFbXB0eUF0dHJpYnV0ZXMgYXJyYXkuXG4gICAgICAgICAgLy8gSWYgaXQgaXMgbm90IGluIHRoZSBhbGxvd2VkRW1wdHlBdHRyaWJ1dGVzIGFycmF5LCBhbmQgaXQgaXMgYSBrbm93biBub24tYm9vbGVhbiBhdHRyaWJ1dGUsIGRlbGV0ZSBpdFxuICAgICAgICAgIC8vIExpc3QgdGFrZW4gZnJvbSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjYXR0cmlidXRlcy0zXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJyAmJiAoIW9wdGlvbnMuYWxsb3dlZEVtcHR5QXR0cmlidXRlcy5pbmNsdWRlcyhhKSkgJiZcbiAgICAgICAgICAgIChvcHRpb25zLm5vbkJvb2xlYW5BdHRyaWJ1dGVzLmluY2x1ZGVzKGEpIHx8IG9wdGlvbnMubm9uQm9vbGVhbkF0dHJpYnV0ZXMuaW5jbHVkZXMoJyonKSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjaGVjayBhbGxvd2VkQXR0cmlidXRlc01hcCBmb3IgdGhlIGVsZW1lbnQgYW5kIGF0dHJpYnV0ZSBhbmQgbW9kaWZ5IHRoZSB2YWx1ZVxuICAgICAgICAgIC8vIGFzIG5lY2Vzc2FyeSBpZiB0aGVyZSBhcmUgc3BlY2lmaWMgdmFsdWVzIGRlZmluZWQuXG4gICAgICAgICAgbGV0IHBhc3NlZEFsbG93ZWRBdHRyaWJ1dGVzTWFwQ2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGVzTWFwIHx8XG4gICAgICAgICAgICAoaGFzKGFsbG93ZWRBdHRyaWJ1dGVzTWFwLCBuYW1lKSAmJiBhbGxvd2VkQXR0cmlidXRlc01hcFtuYW1lXS5pbmRleE9mKGEpICE9PSAtMSkgfHxcbiAgICAgICAgICAgIChhbGxvd2VkQXR0cmlidXRlc01hcFsnKiddICYmIGFsbG93ZWRBdHRyaWJ1dGVzTWFwWycqJ10uaW5kZXhPZihhKSAhPT0gLTEpIHx8XG4gICAgICAgICAgICAoaGFzKGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcCwgbmFtZSkgJiYgYWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwW25hbWVdLnRlc3QoYSkpIHx8XG4gICAgICAgICAgICAoYWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwWycqJ10gJiYgYWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwWycqJ10udGVzdChhKSkpIHtcbiAgICAgICAgICAgIHBhc3NlZEFsbG93ZWRBdHRyaWJ1dGVzTWFwQ2hlY2sgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYWxsb3dlZEF0dHJpYnV0ZXNNYXAgJiYgYWxsb3dlZEF0dHJpYnV0ZXNNYXBbbmFtZV0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbyBvZiBhbGxvd2VkQXR0cmlidXRlc01hcFtuYW1lXSkge1xuICAgICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChvKSAmJiBvLm5hbWUgJiYgKG8ubmFtZSA9PT0gYSkpIHtcbiAgICAgICAgICAgICAgICBwYXNzZWRBbGxvd2VkQXR0cmlidXRlc01hcENoZWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoby5tdWx0aXBsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gdmVyaWZ5IHRoZSB2YWx1ZXMgdGhhdCBhcmUgYWxsb3dlZFxuICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRTdHJBcnJheSA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc3BsaXRTdHJBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoby52YWx1ZXMuaW5kZXhPZihzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHM7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlICs9ICcgJyArIHM7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvLnZhbHVlcy5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyB2ZXJpZmllZCBhbiBhbGxvd2VkIHZhbHVlIG1hdGNoZXMgdGhlIGVudGlyZSBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhc3NlZEFsbG93ZWRBdHRyaWJ1dGVzTWFwQ2hlY2spIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93ZWRTY2hlbWVzQXBwbGllZFRvQXR0cmlidXRlcy5pbmRleE9mKGEpICE9PSAtMSkge1xuICAgICAgICAgICAgICBpZiAobmF1Z2h0eUhyZWYobmFtZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnc2NyaXB0JyAmJiBhID09PSAnc3JjJykge1xuXG4gICAgICAgICAgICAgIGxldCBhbGxvd2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlVXJsKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93ZWRTY3JpcHRIb3N0bmFtZXMgfHwgb3B0aW9ucy5hbGxvd2VkU2NyaXB0RG9tYWlucykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZEhvc3RuYW1lID0gKG9wdGlvbnMuYWxsb3dlZFNjcmlwdEhvc3RuYW1lcyB8fCBbXSkuZmluZChmdW5jdGlvbiAoaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RuYW1lID09PSBwYXJzZWQudXJsLmhvc3RuYW1lO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkRG9tYWluID0gKG9wdGlvbnMuYWxsb3dlZFNjcmlwdERvbWFpbnMgfHwgW10pLmZpbmQoZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQudXJsLmhvc3RuYW1lID09PSBkb21haW4gfHwgcGFyc2VkLnVybC5ob3N0bmFtZS5lbmRzV2l0aChgLiR7ZG9tYWlufWApO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBhbGxvd2VkID0gYWxsb3dlZEhvc3RuYW1lIHx8IGFsbG93ZWREb21haW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaWZyYW1lJyAmJiBhID09PSAnc3JjJykge1xuICAgICAgICAgICAgICBsZXQgYWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VVcmwodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5pc1JlbGF0aXZlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlIG9mIGFsbG93SWZyYW1lUmVsYXRpdmVVcmxzIGlzIHRydWVcbiAgICAgICAgICAgICAgICAgIC8vIHVubGVzcyBhbGxvd2VkSWZyYW1lSG9zdG5hbWVzIG9yIGFsbG93ZWRJZnJhbWVEb21haW5zIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgYWxsb3dlZCA9IGhhcyhvcHRpb25zLCAnYWxsb3dJZnJhbWVSZWxhdGl2ZVVybHMnKVxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuYWxsb3dJZnJhbWVSZWxhdGl2ZVVybHNcbiAgICAgICAgICAgICAgICAgICAgOiAoIW9wdGlvbnMuYWxsb3dlZElmcmFtZUhvc3RuYW1lcyAmJiAhb3B0aW9ucy5hbGxvd2VkSWZyYW1lRG9tYWlucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmFsbG93ZWRJZnJhbWVIb3N0bmFtZXMgfHwgb3B0aW9ucy5hbGxvd2VkSWZyYW1lRG9tYWlucykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZEhvc3RuYW1lID0gKG9wdGlvbnMuYWxsb3dlZElmcmFtZUhvc3RuYW1lcyB8fCBbXSkuZmluZChmdW5jdGlvbiAoaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RuYW1lID09PSBwYXJzZWQudXJsLmhvc3RuYW1lO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkRG9tYWluID0gKG9wdGlvbnMuYWxsb3dlZElmcmFtZURvbWFpbnMgfHwgW10pLmZpbmQoZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQudXJsLmhvc3RuYW1lID09PSBkb21haW4gfHwgcGFyc2VkLnVybC5ob3N0bmFtZS5lbmRzV2l0aChgLiR7ZG9tYWlufWApO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBhbGxvd2VkID0gYWxsb3dlZEhvc3RuYW1lIHx8IGFsbG93ZWREb21haW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5wYXJzZWFibGUgaWZyYW1lIHNyY1xuICAgICAgICAgICAgICAgIGFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZnJhbWUuYXR0cmlic1thXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhID09PSAnc3Jjc2V0Jykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBwYXJzZVNyY3NldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcGFyc2VkLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChuYXVnaHR5SHJlZignc3Jjc2V0JywgdmFsdWUudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5ldmlsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBmaWx0ZXIocGFyc2VkLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gIXYuZXZpbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ2lmeVNyY3NldChmaWx0ZXIocGFyc2VkLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhdi5ldmlsO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgZnJhbWUuYXR0cmlic1thXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFVucGFyc2VhYmxlIHNyY3NldFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZFNwZWNpZmljQ2xhc3NlcyA9IGFsbG93ZWRDbGFzc2VzTWFwW25hbWVdO1xuICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkV2lsZGNhcmRDbGFzc2VzID0gYWxsb3dlZENsYXNzZXNNYXBbJyonXTtcbiAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZFNwZWNpZmljQ2xhc3Nlc0dsb2IgPSBhbGxvd2VkQ2xhc3Nlc0dsb2JNYXBbbmFtZV07XG4gICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRTcGVjaWZpY0NsYXNzZXNSZWdleCA9IGFsbG93ZWRDbGFzc2VzUmVnZXhNYXBbbmFtZV07XG4gICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRXaWxkY2FyZENsYXNzZXNHbG9iID0gYWxsb3dlZENsYXNzZXNHbG9iTWFwWycqJ107XG4gICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRDbGFzc2VzR2xvYnMgPSBbXG4gICAgICAgICAgICAgICAgYWxsb3dlZFNwZWNpZmljQ2xhc3Nlc0dsb2IsXG4gICAgICAgICAgICAgICAgYWxsb3dlZFdpbGRjYXJkQ2xhc3Nlc0dsb2JcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIC5jb25jYXQoYWxsb3dlZFNwZWNpZmljQ2xhc3Nlc1JlZ2V4KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoYWxsb3dlZFNwZWNpZmljQ2xhc3NlcyAmJiBhbGxvd2VkV2lsZGNhcmRDbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXJDbGFzc2VzKHZhbHVlLCBkZWVwbWVyZ2UoYWxsb3dlZFNwZWNpZmljQ2xhc3NlcywgYWxsb3dlZFdpbGRjYXJkQ2xhc3NlcyksIGFsbG93ZWRDbGFzc2VzR2xvYnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZmlsdGVyQ2xhc3Nlcyh2YWx1ZSwgYWxsb3dlZFNwZWNpZmljQ2xhc3NlcyB8fCBhbGxvd2VkV2lsZGNhcmRDbGFzc2VzLCBhbGxvd2VkQ2xhc3Nlc0dsb2JzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyc2VTdHlsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWJzdHJhY3RTeW50YXhUcmVlID0gcG9zdGNzc1BhcnNlKG5hbWUgKyAnIHsnICsgdmFsdWUgKyAnfScsIHsgbWFwOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQVNUID0gZmlsdGVyQ3NzKGFic3RyYWN0U3ludGF4VHJlZSwgb3B0aW9ucy5hbGxvd2VkU3R5bGVzKTtcblxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnlTdHlsZUF0dHJpYnV0ZXMoZmlsdGVyZWRBU1QpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIFwiJyArIG5hbWUgKyAnIHsnICsgdmFsdWUgKyAnfScgKyAnXCIsIElmIHlvdVxcJ3JlIHJ1bm5pbmcgdGhpcyBpbiBhIGJyb3dzZXIsIHdlIHJlY29tbWVuZCB0byBkaXNhYmxlIHN0eWxlIHBhcnNpbmc6IG9wdGlvbnMucGFyc2VTdHlsZUF0dHJpYnV0ZXM6IGZhbHNlLCBzaW5jZSB0aGlzIG9ubHkgd29ya3MgaW4gYSBub2RlIGVudmlyb25tZW50IGR1ZSB0byBhIHBvc3Rjc3MgZGVwZW5kZW5jeSwgTW9yZSBpbmZvOiBodHRwczovL2dpdGh1Yi5jb20vYXBvc3Ryb3BoZWNtcy9zYW5pdGl6ZS1odG1sL2lzc3Vlcy81NDcnKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmFsbG93ZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FsbG93ZWRTdHlsZXMgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggcGFyc2VTdHlsZUF0dHJpYnV0ZXM6IGZhbHNlLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJyAnICsgYTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9ICc9XCInICsgZXNjYXBlSHRtbCh2YWx1ZSwgdHJ1ZSkgKyAnXCInO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmFsbG93ZWRFbXB0eUF0dHJpYnV0ZXMuaW5jbHVkZXMoYSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9ICc9XCJcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zZWxmQ2xvc2luZy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICByZXN1bHQgKz0gJyAvPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gJz4nO1xuICAgICAgICBpZiAoZnJhbWUuaW5uZXJUZXh0ICYmICFoYXNUZXh0ICYmICFvcHRpb25zLnRleHRGaWx0ZXIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlSHRtbChmcmFtZS5pbm5lclRleHQpO1xuICAgICAgICAgIGFkZGVkVGV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHJlc3VsdCA9IHRlbXBSZXN1bHQgKyBlc2NhcGVIdG1sKHJlc3VsdCk7XG4gICAgICAgIHRlbXBSZXN1bHQgPSAnJztcbiAgICAgIH1cbiAgICB9LFxuICAgIG9udGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgaWYgKHNraXBUZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RGcmFtZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgbGV0IHRhZztcblxuICAgICAgaWYgKGxhc3RGcmFtZSkge1xuICAgICAgICB0YWcgPSBsYXN0RnJhbWUudGFnO1xuICAgICAgICAvLyBJZiBpbm5lciB0ZXh0IHdhcyBzZXQgYnkgdHJhbnNmb3JtIGZ1bmN0aW9uIHRoZW4gbGV0J3MgdXNlIGl0XG4gICAgICAgIHRleHQgPSBsYXN0RnJhbWUuaW5uZXJUZXh0ICE9PSB1bmRlZmluZWQgPyBsYXN0RnJhbWUuaW5uZXJUZXh0IDogdGV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGlzYWxsb3dlZFRhZ3NNb2RlID09PSAnY29tcGxldGVseURpc2NhcmQnICYmICF0YWdBbGxvd2VkKHRhZykpIHtcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICgob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGUgPT09ICdkaXNjYXJkJyB8fCBvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ2NvbXBsZXRlbHlEaXNjYXJkJykgJiYgKCh0YWcgPT09ICdzY3JpcHQnKSB8fCAodGFnID09PSAnc3R5bGUnKSkpIHtcbiAgICAgICAgLy8gaHRtbHBhcnNlcjIgZ2l2ZXMgdXMgdGhlc2UgYXMtaXMuIEVzY2FwaW5nIHRoZW0gcnVpbnMgdGhlIGNvbnRlbnQuIEFsbG93aW5nXG4gICAgICAgIC8vIHNjcmlwdCB0YWdzIGlzLCBieSBkZWZpbml0aW9uLCBnYW1lIG92ZXIgZm9yIFhTUyBwcm90ZWN0aW9uLCBzbyBpZiB0aGF0J3NcbiAgICAgICAgLy8geW91ciBjb25jZXJuLCBkb24ndCBhbGxvdyB0aGVtLiBUaGUgc2FtZSBpcyBlc3NlbnRpYWxseSB0cnVlIGZvciBzdHlsZSB0YWdzXG4gICAgICAgIC8vIHdoaWNoIGhhdmUgdGhlaXIgb3duIGNvbGxlY3Rpb24gb2YgWFNTIHZlY3RvcnMuXG4gICAgICAgIHJlc3VsdCArPSB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXNjYXBlZCA9IGVzY2FwZUh0bWwodGV4dCwgZmFsc2UpO1xuICAgICAgICBpZiAob3B0aW9ucy50ZXh0RmlsdGVyICYmICFhZGRlZFRleHQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gb3B0aW9ucy50ZXh0RmlsdGVyKGVzY2FwZWQsIHRhZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFkZGVkVGV4dCkge1xuICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGZyYW1lLnRleHQgKz0gdGV4dDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uY2xvc2V0YWc6IGZ1bmN0aW9uKG5hbWUsIGlzSW1wbGllZCkge1xuXG4gICAgICBpZiAoc2tpcFRleHQpIHtcbiAgICAgICAgc2tpcFRleHREZXB0aC0tO1xuICAgICAgICBpZiAoIXNraXBUZXh0RGVwdGgpIHtcbiAgICAgICAgICBza2lwVGV4dCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmcmFtZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgaWYgKCFmcmFtZSkge1xuICAgICAgICAvLyBEbyBub3QgY3Jhc2ggb24gYmFkIG1hcmt1cFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFtZS50YWcgIT09IG5hbWUpIHtcbiAgICAgICAgLy8gQW5vdGhlciBjYXNlIG9mIGJhZCBtYXJrdXAuXG4gICAgICAgIC8vIFB1c2ggdG8gc3RhY2ssIHNvIHRoYXQgaXQgd2lsbCBiZSB1c2VkIGluIGZ1dHVyZSBjbG9zaW5nIHRhZ3MuXG4gICAgICAgIHN0YWNrLnB1c2goZnJhbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNraXBUZXh0ID0gb3B0aW9ucy5lbmZvcmNlSHRtbEJvdW5kYXJ5ID8gbmFtZSA9PT0gJ2h0bWwnIDogZmFsc2U7XG4gICAgICBkZXB0aC0tO1xuICAgICAgY29uc3Qgc2tpcCA9IHNraXBNYXBbZGVwdGhdO1xuICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgZGVsZXRlIHNraXBNYXBbZGVwdGhdO1xuICAgICAgICBpZiAob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGUgPT09ICdkaXNjYXJkJyB8fCBvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ2NvbXBsZXRlbHlEaXNjYXJkJykge1xuICAgICAgICAgIGZyYW1lLnVwZGF0ZVBhcmVudE5vZGVUZXh0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtTWFwW2RlcHRoXSkge1xuICAgICAgICBuYW1lID0gdHJhbnNmb3JtTWFwW2RlcHRoXTtcbiAgICAgICAgZGVsZXRlIHRyYW5zZm9ybU1hcFtkZXB0aF07XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmV4Y2x1c2l2ZUZpbHRlciAmJiBvcHRpb25zLmV4Y2x1c2l2ZUZpbHRlcihmcmFtZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cigwLCBmcmFtZS50YWdQb3NpdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZnJhbWUudXBkYXRlUGFyZW50Tm9kZU1lZGlhQ2hpbGRyZW4oKTtcbiAgICAgIGZyYW1lLnVwZGF0ZVBhcmVudE5vZGVUZXh0KCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gQWxyZWFkeSBvdXRwdXQgLz5cbiAgICAgICAgb3B0aW9ucy5zZWxmQ2xvc2luZy5pbmRleE9mKG5hbWUpICE9PSAtMSB8fFxuICAgICAgICAvLyBFc2NhcGVkIHRhZywgY2xvc2luZyB0YWcgaXMgaW1wbGllZFxuICAgICAgICAoaXNJbXBsaWVkICYmICF0YWdBbGxvd2VkKG5hbWUpICYmIFsgJ2VzY2FwZScsICdyZWN1cnNpdmVFc2NhcGUnIF0uaW5kZXhPZihvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSkgPj0gMClcbiAgICAgICkge1xuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgIHJlc3VsdCA9IHRlbXBSZXN1bHQ7XG4gICAgICAgICAgdGVtcFJlc3VsdCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICc8LycgKyBuYW1lICsgJz4nO1xuICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgcmVzdWx0ID0gdGVtcFJlc3VsdCArIGVzY2FwZUh0bWwocmVzdWx0KTtcbiAgICAgICAgdGVtcFJlc3VsdCA9ICcnO1xuICAgICAgfVxuICAgICAgYWRkZWRUZXh0ID0gZmFsc2U7XG4gICAgfVxuICB9LCBvcHRpb25zLnBhcnNlcik7XG4gIHBhcnNlci53cml0ZShodG1sKTtcbiAgcGFyc2VyLmVuZCgpO1xuXG4gIHJldHVybiByZXN1bHQ7XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHJlc3VsdCA9ICcnO1xuICAgIGRlcHRoID0gMDtcbiAgICBzdGFjayA9IFtdO1xuICAgIHNraXBNYXAgPSB7fTtcbiAgICB0cmFuc2Zvcm1NYXAgPSB7fTtcbiAgICBza2lwVGV4dCA9IGZhbHNlO1xuICAgIHNraXBUZXh0RGVwdGggPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbChzLCBxdW90ZSkge1xuICAgIGlmICh0eXBlb2YgKHMpICE9PSAnc3RyaW5nJykge1xuICAgICAgcyA9IHMgKyAnJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucGFyc2VyLmRlY29kZUVudGl0aWVzKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgICBpZiAocXVvdGUpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiB0aGlzIGlzIGluYWRlcXVhdGUgYmVjYXVzZSBpdCB3aWxsIHBhc3MgYCYwO2AuIFRoaXMgYXBwcm9hY2hcbiAgICAvLyB3aWxsIG5vdCB3b3JrLCBlYWNoICYgbXVzdCBiZSBjb25zaWRlcmVkIHdpdGggcmVnYXJkIHRvIHdoZXRoZXIgaXRcbiAgICAvLyBpcyBmb2xsb3dlZCBieSBhIDEwMCUgc3ludGFjdGljYWxseSB2YWxpZCBlbnRpdHkgb3Igbm90LCBhbmQgZXNjYXBlZFxuICAgIC8vIGlmIGl0IGlzIG5vdC4gSWYgdGhpcyBib3RoZXJzIHlvdSwgZG9uJ3Qgc2V0IHBhcnNlci5kZWNvZGVFbnRpdGllc1xuICAgIC8vIHRvIGZhbHNlLiAoVGhlIGRlZmF1bHQgaXMgdHJ1ZS4pXG4gICAgcyA9IHMucmVwbGFjZSgvJig/IVthLXpBLVowLTkjXXsxLDIwfTspL2csICcmYW1wOycpIC8vIE1hdGNoIGFtcGVyc2FuZHMgbm90IHBhcnQgb2YgZXhpc3RpbmcgSFRNTCBlbnRpdHlcbiAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgaWYgKHF1b3RlKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gbmF1Z2h0eUhyZWYobmFtZSwgaHJlZikge1xuICAgIC8vIEJyb3dzZXJzIGlnbm9yZSBjaGFyYWN0ZXIgY29kZXMgb2YgMzIgKHNwYWNlKSBhbmQgYmVsb3cgaW4gYSBzdXJwcmlzaW5nXG4gICAgLy8gbnVtYmVyIG9mIHNpdHVhdGlvbnMuIFN0YXJ0IHJlYWRpbmcgaGVyZTpcbiAgICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldCNFbWJlZGRlZF90YWJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIGhyZWYgPSBocmVmLnJlcGxhY2UoL1tcXHgwMC1cXHgyMF0rL2csICcnKTtcbiAgICAvLyBDbG9iYmVyIGFueSBjb21tZW50cyBpbiBVUkxzLCB3aGljaCB0aGUgYnJvd3NlciBtaWdodFxuICAgIC8vIGludGVycHJldCBpbnNpZGUgYW4gWE1MIGRhdGEgaXNsYW5kLCBhbGxvd2luZ1xuICAgIC8vIGEgamF2YXNjcmlwdDogVVJMIHRvIGJlIHNudWNrIHRocm91Z2hcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgZmlyc3RJbmRleCA9IGhyZWYuaW5kZXhPZignPCEtLScpO1xuICAgICAgaWYgKGZpcnN0SW5kZXggPT09IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaHJlZi5pbmRleE9mKCctLT4nLCBmaXJzdEluZGV4ICsgNCk7XG4gICAgICBpZiAobGFzdEluZGV4ID09PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGhyZWYgPSBocmVmLnN1YnN0cmluZygwLCBmaXJzdEluZGV4KSArIGhyZWYuc3Vic3RyaW5nKGxhc3RJbmRleCArIDMpO1xuICAgIH1cbiAgICAvLyBDYXNlIGluc2Vuc2l0aXZlIHNvIHdlIGRvbid0IGdldCBmYWtlZCBvdXQgYnkgSkFWQVNDUklQVCAjMVxuICAgIC8vIEFsbG93IG1vcmUgY2hhcmFjdGVycyBhZnRlciB0aGUgZmlyc3Qgc28gd2UgZG9uJ3QgZ2V0IGZha2VkXG4gICAgLy8gb3V0IGJ5IGNlcnRhaW4gc2NoZW1lcyBicm93c2VycyBhY2NlcHRcbiAgICBjb25zdCBtYXRjaGVzID0gaHJlZi5tYXRjaCgvXihbYS16QS1aXVthLXpBLVowLTkuXFwtK10qKTovKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIC8vIFByb3RvY29sLXJlbGF0aXZlIFVSTCBzdGFydGluZyB3aXRoIGFueSBjb21iaW5hdGlvbiBvZiAnLycgYW5kICdcXCdcbiAgICAgIGlmIChocmVmLm1hdGNoKC9eWy9cXFxcXXsyfS8pKSB7XG4gICAgICAgIHJldHVybiAhb3B0aW9ucy5hbGxvd1Byb3RvY29sUmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vIHNjaGVtZVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzY2hlbWUgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoaGFzKG9wdGlvbnMuYWxsb3dlZFNjaGVtZXNCeVRhZywgbmFtZSkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmFsbG93ZWRTY2hlbWVzQnlUYWdbbmFtZV0uaW5kZXhPZihzY2hlbWUpID09PSAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gIW9wdGlvbnMuYWxsb3dlZFNjaGVtZXMgfHwgb3B0aW9ucy5hbGxvd2VkU2NoZW1lcy5pbmRleE9mKHNjaGVtZSkgPT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VVcmwodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oXFx3KzopP1xccypbXFxcXC9dXFxzKltcXFxcL10vLCAnJDEvLycpO1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdyZWxhdGl2ZTonKSkge1xuICAgICAgLy8gQW4gYXR0ZW1wdCB0byBleHBsb2l0IG91ciB3b3JrYXJvdW5kIGZvciBiYXNlIFVSTHMgYmVpbmdcbiAgICAgIC8vIG1hbmRhdG9yeSBmb3IgcmVsYXRpdmUgVVJMIHZhbGlkYXRpb24gaW4gdGhlIFdIQVRXR1xuICAgICAgLy8gVVJMIHBhcnNlciwgcmVqZWN0IGl0XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbGF0aXZlOiBleHBsb2l0IGF0dGVtcHQnKTtcbiAgICB9XG4gICAgLy8gbmF1Z2h0eUhyZWYgaXMgaW4gY2hhcmdlIG9mIHdoZXRoZXIgcHJvdG9jb2wgcmVsYXRpdmUgVVJMc1xuICAgIC8vIGFyZSBjb29sLiBIZXJlIHdlIGFyZSBjb25jZXJuZWQganVzdCB3aXRoIGFsbG93ZWQgaG9zdG5hbWVzIGFuZFxuICAgIC8vIHdoZXRoZXIgdG8gYWxsb3cgcmVsYXRpdmUgVVJMcy5cbiAgICAvL1xuICAgIC8vIEJ1aWxkIGEgcGxhY2Vob2xkZXIgXCJiYXNlIFVSTFwiIGFnYWluc3Qgd2hpY2ggYW55IHJlYXNvbmFibGVcbiAgICAvLyByZWxhdGl2ZSBVUkwgbWF5IGJlIHBhcnNlZCBzdWNjZXNzZnVsbHlcbiAgICBsZXQgYmFzZSA9ICdyZWxhdGl2ZTovL3JlbGF0aXZlLXNpdGUnO1xuICAgIGZvciAobGV0IGkgPSAwOyAoaSA8IDEwMCk7IGkrKykge1xuICAgICAgYmFzZSArPSBgLyR7aX1gO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBVUkwodmFsdWUsIGJhc2UpO1xuXG4gICAgY29uc3QgaXNSZWxhdGl2ZVVybCA9IHBhcnNlZCAmJiBwYXJzZWQuaG9zdG5hbWUgPT09ICdyZWxhdGl2ZS1zaXRlJyAmJiBwYXJzZWQucHJvdG9jb2wgPT09ICdyZWxhdGl2ZTonO1xuICAgIHJldHVybiB7XG4gICAgICBpc1JlbGF0aXZlVXJsLFxuICAgICAgdXJsOiBwYXJzZWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBGaWx0ZXJzIHVzZXIgaW5wdXQgY3NzIHByb3BlcnRpZXMgYnkgYWxsb3dsaXN0ZWQgcmVnZXggYXR0cmlidXRlcy5cbiAgICogTW9kaWZpZXMgdGhlIGFic3RyYWN0U3ludGF4VHJlZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhYnN0cmFjdFN5bnRheFRyZWUgIC0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIENTUyBhdHRyaWJ1dGVzLlxuICAgKiBAcHJvcGVydHkge2FycmF5W0RlY2xhcmF0aW9uXX0gYWJzdHJhY3RTeW50YXhUcmVlLm5vZGVzWzBdIC0gRWFjaCBvYmplY3QgY29pbnRhaW5zIHByb3AgYW5kIHZhbHVlIGtleSwgaS5lIHsgcHJvcDogJ2NvbG9yJywgdmFsdWU6ICdyZWQnIH0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxvd2VkU3R5bGVzICAgICAgIC0gS2V5cyBhcmUgcHJvcGVydGllcyAoaS5lIGNvbG9yKSwgdmFsdWUgaXMgbGlzdCBvZiBwZXJtaXR0ZWQgcmVnZXggcnVsZXMgKGkuZSAvZ3JlZW4vaSkuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICAgIC0gVGhlIG1vZGlmaWVkIHRyZWUuXG4gICAqL1xuICBmdW5jdGlvbiBmaWx0ZXJDc3MoYWJzdHJhY3RTeW50YXhUcmVlLCBhbGxvd2VkU3R5bGVzKSB7XG4gICAgaWYgKCFhbGxvd2VkU3R5bGVzKSB7XG4gICAgICByZXR1cm4gYWJzdHJhY3RTeW50YXhUcmVlO1xuICAgIH1cblxuICAgIGNvbnN0IGFzdFJ1bGVzID0gYWJzdHJhY3RTeW50YXhUcmVlLm5vZGVzWzBdO1xuICAgIGxldCBzZWxlY3RlZFJ1bGU7XG5cbiAgICAvLyBNZXJnZSBnbG9iYWwgYW5kIHRhZy1zcGVjaWZpYyBzdHlsZXMgaW50byBuZXcgQVNULlxuICAgIGlmIChhbGxvd2VkU3R5bGVzW2FzdFJ1bGVzLnNlbGVjdG9yXSAmJiBhbGxvd2VkU3R5bGVzWycqJ10pIHtcbiAgICAgIHNlbGVjdGVkUnVsZSA9IGRlZXBtZXJnZShcbiAgICAgICAgYWxsb3dlZFN0eWxlc1thc3RSdWxlcy5zZWxlY3Rvcl0sXG4gICAgICAgIGFsbG93ZWRTdHlsZXNbJyonXVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRSdWxlID0gYWxsb3dlZFN0eWxlc1thc3RSdWxlcy5zZWxlY3Rvcl0gfHwgYWxsb3dlZFN0eWxlc1snKiddO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RlZFJ1bGUpIHtcbiAgICAgIGFic3RyYWN0U3ludGF4VHJlZS5ub2Rlc1swXS5ub2RlcyA9IGFzdFJ1bGVzLm5vZGVzLnJlZHVjZShmaWx0ZXJEZWNsYXJhdGlvbnMoc2VsZWN0ZWRSdWxlKSwgW10pO1xuICAgIH1cblxuICAgIHJldHVybiBhYnN0cmFjdFN5bnRheFRyZWU7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIHN0eWxlIGF0dHJpYnV0ZXMgZnJvbSBhbiBBYnN0cmFjdFN5bnRheFRyZWUgYW5kIGZvcm1hdHMgdGhvc2VcbiAgICogdmFsdWVzIGluIHRoZSBpbmxpbmUgc3R5bGUgYXR0cmlidXRlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtICB7QWJzdHJhY3RTeW50YXhUcmVlfSBmaWx0ZXJlZEFTVFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgIC0gRXhhbXBsZTogXCJjb2xvcjp5ZWxsb3c7dGV4dC1hbGlnbjpjZW50ZXIgIWltcG9ydGFudDtmb250LWZhbWlseTpoZWx2ZXRpY2E7XCJcbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlQXR0cmlidXRlcyhmaWx0ZXJlZEFTVCkge1xuICAgIHJldHVybiBmaWx0ZXJlZEFTVC5ub2Rlc1swXS5ub2Rlc1xuICAgICAgLnJlZHVjZShmdW5jdGlvbihleHRyYWN0ZWRBdHRyaWJ1dGVzLCBhdHRyT2JqZWN0KSB7XG4gICAgICAgIGV4dHJhY3RlZEF0dHJpYnV0ZXMucHVzaChcbiAgICAgICAgICBgJHthdHRyT2JqZWN0LnByb3B9OiR7YXR0ck9iamVjdC52YWx1ZX0ke2F0dHJPYmplY3QuaW1wb3J0YW50ID8gJyAhaW1wb3J0YW50JyA6ICcnfWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RlZEF0dHJpYnV0ZXM7XG4gICAgICB9LCBbXSlcbiAgICAgIC5qb2luKCc7Jyk7XG4gIH1cblxuICAvKipcbiAgICAqIEZpbHRlcnMgdGhlIGV4aXN0aW5nIGF0dHJpYnV0ZXMgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS4gRGlzY2FyZHMgYW55IGF0dHJpYnV0ZXNcbiAgICAqIHdoaWNoIGRvbid0IG1hdGNoIHRoZSBhbGxvd2xpc3QuXG4gICAgKlxuICAgICogQHBhcmFtICB7b2JqZWN0fSBzZWxlY3RlZFJ1bGUgICAgICAgICAgICAgLSBFeGFtcGxlOiB7IGNvbG9yOiByZWQsIGZvbnQtZmFtaWx5OiBoZWx2ZXRpY2EgfVxuICAgICogQHBhcmFtICB7YXJyYXl9IGFsbG93ZWREZWNsYXJhdGlvbnNMaXN0ICAgLSBMaXN0IG9mIGRlY2xhcmF0aW9ucyB3aGljaCBwYXNzIHRoZSBhbGxvd2xpc3QuXG4gICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZU9iamVjdCAgICAgICAgICAtIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgY3NzIHByb3BlcnR5LlxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHJpYnV0ZU9iamVjdC50eXBlICAgLSBUeXBpY2FsbHkgJ2RlY2xhcmF0aW9uJy5cbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyaWJ1dGVPYmplY3QucHJvcCAgIC0gVGhlIENTUyBwcm9wZXJ0eSwgaS5lICdjb2xvcicuXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gYXR0cmlidXRlT2JqZWN0LnZhbHVlICAtIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHRvIHRoZSBjc3MgcHJvcGVydHksIGkuZSAncmVkJy5cbiAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSAgICAgICAgICAgICAgICAgICAgICAgIC0gV2hlbiB1c2VkIGluIEFycmF5LnJlZHVjZSwgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgRGVjbGFyYXRpb24gb2JqZWN0c1xuICAgICovXG4gIGZ1bmN0aW9uIGZpbHRlckRlY2xhcmF0aW9ucyhzZWxlY3RlZFJ1bGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFsbG93ZWREZWNsYXJhdGlvbnNMaXN0LCBhdHRyaWJ1dGVPYmplY3QpIHtcbiAgICAgIC8vIElmIHRoaXMgcHJvcGVydHkgaXMgYWxsb3dsaXN0ZWQuLi5cbiAgICAgIGlmIChoYXMoc2VsZWN0ZWRSdWxlLCBhdHRyaWJ1dGVPYmplY3QucHJvcCkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlc1JlZ2V4ID0gc2VsZWN0ZWRSdWxlW2F0dHJpYnV0ZU9iamVjdC5wcm9wXS5zb21lKGZ1bmN0aW9uKHJlZ3VsYXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoYXR0cmlidXRlT2JqZWN0LnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXNSZWdleCkge1xuICAgICAgICAgIGFsbG93ZWREZWNsYXJhdGlvbnNMaXN0LnB1c2goYXR0cmlidXRlT2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbG93ZWREZWNsYXJhdGlvbnNMaXN0O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJDbGFzc2VzKGNsYXNzZXMsIGFsbG93ZWQsIGFsbG93ZWRHbG9icykge1xuICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgLy8gVGhlIGNsYXNzIGF0dHJpYnV0ZSBpcyBhbGxvd2VkIHdpdGhvdXQgZmlsdGVyaW5nIG9uIHRoaXMgdGFnXG4gICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG4gICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgICByZXR1cm4gY2xhc3Nlcy5maWx0ZXIoZnVuY3Rpb24oY2xzcykge1xuICAgICAgcmV0dXJuIGFsbG93ZWQuaW5kZXhPZihjbHNzKSAhPT0gLTEgfHwgYWxsb3dlZEdsb2JzLnNvbWUoZnVuY3Rpb24oZ2xvYikge1xuICAgICAgICByZXR1cm4gZ2xvYi50ZXN0KGNsc3MpO1xuICAgICAgfSk7XG4gICAgfSkuam9pbignICcpO1xuICB9XG59XG5cbi8vIERlZmF1bHRzIGFyZSBhY2Nlc3NpYmxlIHRvIHlvdSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoZW0gYXMgYSBzdGFydGluZyBwb2ludFxuLy8gcHJvZ3JhbW1hdGljYWxseSBpZiB5b3Ugd2lzaFxuXG5jb25zdCBodG1sUGFyc2VyRGVmYXVsdHMgPSB7XG4gIGRlY29kZUVudGl0aWVzOiB0cnVlXG59O1xuc2FuaXRpemVIdG1sLmRlZmF1bHRzID0ge1xuICBhbGxvd2VkVGFnczogW1xuICAgIC8vIFNlY3Rpb25zIGRlcml2ZWQgZnJvbSBNRE4gZWxlbWVudCBjYXRlZ29yaWVzIGFuZCBsaW1pdGVkIHRvIHRoZSBtb3JlXG4gICAgLy8gYmVuaWduIGNhdGVnb3JpZXMuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50XG4gICAgLy8gQ29udGVudCBzZWN0aW9uaW5nXG4gICAgJ2FkZHJlc3MnLCAnYXJ0aWNsZScsICdhc2lkZScsICdmb290ZXInLCAnaGVhZGVyJyxcbiAgICAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGdyb3VwJyxcbiAgICAnbWFpbicsICduYXYnLCAnc2VjdGlvbicsXG4gICAgLy8gVGV4dCBjb250ZW50XG4gICAgJ2Jsb2NrcXVvdGUnLCAnZGQnLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJyxcbiAgICAnaHInLCAnbGknLCAnbWFpbicsICdvbCcsICdwJywgJ3ByZScsICd1bCcsXG4gICAgLy8gSW5saW5lIHRleHQgc2VtYW50aWNzXG4gICAgJ2EnLCAnYWJicicsICdiJywgJ2JkaScsICdiZG8nLCAnYnInLCAnY2l0ZScsICdjb2RlJywgJ2RhdGEnLCAnZGZuJyxcbiAgICAnZW0nLCAnaScsICdrYmQnLCAnbWFyaycsICdxJyxcbiAgICAncmInLCAncnAnLCAncnQnLCAncnRjJywgJ3J1YnknLFxuICAgICdzJywgJ3NhbXAnLCAnc21hbGwnLCAnc3BhbicsICdzdHJvbmcnLCAnc3ViJywgJ3N1cCcsICd0aW1lJywgJ3UnLCAndmFyJywgJ3dicicsXG4gICAgLy8gVGFibGUgY29udGVudFxuICAgICdjYXB0aW9uJywgJ2NvbCcsICdjb2xncm91cCcsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0Zm9vdCcsICd0aCcsXG4gICAgJ3RoZWFkJywgJ3RyJ1xuICBdLFxuICAvLyBUYWdzIHRoYXQgY2Fubm90IGJlIGJvb2xlYW5cbiAgbm9uQm9vbGVhbkF0dHJpYnV0ZXM6IFtcbiAgICAnYWJicicsICdhY2NlcHQnLCAnYWNjZXB0LWNoYXJzZXQnLCAnYWNjZXNza2V5JywgJ2FjdGlvbicsXG4gICAgJ2FsbG93JywgJ2FsdCcsICdhcycsICdhdXRvY2FwaXRhbGl6ZScsICdhdXRvY29tcGxldGUnLFxuICAgICdibG9ja2luZycsICdjaGFyc2V0JywgJ2NpdGUnLCAnY2xhc3MnLCAnY29sb3InLCAnY29scycsXG4gICAgJ2NvbHNwYW4nLCAnY29udGVudCcsICdjb250ZW50ZWRpdGFibGUnLCAnY29vcmRzJywgJ2Nyb3Nzb3JpZ2luJyxcbiAgICAnZGF0YScsICdkYXRldGltZScsICdkZWNvZGluZycsICdkaXInLCAnZGlybmFtZScsICdkb3dubG9hZCcsXG4gICAgJ2RyYWdnYWJsZScsICdlbmN0eXBlJywgJ2VudGVya2V5aGludCcsICdmZXRjaHByaW9yaXR5JywgJ2ZvcicsXG4gICAgJ2Zvcm0nLCAnZm9ybWFjdGlvbicsICdmb3JtZW5jdHlwZScsICdmb3JtbWV0aG9kJywgJ2Zvcm10YXJnZXQnLFxuICAgICdoZWFkZXJzJywgJ2hlaWdodCcsICdoaWRkZW4nLCAnaGlnaCcsICdocmVmJywgJ2hyZWZsYW5nJyxcbiAgICAnaHR0cC1lcXVpdicsICdpZCcsICdpbWFnZXNpemVzJywgJ2ltYWdlc3Jjc2V0JywgJ2lucHV0bW9kZScsXG4gICAgJ2ludGVncml0eScsICdpcycsICdpdGVtaWQnLCAnaXRlbXByb3AnLCAnaXRlbXJlZicsICdpdGVtdHlwZScsXG4gICAgJ2tpbmQnLCAnbGFiZWwnLCAnbGFuZycsICdsaXN0JywgJ2xvYWRpbmcnLCAnbG93JywgJ21heCcsXG4gICAgJ21heGxlbmd0aCcsICdtZWRpYScsICdtZXRob2QnLCAnbWluJywgJ21pbmxlbmd0aCcsICduYW1lJyxcbiAgICAnbm9uY2UnLCAnb3B0aW11bScsICdwYXR0ZXJuJywgJ3BpbmcnLCAncGxhY2Vob2xkZXInLCAncG9wb3ZlcicsXG4gICAgJ3BvcG92ZXJ0YXJnZXQnLCAncG9wb3ZlcnRhcmdldGFjdGlvbicsICdwb3N0ZXInLCAncHJlbG9hZCcsXG4gICAgJ3JlZmVycmVycG9saWN5JywgJ3JlbCcsICdyb3dzJywgJ3Jvd3NwYW4nLCAnc2FuZGJveCcsICdzY29wZScsXG4gICAgJ3NoYXBlJywgJ3NpemUnLCAnc2l6ZXMnLCAnc2xvdCcsICdzcGFuJywgJ3NwZWxsY2hlY2snLCAnc3JjJyxcbiAgICAnc3JjZG9jJywgJ3NyY2xhbmcnLCAnc3Jjc2V0JywgJ3N0YXJ0JywgJ3N0ZXAnLCAnc3R5bGUnLFxuICAgICd0YWJpbmRleCcsICd0YXJnZXQnLCAndGl0bGUnLCAndHJhbnNsYXRlJywgJ3R5cGUnLCAndXNlbWFwJyxcbiAgICAndmFsdWUnLCAnd2lkdGgnLCAnd3JhcCcsXG4gICAgLy8gRXZlbnQgaGFuZGxlcnNcbiAgICAnb25hdXhjbGljaycsICdvbmFmdGVycHJpbnQnLCAnb25iZWZvcmVtYXRjaCcsICdvbmJlZm9yZXByaW50JyxcbiAgICAnb25iZWZvcmV1bmxvYWQnLCAnb25iZWZvcmV0b2dnbGUnLCAnb25ibHVyJywgJ29uY2FuY2VsJyxcbiAgICAnb25jYW5wbGF5JywgJ29uY2FucGxheXRocm91Z2gnLCAnb25jaGFuZ2UnLCAnb25jbGljaycsICdvbmNsb3NlJyxcbiAgICAnb25jb250ZXh0bG9zdCcsICdvbmNvbnRleHRtZW51JywgJ29uY29udGV4dHJlc3RvcmVkJywgJ29uY29weScsXG4gICAgJ29uY3VlY2hhbmdlJywgJ29uY3V0JywgJ29uZGJsY2xpY2snLCAnb25kcmFnJywgJ29uZHJhZ2VuZCcsXG4gICAgJ29uZHJhZ2VudGVyJywgJ29uZHJhZ2xlYXZlJywgJ29uZHJhZ292ZXInLCAnb25kcmFnc3RhcnQnLFxuICAgICdvbmRyb3AnLCAnb25kdXJhdGlvbmNoYW5nZScsICdvbmVtcHRpZWQnLCAnb25lbmRlZCcsXG4gICAgJ29uZXJyb3InLCAnb25mb2N1cycsICdvbmZvcm1kYXRhJywgJ29uaGFzaGNoYW5nZScsICdvbmlucHV0JyxcbiAgICAnb25pbnZhbGlkJywgJ29ua2V5ZG93bicsICdvbmtleXByZXNzJywgJ29ua2V5dXAnLFxuICAgICdvbmxhbmd1YWdlY2hhbmdlJywgJ29ubG9hZCcsICdvbmxvYWRlZGRhdGEnLCAnb25sb2FkZWRtZXRhZGF0YScsXG4gICAgJ29ubG9hZHN0YXJ0JywgJ29ubWVzc2FnZScsICdvbm1lc3NhZ2VlcnJvcicsICdvbm1vdXNlZG93bicsXG4gICAgJ29ubW91c2VlbnRlcicsICdvbm1vdXNlbGVhdmUnLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsXG4gICAgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdvbm9mZmxpbmUnLCAnb25vbmxpbmUnLCAnb25wYWdlaGlkZScsXG4gICAgJ29ucGFnZXNob3cnLCAnb25wYXN0ZScsICdvbnBhdXNlJywgJ29ucGxheScsICdvbnBsYXlpbmcnLFxuICAgICdvbnBvcHN0YXRlJywgJ29ucHJvZ3Jlc3MnLCAnb25yYXRlY2hhbmdlJywgJ29ucmVzZXQnLCAnb25yZXNpemUnLFxuICAgICdvbnJlamVjdGlvbmhhbmRsZWQnLCAnb25zY3JvbGwnLCAnb25zY3JvbGxlbmQnLFxuICAgICdvbnNlY3VyaXR5cG9saWN5dmlvbGF0aW9uJywgJ29uc2Vla2VkJywgJ29uc2Vla2luZycsICdvbnNlbGVjdCcsXG4gICAgJ29uc2xvdGNoYW5nZScsICdvbnN0YWxsZWQnLCAnb25zdG9yYWdlJywgJ29uc3VibWl0JywgJ29uc3VzcGVuZCcsXG4gICAgJ29udGltZXVwZGF0ZScsICdvbnRvZ2dsZScsICdvbnVuaGFuZGxlZHJlamVjdGlvbicsICdvbnVubG9hZCcsXG4gICAgJ29udm9sdW1lY2hhbmdlJywgJ29ud2FpdGluZycsICdvbndoZWVsJ1xuICBdLFxuICBkaXNhbGxvd2VkVGFnc01vZGU6ICdkaXNjYXJkJyxcbiAgYWxsb3dlZEF0dHJpYnV0ZXM6IHtcbiAgICBhOiBbICdocmVmJywgJ25hbWUnLCAndGFyZ2V0JyBdLFxuICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBhbGxvdyBpbWcgaXRzZWxmIGJ5IGRlZmF1bHQsIGJ1dFxuICAgIC8vIHRoZXNlIGF0dHJpYnV0ZXMgd291bGQgbWFrZSBzZW5zZSBpZiB3ZSBkaWQuXG4gICAgaW1nOiBbICdzcmMnLCAnc3Jjc2V0JywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnLCAnbG9hZGluZycgXVxuICB9LFxuICBhbGxvd2VkRW1wdHlBdHRyaWJ1dGVzOiBbXG4gICAgJ2FsdCdcbiAgXSxcbiAgLy8gTG90cyBvZiB0aGVzZSB3b24ndCBjb21lIHVwIGJ5IGRlZmF1bHQgYmVjYXVzZSB3ZSBkb24ndCBhbGxvdyB0aGVtXG4gIHNlbGZDbG9zaW5nOiBbICdpbWcnLCAnYnInLCAnaHInLCAnYXJlYScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2lucHV0JywgJ2xpbmsnLCAnbWV0YScgXSxcbiAgLy8gVVJMIHNjaGVtZXMgd2UgcGVybWl0XG4gIGFsbG93ZWRTY2hlbWVzOiBbICdodHRwJywgJ2h0dHBzJywgJ2Z0cCcsICdtYWlsdG8nLCAndGVsJyBdLFxuICBhbGxvd2VkU2NoZW1lc0J5VGFnOiB7fSxcbiAgYWxsb3dlZFNjaGVtZXNBcHBsaWVkVG9BdHRyaWJ1dGVzOiBbICdocmVmJywgJ3NyYycsICdjaXRlJyBdLFxuICBhbGxvd1Byb3RvY29sUmVsYXRpdmU6IHRydWUsXG4gIGVuZm9yY2VIdG1sQm91bmRhcnk6IGZhbHNlLFxuICBwYXJzZVN0eWxlQXR0cmlidXRlczogdHJ1ZVxufTtcblxuc2FuaXRpemVIdG1sLnNpbXBsZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKG5ld1RhZ05hbWUsIG5ld0F0dHJpYnMsIG1lcmdlKSB7XG4gIG1lcmdlID0gKG1lcmdlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG1lcmdlO1xuICBuZXdBdHRyaWJzID0gbmV3QXR0cmlicyB8fCB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24odGFnTmFtZSwgYXR0cmlicykge1xuICAgIGxldCBhdHRyaWI7XG4gICAgaWYgKG1lcmdlKSB7XG4gICAgICBmb3IgKGF0dHJpYiBpbiBuZXdBdHRyaWJzKSB7XG4gICAgICAgIGF0dHJpYnNbYXR0cmliXSA9IG5ld0F0dHJpYnNbYXR0cmliXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlicyA9IG5ld0F0dHJpYnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ05hbWU6IG5ld1RhZ05hbWUsXG4gICAgICBhdHRyaWJzOiBhdHRyaWJzXG4gICAgfTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qIVxuICogaXMtcGxhaW4tb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICB2YXIgY3Rvcixwcm90O1xuXG4gIGlmIChpc09iamVjdChvKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBoYXMgbW9kaWZpZWQgY29uc3RydWN0b3JcbiAgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGVcbiAgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoaXNPYmplY3QocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgY29uc3RydWN0b3IgZG9lcyBub3QgaGF2ZSBhbiBPYmplY3Qtc3BlY2lmaWMgbWV0aG9kXG4gIGlmIChwcm90Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTW9zdCBsaWtlbHkgYSBwbGFpbiBPYmplY3RcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4iLCJpbXBvcnQgc2FuaXRpemVIdG1sIGZyb20gJ3Nhbml0aXplLWh0bWwnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiB1c2VkIHRvIGNvbnZlcnQgSFRNTCBzdHJpbmdzIGludG8gSFRNTCBlbGVtZW50cyBhdCBydW50aW1lLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZWxlbWVudFRleHQgXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2FuaXRpemUgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5lKGVsZW1lbnRUZXh0LCBzYW5pdGl6ZSA9IHRydWUpe1xyXG4gICAgLy8gbGV0IGVsZW1lbnRUeXBlID0gL1tcXHNcXFNdKj88KC4qPyk+Ly5leGVjKGVsZW1lbnRUZXh0KVsxXVxyXG4gICAgLy8gaWYoZWxlbWVudFR5cGUuaW5jbHVkZXMoXCIgXCIpPT10cnVlKWVsZW1lbnRUeXBlID0gZWxlbWVudFR5cGUuc3Vic3RyaW5nKDAsIGVsZW1lbnRUeXBlLmluZGV4T2YoXCIgXCIpKVxyXG4gICAgLy8gbGV0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlKVxyXG4gICAgbGV0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICBlLnN0eWxlLmFsbCA9IFwidW5zZXRcIlxyXG4gICAgZS5pbm5lckhUTUwgPSBzYW5pdGl6ZUh0bWwoZWxlbWVudFRleHQpXHJcbiAgICByZXR1cm4gZVxyXG59XHJcbiIsIlxyXG5pbXBvcnQge25lfSBmcm9tICcuL2JhZGVsLmpzJ1xyXG5pbXBvcnQgc2FuaXRpemVIdG1sIGZyb20gJ3Nhbml0aXplLWh0bWwnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFBhZ2UoKXtcclxuICAgIFxyXG5cclxuICAgIHJldHVybiBuZShgXHJcbiAgICAgICAgPGgxIHN0eWxlPVwiY29sb3I6IGdyZWVuXCI+SGVsbG8gJHsxKzF9PC9oMT5cclxuICAgIGApXHJcbn1cclxuIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIGxldCBpID0gc2l6ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoKSB8IDBdXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG59XG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSAnJ1xuICBsZXQgaSA9IHNpemVcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogNjQpIHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbm1vZHVsZS5leHBvcnRzID0geyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0IH1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgKiBhcyBiYWRlbCBmcm9tICcuL2JhZGVsLmpzJ1xyXG5cclxuaW1wb3J0ICogYXMgUXVpeiBmcm9tICcuL3F1aXouanMnXHJcblxyXG5jb25zdCBwYWdlcyA9IHtcclxuICAgIFwiL3F1aXouaHRtbFwiOiBRdWl6LlBhZ2VcclxufVxyXG5cclxuaWYocGFnZXNbd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lXSl7XHJcbiAgICBsZXQgcGFnZUhUTUwgPSBwYWdlc1t3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVdKCk7XHJcblxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYWdlXCIpLnJlcGxhY2VDaGlsZHJlbihwYWdlSFRNTClcclxufWVsc2V7XHJcbiAgICBjb25zb2xlLmxvZyhcIk5vIHBhZ2UgZm91bmQhXCIpO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9